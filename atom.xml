<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>xgfe</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xgfe.github.io/"/>
  <updated>2018-12-04T03:01:22.504Z</updated>
  <id>http://xgfe.github.io/</id>
  
  <author>
    <name>xgfe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅谈 React-Native 与 Redux 数据流</title>
    <link href="http://xgfe.github.io/2018/11/25/juga/%E6%B5%85%E8%B0%88React-Native%E4%B8%8ERedux%E6%95%B0%E6%8D%AE%E6%B5%81/"/>
    <id>http://xgfe.github.io/2018/11/25/juga/浅谈React-Native与Redux数据流/</id>
    <published>2018-11-24T16:00:00.000Z</published>
    <updated>2018-12-04T03:01:22.504Z</updated>
    
    <content type="html"><![CDATA[<p>本文是对 React-Native 组件和模块开发的一个简单的介绍，以及对于 Redux 单向数据流的深入学习。</p><a id="more"></a><h4 id="React-Native-介绍"><a href="#React-Native-介绍" class="headerlink" title="React-Native 介绍"></a>React-Native 介绍</h4><ul><li><p>React-Native 在官网上给的定义是：使用 JavaScript 和 React 编写原生移动应用。在设计原理上是和 React 一致的，可以通过生命是的组件机制来搭建丰富多彩的用户界面。RN 产出的不是“网页应用”或者“HTML5应用”，RN 所产出的其实是一个真正的移动应用。从感受上来说和 Objective-C 或 Java 编写的应用基本是一样的。</p></li><li><p><a href="https://reactnative.cn/" target="_blank" rel="noopener">RN官网</a></p></li></ul><h4 id="组件开发"><a href="#组件开发" class="headerlink" title="组件开发"></a>组件开发</h4><ul><li><p>官网上有教大家如何构建一个新的 React-Native 应用，这里就不多说了，这里直接切入组件的开发。可以在项目里面新建一个 Component 组件文件夹，专门用来存放组件。在该文件家里面建一个 TestComponen 子文件夹，然后在此子文件下面再建 TestComponent.js 和TestComponentStyle.js 两个文件夹，组件的逻辑写在TestComponent.js 文件下，样式写在 TestComponentStyle.js 文件下。<br><img src="https://wx4.sinaimg.cn/mw690/ba56005dgy1fxkcvc82f8j20hk03uaaa.jpg" alt="文件结构"></p></li><li><p>JS文件分析</p></li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123;Component&#125; <span class="keyword">from</span> <span class="string">'react'</span>; <span class="comment">//引入Component</span></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  View,</span><br><span class="line">  Text,</span><br><span class="line">  Button</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>; <span class="comment">//引入RN原生组件</span></span><br><span class="line"><span class="keyword">import</span> &#123;Style&#125; <span class="keyword">from</span> <span class="string">'./TestComponentStyle'</span>; <span class="comment">//引入样式</span></span><br></pre></td></tr></table></figure><ul><li>简单的计数器实现</li></ul><p><img src="https://wx4.sinaimg.cn/mw690/ba56005dgy1fxkcvc2m1qj207g010dfq.jpg" alt="计数器"></p><p>点击加号数字动态变化 +1，点击减号数字动态 -1。首先这个组件由一个 Text 和两个  Button 组件组成，其中 Text 组件中有两个变量，children 作为对外暴露的属性，写在 this.props 里面，state 是组件内部的可变化的状态，写在 this.state 里面。<br>官网上是这样描述 props 和 state：我们使用两种数据来控制一个组件：props 和 state.props 是在父组件中指定，而且一经指定，在被指定的组件的生命周期中则不再改变。对于需要改变的数据，我们需要使用 state 。<br>这里先介绍一下 render 函数部分：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">render() &#123; <span class="comment">//渲染函数</span></span><br><span class="line">    <span class="keyword">const</span> &#123; </span><br><span class="line">      children</span><br><span class="line">    &#125; = <span class="keyword">this</span>.props; <span class="comment">//组件对外暴露的属性</span></span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state; <span class="comment">//组件内部的状态</span></span><br><span class="line">    <span class="keyword">return</span> ( <span class="comment">//返回要渲染的组件</span></span><br><span class="line">      &lt;View style=&#123;Style.container&#125;&gt;</span><br><span class="line">        &lt;Text style=&#123;Style.txt&#125;&gt;&#123;<span class="string">`<span class="subst">$&#123;children&#125;</span> <span class="subst">$&#123;num&#125;</span>`</span>&#125;&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Button title=&#123;'-'&#125; color=&#123;'red'&#125; onPress=&#123;this.clickBtnSub&#125;/</span>&gt;</span><br><span class="line">        &lt;Button title=&#123;<span class="string">'+'</span>&#125; color=&#123;<span class="string">'blue'</span>&#125; onPress=&#123;<span class="keyword">this</span>.clickBtnAdd&#125;/&gt;</span><br><span class="line">      &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br></pre></td></tr></table></figure><p>可以看到，组件的结构由一个 View 组件包裹一个 Text ，两个 Button 组件。Text 组件为展示的数字名和数字大小，Button 则是两个加减按钮。</p><p>然后可以看到 Style.container 和 Style.txt 都是引自  TestComponentStyle.js 文件。接下来我们看一下该文件。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;StyleSheet&#125; <span class="keyword">from</span> <span class="string">'react-native'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Style = StyleSheet.create(&#123;</span><br><span class="line"><span class="comment">// styles</span></span><br><span class="line">  container: &#123;</span><br><span class="line">    flexDirection: <span class="string">'row'</span>,</span><br><span class="line">    alignItems: <span class="string">'center'</span>,</span><br><span class="line">    justifyContent: <span class="string">'space-around'</span>,</span><br><span class="line">    width: <span class="number">200</span>,</span><br><span class="line">    height: <span class="number">80</span></span><br><span class="line">  &#125;,</span><br><span class="line">  txt: &#123;</span><br><span class="line">    fontSize: <span class="number">20</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>这个是 RN 样式的基本写法，这个文件专门放 css 层的东西。这里要注意的是 css 的属性值接受的是字符串形式，在 RN 里面的 css 很多样式的值都被阉割了，所以这点要特别注意，这里有个推荐的网站可以看常用的RN样式：<br><a href="https://shenbao.github.io/ishehui/html/RN%20%E5%9F%BA%E7%A1%80/React%20Native%20%E6%A0%B7%E5%BC%8F%E8%A1%A8%E6%8C%87%E5%8D%97.html" target="_blank" rel="noopener">RN css 样式</a></p><p>然后可以看到 Button 组件里面分别有一个点击事件。clickBtnSub 事件处理减 1，clickBtnAdd 处理加 1。<br>这里我推荐是使用箭头函数来定义函数，就可以在该组件的作用域里面直接调用。<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">clickBtnSub = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: num - <span class="number">1</span>&#125;);<span class="comment">//调用setState()函数，改变组件内部的状态</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> clickBtnAdd = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">   <span class="keyword">const</span> &#123;num&#125; = <span class="keyword">this</span>.state;</span><br><span class="line">   <span class="keyword">this</span>.setState(&#123;<span class="attr">num</span>: num + <span class="number">1</span>&#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><h4 id="模块开发"><a href="#模块开发" class="headerlink" title="模块开发"></a>模块开发</h4><p>组件写好之后可以引入到某个功能模块中使用。这里我们可以建一个 TestModule 文件夹来存放模块文件，里面可以建这么几个文件。如下图<br><img src="https://wx2.sinaimg.cn/mw690/ba56005dgy1fxkcvcd0coj20ia08o755.jpg" alt="文件结构"><br>接下来我们一个一个来介绍这几个文件的用处。<br>其实上面的组件计数器，除了使用 setState 来改变数字还可以使用 Redux 来完成这件事。<br>接下来就让我们来看看如何使用 Redux 完成</p><ul><li>TestModule.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//import部分省略</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestModule</span> <span class="keyword">extends</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  _renderTitle = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;Text&gt;计数器&lt;<span class="regexp">/Text&gt;</span></span><br><span class="line"><span class="regexp">    )</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp"> render() &#123;</span></span><br><span class="line"><span class="regexp">    const &#123;num&#125; = this.props.data /</span><span class="regexp">/从store取得的数据，在reducer里面初始化</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;View&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*引入计数器组件*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;View style=&#123;Style.container&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this._renderTitle()&#125;</span></span><br><span class="line"><span class="regexp">          &lt;TestComponent children=&#123;'数字: '&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">        &#123;/</span>*使用Redux完成的计数器*<span class="regexp">/&#125;</span></span><br><span class="line"><span class="regexp">        &lt;View&gt;</span></span><br><span class="line"><span class="regexp">          &#123;this._renderTitle()&#125;</span></span><br><span class="line"><span class="regexp">          &lt;Text&gt;&#123;num&#125;&lt;/</span>Text&gt;</span><br><span class="line">          &lt;Button title=&#123;<span class="string">'-'</span>&#125; color=&#123;<span class="string">'red'</span>&#125; onPress=&#123;() =&gt; <span class="keyword">this</span>.props.sub(num)&#125; /&gt;</span><br><span class="line">          &lt;Button title=&#123;<span class="string">'+'</span>&#125; color=&#123;<span class="string">'blue'</span>&#125; onPress=&#123;() =&gt; <span class="keyword">this</span>.props.add(num)&#125; /&gt;</span><br><span class="line">        &lt;<span class="regexp">/View&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>View&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> connect(</span><br><span class="line">  (state) =&gt; (&#123; <span class="comment">//state其实就是store.getState()，得到数据</span></span><br><span class="line">    data: state.modules[CONSTANTS.NAME]</span><br><span class="line">  &#125;),</span><br><span class="line">  (dispatch) =&gt; (&#123; <span class="comment">//dispatch是一个发布器他需要接受一个对象用于触发reducer</span></span><br><span class="line">    <span class="comment">// actions</span></span><br><span class="line">    add: <span class="function">(<span class="params">num</span>) =&gt;</span> dispatch(actions.add(num)),</span><br><span class="line">    sub: <span class="function">(<span class="params">num</span>) =&gt;</span> dispatch(actions.sub(num))</span><br><span class="line">  &#125;)</span><br><span class="line">)(TestModule);</span><br></pre></td></tr></table></figure></li></ul><p>模块的主要页面内容都是写在这个文件里面，这里我们直接从 components 引入了 TestComponent 组件进行使用。直接将组件当成标签名使用 <testcomponent>。这就是自定义组件方便的地方。中间可以看到组件渲染不一定要都放在 render() 里面，可以利用一个渲染函数，单独抽出来，这样可以让程序的结构上看起来更加明了，不要让所有的子组件都堆积在 render() 函数中。当然如果抽出来的组件内容太少，就没必要抽了。<br>这个文件的最下面 connect 函数是 Provider 提供的一种 store 注入方式，其中封装了两个函数，第一个函数其实是 store.getState() ，是从 store 得到数据的。<br>第二个函数 dispatch 是一个触发器，在里面写 action 函数来触发 reducer 来对数据进行所需要的操作。dispatch 触发 TestModuleActions.js 里面的函数。下面就介绍一下 TestModuleActions.js 文件<br>这里我们写了一个加一个减函数，接着在 actions.js 文件里定义这两个 action 函数。</testcomponent></p><ul><li>TestModuleActios.js文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  ADD,</span><br><span class="line">  SUB</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> add = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: ADD, <span class="comment">//必填type类型</span></span><br><span class="line">      payload: &#123;</span><br><span class="line">        num: num</span><br><span class="line">      &#125; <span class="comment">//数据传到reducer去处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> sub = <span class="function">(<span class="params">num</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function">(<span class="params">dispatch</span>) =&gt;</span> &#123;</span><br><span class="line">    dispatch(&#123;</span><br><span class="line">      type: SUB, <span class="comment">//必填type类型</span></span><br><span class="line">      payload: &#123;</span><br><span class="line">        num: num</span><br><span class="line">      &#125; <span class="comment">//数据传到reducer去处理</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件主要是写 actions 的文件，定义 action，dispatch中根据 type 类型去 TestModuleReducers.js 那处理数据。通过 payload 把数据传到 reducer 里面。</p><ul><li>TestModuleConstants.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> NAME = <span class="string">'testmodule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// action types</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ADD = <span class="string">`<span class="subst">$&#123;NAME&#125;</span>/ADD`</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> SUB = <span class="string">`<span class="subst">$&#123;NAME&#125;</span>/SUB`</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件用来放全局常量。这里定义了 ADD 和 SUB 。</p><ul><li>TestModuleReducer.js 文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;handleActions&#125; <span class="keyword">from</span> <span class="string">'redux-actions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;ADD, SUB&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> initialState = &#123; <span class="comment">//初始化数据的地方</span></span><br><span class="line">  num: <span class="number">0</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> handleActions(&#123; <span class="comment">//处理数据的地方</span></span><br><span class="line">  <span class="comment">// actions</span></span><br><span class="line">  [ADD]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = action.payload; <span class="comment">//action里面传来的值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回处理后的数据</span></span><br><span class="line">      ...state,</span><br><span class="line">      num: num + <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  [SUB]: <span class="function">(<span class="params">state, action</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> &#123;num&#125; = action.payload; <span class="comment">//action里面传来的值</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回处理后的数据</span></span><br><span class="line">      ...state,</span><br><span class="line">      num: num - <span class="number">1</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, initialState);</span><br></pre></td></tr></table></figure></li></ul><p>reducer 利用 action.payload 拿到从 action 传来的数据，处理数据，处理完返回。<br>这里就要说一下Redux的数据流了，请先看一下下图：<br><img src="https://wx3.sinaimg.cn/mw690/ba56005dgy1fxkcvc6dthj20xm0mk77l.jpg" alt="Redux Flow"></p><p>(图片来自网上)<br>这里我们在TestModule.js 文件中的 connect 中 dispatch( action ) ，把原先的计数器中数字 num (图中 previousState )，和 action ( ADD 或 SUB )传到了 reducer 里面，根据 actions 文件里面的 action 的 TYPE 来执行各自的数据处理。处理完之后就有新的 newState 传到 Store ，再传到组件中，驱动组件改变状态重新渲染。</p><ul><li>index.js文件<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="built_in">module</span> <span class="keyword">from</span> <span class="string">'./TestModule'</span>;</span><br><span class="line"><span class="keyword">import</span> reducer <span class="keyword">from</span> <span class="string">'./TestModuleReducer'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> actions <span class="keyword">from</span> <span class="string">'./TestModuleActions'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123;NAME&#125; <span class="keyword">from</span> <span class="string">'./TestModuleConstants'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  NAME,</span><br><span class="line">  <span class="built_in">module</span>,</span><br><span class="line">  reducer,</span><br><span class="line">  actions</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>这个文件将 NAME，module，reducer，actions 暴露出去。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>使用 RN + Redux 为基础框架开发已有三个多月，很多东西都还需要多加学习研究，这只是最基础的组件和模块开发。</p><p>组件开发总的时间为十的话，一定要思考占七，动手写占三，认真的多思考组件的构造，这样在动手写的时候才能尽量的避免结构的冗余，或者是样式的冗余，而且要想为什么做这个组件，必需能在某个项目中能多次的使用该组件，这样组件的开发才会变得有意义，不然一个组件只用一次的话，就没有必要单独拿出来封装成一个组件。另外就是组件写的过程尽量的思考拓展性，很多结构不要写死了，这次组件可能只需要展示 2 个 tab，但是下一次就不一定了，所以写的时候要多想。</p><p>模块开发的时候，尽量保持结构层次的清晰，这样的话代码的维护就会得比较轻松，模块里有很多独立的功能部分可以单抽出来做成一个渲染函数，这样就能让 render 函数看起来没那么的冗余，且结构不会过于复杂。一些点击事件和逻辑功能也是能单独抽出来写成事件函数，这样的话，调试出问题的时候就可以快速定位到问题代码块。还有就是尽量避免写一些重复的组件，能简化的就简化，可以考虑使用 map 函数来渲染重复的组件。</p><p>虽然这里用 Redux 也实现了计数器，但是其实是杀鸡用牛刀了，这样的简单的数据重新渲染其实大可不必，用 setState 就可以了，当然 Redux 也有其优点，他让数据和我们的组件模块解耦，数据单独处理了，不需要在每一个组件中来对 state 进行管理，需要的数据从上游作为 props 传进来了。不过经常可以看到这么一句话，如果你不知道你为什么需要 Redux，那你就是不需要 Redux..   (=. = redux 对于新手真的有点不友好)</p><h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><ul><li><a href="https://blog.csdn.net/Helloyongwei/article/details/82937808" target="_blank" rel="noopener">Redux 的数据流</a></li><li><a href="https://www.jianshu.com/p/2a20c8485a90" target="_blank" rel="noopener">看了我这篇 RN 你就入门了</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文是对 React-Native 组件和模块开发的一个简单的介绍，以及对于 Redux 单向数据流的深入学习。&lt;/p&gt;
    
    </summary>
    
      <category term="juga" scheme="http://xgfe.github.io/categories/juga/"/>
    
    
      <category term="React-Native" scheme="http://xgfe.github.io/tags/React-Native/"/>
    
      <category term="Redux" scheme="http://xgfe.github.io/tags/Redux/"/>
    
  </entry>
  
  <entry>
    <title>koa-router 源码解读</title>
    <link href="http://xgfe.github.io/2018/09/27/zuopengfei/koa-router/"/>
    <id>http://xgfe.github.io/2018/09/27/zuopengfei/koa-router/</id>
    <published>2018-09-27T11:18:00.000Z</published>
    <updated>2018-12-07T07:40:15.959Z</updated>
    
    <content type="html"><![CDATA[<p>本文通过阅读 koa-router 的源码归纳了 koa-router 涉及到的 router 和 layer 两个对象的关系；以及梳理了 koa-router 处理请求的整体流程。</p><a id="more"></a><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>如果实现一个简单的路由，可以解析<code>node</code>原生<code>request即IncomingMessage</code>对象的<code>url</code>属性，用 <code>if...else</code>判断路径从而返回不同的结果；当然也可以利用<code>koa</code>的<code>request</code>对象和<code>response</code>对象来处理。下面就是用<code>koa</code>实现的简单路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">page</span>)</span>&#123;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> pageUrl = <span class="string">`./page/<span class="subst">$&#123;page&#125;</span>`</span>;</span><br><span class="line">        fs.readFile(pageUrl, <span class="string">"binary"</span>, (err,data) =&gt; &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="number">444</span>);</span><br><span class="line">            <span class="keyword">if</span> (err) &#123;</span><br><span class="line">                reject(err)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                resolve(data);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">route</span>(<span class="params">url</span>)</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">let</span> page = <span class="string">'404.html'</span>;</span><br><span class="line">    <span class="keyword">switch</span>(url)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/'</span>:</span><br><span class="line">            page =<span class="string">'index.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/index'</span>:</span><br><span class="line">            page =<span class="string">'index.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/todo'</span>:</span><br><span class="line">            page = <span class="string">'todo.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">'/404'</span>:</span><br><span class="line">            page = <span class="string">'404.html'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> render(page);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> html;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">app.use(<span class="keyword">async</span>(ctx)=&gt;&#123;</span><br><span class="line">    <span class="keyword">let</span> url = ctx.request.url;</span><br><span class="line">    <span class="keyword">let</span> html = <span class="keyword">await</span> route(url);</span><br><span class="line">    </span><br><span class="line">    ctx.body = html;</span><br><span class="line">&#125;)</span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'starting at 3000'</span>);</span><br></pre></td></tr></table></figure><p>缺点</p><ul><li>路由越多消耗的性能也就越大</li><li>不能对特殊路由添加中间件</li><li>也没有处理响应头类型</li></ul><p>更好的方法是使用面向对象的方式，根据请求的<code>path</code>和<code>method</code>执行相应的中间件处理函数；而在实际开发中我们常用的是<code>koa</code>路由库<a href="https://github.com/alexmingoia/koa-router" target="_blank" rel="noopener">koa-router</a>。本文通过解析<code>koa-router</code>的源码来达到深入学习其原理的目的。</p><h2 id="kao-router的简单使用demo"><a href="#kao-router的简单使用demo" class="headerlink" title="kao-router的简单使用demo"></a>kao-router的简单使用demo</h2><p>使用<code>koa-router</code>第一步就是新建一个<code>router</code>实例对象:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> Koa = <span class="built_in">require</span>(<span class="string">'koa'</span>);</span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"><span class="keyword">const</span> pagePromptRouter <span class="built_in">require</span>(<span class="string">'./controllers/pagePrompt'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Koa();</span><br><span class="line"><span class="comment">// 创建router实例对象</span></span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> KoaRouter();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 嵌套路由</span></span><br><span class="line">router.use(<span class="string">'/admin/prompt'</span>, pagePromptRouter.routes(), pagePrompt.allowedMethods());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加路由中间件</span></span><br><span class="line">app.use(router.routes()); </span><br><span class="line"><span class="comment">// 对请求进行一些限制处理</span></span><br><span class="line">app.use(router.allowedMethods()); </span><br><span class="line"></span><br><span class="line">app.listen(<span class="number">3000</span>);</span><br></pre></td></tr></table></figure><p>构建应用的时候，我们的首要目标就是创建多个<code>CGI</code>接口以适配不同的业务需求，那么接下来就需要注册对应的路由：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> KoaRouter = <span class="built_in">require</span>(<span class="string">'koa-router'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> router = <span class="keyword">new</span> Router();</span><br><span class="line"></span><br><span class="line">router.get(<span class="string">'/queryPagePromptList'</span>, queryPagePromptList);</span><br><span class="line">router.post(<span class="string">'/deletePagePromptById'</span>, deletePagePromptById);</span><br><span class="line">router.post(<span class="string">'/savePagePrompt'</span>, savePagePrompt);</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">queryPagePromptList</span>(<span class="params">ctx, next</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> result = <span class="keyword">await</span> getResult();</span><br><span class="line">ctx.body = &#123;</span><br><span class="line">    data: result.data,</span><br><span class="line">    code: <span class="number">200</span></span><br><span class="line">    &#125;;</span><br><span class="line"><span class="keyword">await</span> next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后为了让<code>koa</code>实例使用我们配置后的路由模块，需要使用<code>routes()</code>方法将路由(上面的例子中为了代码分层使用了嵌套路由)加入到应用全局的中间件函数中：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app.use(router.routes());  <span class="comment">// 添加路由中间件</span></span><br><span class="line">app.use(router.allowedMethods()); <span class="comment">// 对请求进行一些限制处理</span></span><br></pre></td></tr></table></figure><h2 id="源码结构"><a href="#源码结构" class="headerlink" title="源码结构"></a>源码结构</h2><p><a href="https://github.com/alexmingoia/koa-router/blob/master/lib/router.js" target="_blank" rel="noopener">router.js</a></p><p><img src="http://vfile.meituan.net/xgfe/88ed43b2f2951c77384f10d7ff4e1a6a172778.png" alt="router"></p><p><a href="https://github.com/alexmingoia/koa-router/blob/master/lib/layer.js" target="_blank" rel="noopener">layer.js</a></p><p><img src="http://vfile.meituan.net/xgfe/190cd799e93c05d43fd05b1bda3574ad116451.png" alt="layer"></p><p>router和layer的关系</p><p><img src="http://p0.meituan.net/xgfe/b736ea9f7cc83ba0f0aeaf22782185ff20689.png" alt="router-layer"></p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><h3 id="Router-构造函数"><a href="#Router-构造函数" class="headerlink" title="Router 构造函数"></a>Router 构造函数</h3><p><code>Node</code>本身提供了数十个<code>HTTP</code>请求动词，<code>koa-router</code>只是实现了部分常用的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function Router(opts) &#123;</span><br><span class="line">  if (!(this instanceof Router)) &#123;</span><br><span class="line">    return new Router(opts);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.opts = opts || &#123;&#125;;</span><br><span class="line">  this.methods = this.opts.methods || [</span><br><span class="line">    &apos;HEAD&apos;,</span><br><span class="line">    &apos;OPTIONS&apos;,</span><br><span class="line">    &apos;GET&apos;,</span><br><span class="line">    &apos;PUT&apos;,</span><br><span class="line">    &apos;PATCH&apos;,</span><br><span class="line">    &apos;POST&apos;,</span><br><span class="line">    &apos;DELETE&apos;</span><br><span class="line">  ];</span><br><span class="line">  //省略</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="router-get-post-delete-all…"><a href="#router-get-post-delete-all…" class="headerlink" title="router.(get|post|delete|all…)()"></a>router.(get|post|delete|all…)()</h3><p>这些请求动词的实现是通过第三方模块<a href="https://github.com/jshttp/methods" target="_blank" rel="noopener">methods</a>支持的，然后<code>koa-router</code>内部进行了注册处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">// 这里的methods就是上面的methods模块提供的数组</span><br><span class="line">methods.forEach(function (method) &#123;</span><br><span class="line">  Router.prototype[method] = function (name, path, middleware) &#123;</span><br><span class="line">    var middleware;</span><br><span class="line"></span><br><span class="line">    // 这段代码做了两件事：</span><br><span class="line">    // 1.name 参数是可选的，所以要做一些参数置换的处理</span><br><span class="line">    // 2.将所有路由中间件（因为可以注册多个中间件）合并成一个数组</span><br><span class="line">    if (typeof path === &apos;string&apos; || path instanceof RegExp) &#123;</span><br><span class="line">      middleware = Array.prototype.slice.call(arguments, 2);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      middleware = Array.prototype.slice.call(arguments, 1);</span><br><span class="line">      path = name;</span><br><span class="line">      name = null;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 调用register方法</span><br><span class="line">    this.register(path, [method], middleware, &#123;</span><br><span class="line">      name: name</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return this;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>上面函数先判断<code>path</code>是否是字符串或者正则表达式，是因为注册路由的时候还可以为路由进行命名(命名空间方便管理)，然后准确地获取回调的函数数组(注册路由可以接收多个回调)， 这样如果匹配到某个路由，回调函数数组中的函数就会依次执行。留意到每个方法都会返回对象本身，也就是说注册路由的时候是可以支持链式调用的。</p><h3 id="register方法"><a href="#register方法" class="headerlink" title="register方法"></a>register方法</h3><p><code>this.register</code>接受请求路径、方法、中间件作为参数，返回已经注册的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.register = function (path, methods, middleware, opts) &#123;</span><br><span class="line">  opts = opts || &#123;&#125;;</span><br><span class="line">  var router = this;</span><br><span class="line"></span><br><span class="line">  // 全部路由</span><br><span class="line">  var stack = this.stack;</span><br><span class="line"></span><br><span class="line">  // 说明路由的path是支持数组的</span><br><span class="line">  // 如果是数组的话，需要递归调用register来注册路由，因为一个path对应一个路由</span><br><span class="line">  if (Array.isArray(path)) &#123;</span><br><span class="line">    path.forEach(function (p) &#123;</span><br><span class="line">      router.register.call(router, p, methods, middleware, opts);</span><br><span class="line">    &#125;);</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 创建路由，路由就是Layer的实例</span><br><span class="line">  // methods是路由处理的http方法</span><br><span class="line">  // 最后一个参数对象最终是传给Layer模块中的path-to-regexp模块接口调用的</span><br><span class="line">  var route = new Layer(path, methods, middleware, &#123;</span><br><span class="line">    end: opts.end === false ? opts.end : true,</span><br><span class="line">    name: opts.name,</span><br><span class="line">    sensitive: opts.sensitive || this.opts.sensitive || false,</span><br><span class="line">    strict: opts.strict || this.opts.strict || false,</span><br><span class="line">    prefix: opts.prefix || this.opts.prefix || &quot;&quot;,</span><br><span class="line">    ignoreCaptures: opts.ignoreCaptures</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  // 处理路径前缀</span><br><span class="line">  if (this.opts.prefix) &#123;</span><br><span class="line">    route.setPrefix(this.opts.prefix);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 将全局的路由参数添加到每个路由中</span><br><span class="line">  Object.keys(this.params).forEach(function (param) &#123;</span><br><span class="line">    route.param(param, this.params[param]);</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  // 往路由数组中添加新创建的路由</span><br><span class="line">  stack.push(route);</span><br><span class="line"></span><br><span class="line">  return route;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>根据上面的逻辑我们应该知道</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.get(&apos;/test&apos;, async (ctx, next) =&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p>其实它相当于下面这段代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router.register(&apos;/test&apos;, [&apos;GET&apos;], [async (ctx, next) =&gt; &#123;&#125;], &#123; name: null &#125;);</span><br></pre></td></tr></table></figure><p><code>register</code>函数将路由作为第一个参数传入，然后方法名放入到方法数组中作为第二个参数， 第三个函数是路由的回调数组；其实每个路由注册的时候，后面都可以添加很多个函数，而这些函数都会被添加到一个数组里面，如果被匹配到，就会利用中间件机制来逐个执行这些函数。最后一个参数是将路由的命名空间传入。</p><p>对于<code>stack</code>数组，则是存储每一个路由，也就是<code>Layer</code>的实例对象，每一个路由都相当于一个<code>Layer</code>实例对象。</p><p>对于<code>Layer</code>类来说, 创建一个实例对象用于管理每个路由:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function Layer(path, methods, middleware, opts) &#123;</span><br><span class="line">  this.opts = opts || &#123;&#125;;</span><br><span class="line">  // 路由命名</span><br><span class="line">  this.name = this.opts.name || null;</span><br><span class="line">  // 路由对应的方法</span><br><span class="line">  this.methods = [];</span><br><span class="line">  // 路由参数名数组</span><br><span class="line">  this.paramNames = [];</span><br><span class="line">  // 路由处理中间件数组</span><br><span class="line">  this.stack = Array.isArray(middleware) ? middleware : [middleware];</span><br><span class="line">  // 存储路由方法</span><br><span class="line">  methods.forEach(function(method) &#123;</span><br><span class="line">    var l = this.methods.push(method.toUpperCase());</span><br><span class="line">    if (this.methods[l-1] === &apos;GET&apos;) &#123;</span><br><span class="line">      this.methods.unshift(&apos;HEAD&apos;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  // 将添加的回调处理中间件函数添加到Layer实例对象的 stack 数组中</span><br><span class="line">  this.stack.forEach(function(fn) &#123;</span><br><span class="line">    var type = (typeof fn);</span><br><span class="line">    if (type !== &apos;function&apos;) &#123;</span><br><span class="line">      throw new Error(</span><br><span class="line">        methods.toString() + &quot; `&quot; + (this.opts.name || path) +&quot;`: `middleware` &quot;</span><br><span class="line">        + &quot;must be a function, not `&quot; + type + &quot;`&quot;</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, this);</span><br><span class="line"></span><br><span class="line">  this.path = path;</span><br><span class="line">  this.regexp = pathToRegExp(path, this.paramNames, this.opts);</span><br><span class="line"></span><br><span class="line">  debug(&apos;defined route %s %s&apos;, this.methods, this.opts.prefix + this.path);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>我们可以看到, 对于<code>Layer</code>的实例对象, 核心的逻辑还是在于将<code>path</code>转化为正则表达式用于匹配请求的路由,  然后将路由的处理中间件添加到<code>Layer</code>的<code>stack</code>数组中。 注意这里的<code>stack</code>和<code>Router</code>里面的<code>stack</code>是不一样的, <code>Router</code>的<code>stack</code>数组是存放每个路由对应的<code>Layer</code>实例对象的, 而 <code>Layer</code>实例对象里面的<code>stack</code>数组是存储每个路由的处理函数中间件的, 换言之, 一个路由可以添加多个处理函数。</p><p>下面的图详细描述了<code>Router</code>和<code>Layer</code>的关系：</p><p><img src="https://vfile.meituan.net/xgfe/baf7698bb56fa67e38d3c84ad2121a0725705.png" alt="Router和Layer的关系"></p><h3 id="router-routes"><a href="#router-routes" class="headerlink" title="router.routes()"></a>router.routes()</h3><p><code>app.use(router.routes())</code>就这样，<code>koa-router</code>就启动了，所以大家也一定会很好奇这个<code>routes</code>函数到底做了什么，但可以肯定的是<code>router.routes()</code>返回了一个中间件函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.routes = Router.prototype.middleware = function () &#123;</span><br><span class="line">  var router = this;</span><br><span class="line">  var dispatch = function dispatch(ctx, next) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  dispatch.router = this;</span><br><span class="line">  return dispatch;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里形成了一个闭包，在<code>routes</code>函数内部返回了一个<code>dispatch</code>函数作为中间件。 </p><p>接下来看下<code>dispatch</code>函数的实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">var dispatch = function dispatch(ctx, next) &#123;</span><br><span class="line"></span><br><span class="line">    var path = router.opts.routerPath || ctx.routerPath || ctx.path;</span><br><span class="line"></span><br><span class="line">    // router.match函数内部遍历所有路由（this.stack),</span><br><span class="line">    // 根据路径和请求方法找到对应的路由</span><br><span class="line">    // 返回的matched对象为： </span><br><span class="line">    /* </span><br><span class="line">      var matched = &#123;</span><br><span class="line">        path: [], // 保存了path匹配的路由数组</span><br><span class="line">        pathAndMethod: [], // 保存了path和methods都匹配的路由数组</span><br><span class="line">        route: false // 是否有对应的路由</span><br><span class="line">      &#125;;</span><br><span class="line">    */</span><br><span class="line">    var matched = router.match(path, ctx.method);</span><br><span class="line">    var layerChain, layer, i;</span><br><span class="line">    if (ctx.matched) &#123;</span><br><span class="line">      ctx.matched.push.apply(ctx.matched, matched.path);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      ctx.matched = matched.path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 如果没有对应的路由，则直接进入下一个中间件</span><br><span class="line">    if (!matched.route) return next();</span><br><span class="line"></span><br><span class="line">    // 找到正确的路由的path</span><br><span class="line">    var mostSpecificPath = matched.pathAndMethod[matched.pathAndMethod.length - 1].path;</span><br><span class="line">    ctx._matchedRoute = mostSpecificPath;</span><br><span class="line"></span><br><span class="line">    // 使用reduce方法将路由的所有中间件形成一条链</span><br><span class="line">    // 构建路径对应路由的处理中间件函数数组</span><br><span class="line">    // 这里的目的是在每个匹配的路由对应的中间件处理函数数组前添加一个用于处理</span><br><span class="line">    // 对应路由的 captures, params, 以及路由命名的函数</span><br><span class="line">    layerChain = matched.pathAndMethod.reduce(function(memo, layer) &#123;</span><br><span class="line"></span><br><span class="line">      // 在每个路由的中间件执行之前，根据参数不同，设置 ctx.captures 和 ctx.params</span><br><span class="line">      // 这就是为什么我们可以直接在中间件函数中直接使用 ctx.params 来读取路由参数信息了</span><br><span class="line">      memo.push(function(ctx, next) &#123;</span><br><span class="line"></span><br><span class="line">       // captures是存储路由中参数的值的数组</span><br><span class="line">        ctx.captures = layer.captures(path, ctx.captures);</span><br><span class="line"></span><br><span class="line">        // params是一个对象, 键为参数名, 根据参数名可以获取路由中的参数值, 值从captures中拿</span><br><span class="line">        ctx.params = layer.params(path, ctx.captures, ctx.params);</span><br><span class="line"></span><br><span class="line">        // 执行下一个中间件</span><br><span class="line">        return next();</span><br><span class="line">      &#125;);</span><br><span class="line"></span><br><span class="line">      // 将上面另外加的中间件和已有的路由中间件合并到一起</span><br><span class="line">      // 所以最终 layerChain 将会是一个中间件的数组</span><br><span class="line">      return memo.concat(layer.stack);</span><br><span class="line">    &#125;, []);</span><br><span class="line"></span><br><span class="line">    // 最后调用上面提到的compose模块提供的方法，返回将layerChain(中间件的数组) </span><br><span class="line">    // 顺序执行所有中间件的执行函数， 并立即执行。</span><br><span class="line">    return compose(layerChain)(ctx, next);</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><h3 id="router-allowedMethod"><a href="#router-allowedMethod" class="headerlink" title="router.allowedMethod()"></a>router.allowedMethod()</h3><p>对于<code>allowedMethod</code>方法来说, 它的作用就是用于处理请求的错误, 所以它作为路由模块的最后一个函数来执行。同样地, 它也是以一个<code>koa</code>的中间件插件函数的形式出现, 同样在函数内部形成了一个闭包:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.allowedMethods = function (options) &#123;</span><br><span class="line">  options = options || &#123;&#125;;</span><br><span class="line">  var implemented = this.methods;</span><br><span class="line"></span><br><span class="line">  return function allowedMethods(ctx, next) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>上面的代码很简单, 就是保存<code>Router</code>配置中允许的<code>HTTP</code>方法数组在闭包内部</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">return function allowedMethods(ctx, next) &#123;</span><br><span class="line">    // 从这里可以看出, allowedMethods函数是用于在中间件机制中处理返回结果的函数</span><br><span class="line">    // 先执行next函数, next函数返回的是一个Promise对象</span><br><span class="line">    return next().then(function() &#123;</span><br><span class="line">      var allowed = &#123;&#125;;</span><br><span class="line">      // allowedMethods函数的逻辑建立在statusCode没有设置或者值为404的时候</span><br><span class="line">      if (!ctx.status || ctx.status === 404) &#123;</span><br><span class="line">        // 这里的matched就是在match函数执行之后返回结果集中的 path 数组</span><br><span class="line">        // 也就是说请求路径与路由正则匹配的 layer 实例对象数组</span><br><span class="line">        ctx.matched.forEach(function (route) &#123;</span><br><span class="line">          // 将这些layer路由的HTTP方法存储起来</span><br><span class="line">          route.methods.forEach(function (method) &#123;</span><br><span class="line">            allowed[method] = method;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">        // 将上面的allowed整理为数组</span><br><span class="line">        var allowedArr = Object.keys(allowed);</span><br><span class="line">        // implemented就是Router配置中的methods数组, 也就是允许的方法</span><br><span class="line">        // 这里通过~运算判断当前的请求方法是否在配置允许的方法中</span><br><span class="line">        // 如果该方法不被允许</span><br><span class="line">        if (!~implemented.indexOf(ctx.method)) &#123;</span><br><span class="line">          // 如果 Router 配置中配置 throw 为 true</span><br><span class="line">          if (options.throw) &#123;</span><br><span class="line">            var notImplementedThrowable;</span><br><span class="line">            // 如果配置中规定了throw抛出错误的函数, 那么就执行对应的函数</span><br><span class="line">            if (typeof options.notImplemented === &apos;function&apos;) &#123;</span><br><span class="line">              notImplementedThrowable = options.notImplemented(); // set whatever the user returns from their function</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">            // 如果没有则直接抛出HTTP Error</span><br><span class="line">              notImplementedThrowable = new HttpError.NotImplemented();</span><br><span class="line">            &#125;</span><br><span class="line">            // 抛出错误</span><br><span class="line">            throw notImplementedThrowable;</span><br><span class="line">          &#125; else &#123;</span><br><span class="line">            // Router配置throw为false</span><br><span class="line">            // 设置状态码为 501</span><br><span class="line">            ctx.status = 501;</span><br><span class="line">            // 并且设置Allow头部, 值为上面得到的允许的方法数组allowedArr</span><br><span class="line">            ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; else if (allowedArr.length) &#123;</span><br><span class="line">          // 来到这里说明该请求的方法是被允许的, 那么为什么会没有状态码statusCode或者 statusCode为404呢?</span><br><span class="line">          // 原因在于除却特殊情况, 我们一般在业务逻辑里面不会处理OPTIONS请求的</span><br><span class="line">          // 发出这个请求一般常见就是非简单请求, 则会发出预检请求OPTIONS</span><br><span class="line">          // 例如 application/json 格式的POST请求</span><br><span class="line">          </span><br><span class="line">          // 如果是 OPTIONS 请求, 状态码为 200, 然后设置 Allow 头部, 值为允许的方法数组 methods</span><br><span class="line">          if (ctx.method === &apos;OPTIONS&apos;) &#123;</span><br><span class="line">            ctx.status = 200;</span><br><span class="line">            ctx.body = &apos;&apos;;</span><br><span class="line">            ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">          &#125; else if (!allowed[ctx.method]) &#123;</span><br><span class="line">          // 方法被服务端允许, 但是在路径匹配的路由中没有找到对应本次请求的方法的处理函数</span><br><span class="line">            // 类似上面的逻辑</span><br><span class="line">            if (options.throw) &#123;</span><br><span class="line">              var notAllowedThrowable;</span><br><span class="line">              if (typeof options.methodNotAllowed === &apos;function&apos;) &#123;</span><br><span class="line">                notAllowedThrowable = options.methodNotAllowed(); // set whatever the user returns from their function</span><br><span class="line">              &#125; else &#123;</span><br><span class="line">                notAllowedThrowable = new HttpError.MethodNotAllowed();</span><br><span class="line">              &#125;</span><br><span class="line">              throw notAllowedThrowable;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">              // 这里的状态码为 405</span><br><span class="line">              ctx.status = 405;</span><br><span class="line">              ctx.set(&apos;Allow&apos;, allowedArr.join(&apos;, &apos;));</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>值得注意的是, <code>Router.methods</code>数组里面的方法是服务端需要实现并支持的方法, 如果客户端发送过来的请求方法不被允许, 那么这是一个服务端错误<code>501</code>, 但是如果这个方法被允许, 但是找不到对应这个方法的路由处理函数(比如相同路由的<code>POST</code>路由但是用<code>GET</code>方法来获取数据), 这是一个客户端错误<code>405</code>。</p><h3 id="router-use"><a href="#router-use" class="headerlink" title="router.use()"></a>router.use()</h3><p><code>use</code>函数就是用于添加中间件的, 只不过不同于<code>koa</code>中的<code>use</code>函数, <code>router</code>的<code>use</code>函数添加的中间件函数会在所有路由执行之前执行。此外, 它还可以对某些特定路径的进行中间件函数的绑定执行.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">router.prototype.use = function () &#123;</span><br><span class="line">  var router = this;</span><br><span class="line">  // 中间件函数数组</span><br><span class="line">  var middleware = Array.prototype.slice.call(arguments);</span><br><span class="line">  var path;</span><br><span class="line"></span><br><span class="line">  // 支持同时为多个路由绑定中间件函数: router.use([&apos;/use&apos;, &apos;/admin&apos;], auth());</span><br><span class="line">  if (Array.isArray(middleware[0]) &amp;&amp; typeof middleware[0][0] === &apos;string&apos;) &#123;</span><br><span class="line">    middleware[0].forEach(function (p) &#123;</span><br><span class="line">      // 递归调用</span><br><span class="line">      router.use.apply(router, [p].concat(middleware.slice(1)));</span><br><span class="line">    &#125;);</span><br><span class="line">    // 直接返回, 下面是非数组 path 的逻辑</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">  // 如果第一个参数有传值为字符串, 说明有传路径</span><br><span class="line">  var hasPath = typeof middleware[0] === &apos;string&apos;;</span><br><span class="line">  if (hasPath) &#123;</span><br><span class="line">    path = middleware.shift();</span><br><span class="line">  &#125;</span><br><span class="line">    </span><br><span class="line">  middleware.forEach(function (m) &#123;</span><br><span class="line">    // 如果有router属性, 说明这个中间件函数是由 Router.prototype.routes暴露出来的</span><br><span class="line">    // 属于嵌套路由</span><br><span class="line">    if (m.router) &#123;</span><br><span class="line">      // 这里的逻辑很有意思, 如果是嵌套路由, 相当于将需要嵌套路由重新注册到现在的 Router 对象上</span><br><span class="line">      m.router.stack.forEach(function (nestedLayer) &#123;</span><br><span class="line">        // 如果有path, 那么为需要嵌套的路由加上路径前缀</span><br><span class="line">        if (path) nestedLayer.setPrefix(path);</span><br><span class="line">        // 如果本身的router有前缀配置, 也添加上</span><br><span class="line">        if (router.opts.prefix) nestedLayer.setPrefix(router.opts.prefix);</span><br><span class="line">        // 将需要嵌套的路由模块的 stack 中存储的 Layer 加入到本 router 对象上</span><br><span class="line">        router.stack.push(nestedLayer);</span><br><span class="line">      &#125;);</span><br><span class="line">      // 这里与register函数的逻辑类似, 注册的时候检查添加参数校验函数 params</span><br><span class="line">      if (router.params) &#123;</span><br><span class="line">        Object.keys(router.params).forEach(function (key) &#123;</span><br><span class="line">          m.router.param(key, router.params[key]);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // 没有router属性则是常规中间件函数, 如果有给定的 path 那么就生成一个 Layer 模块进行管理</span><br><span class="line">      // 如果没有path, 那么就生成通配的路径 (.*) 来生成 Layer 来管理</span><br><span class="line">      router.register(path || &apos;(.*)&apos;, [], m, &#123; end: false, ignoreCaptures: !hasPath &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>眼尖的同学可能会看到一些 http code：404, 501, 204, 405 。那这个函数其实就是当所有中间件函数执行完了，并且请求出错了进行相应的处理：</p><ul><li>如果请求的方法<code>koa-router</code>不支持并且没有设置<code>throw</code>选项，则返回<code>501</code>(未实现)</li><li>如果是<code>options</code>请求，则返回 <code>204</code>(无内容)</li><li>如果请求的方法支持但没有设置<code>throw</code>选项，则返回 <code>405</code>(不允许此方法 )</li></ul><h3 id="Router-prototype-match"><a href="#Router-prototype-match" class="headerlink" title="Router.prototype.match"></a>Router.prototype.match</h3><p>我们已经注册好了路由, 但是, 如果请求过来了, 请求是怎么匹配然后进行到相对应的处理函数去的呢? 答案就是利用<code>match</code>函数.先看一下<code>match</code>函数的代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Router.prototype.match = function (path, method) &#123;</span><br><span class="line">  // 取所有路由 Layer 实例</span><br><span class="line">  var layers = this.stack;</span><br><span class="line">  var layer;</span><br><span class="line">  // 匹配结果</span><br><span class="line">  var matched = &#123;</span><br><span class="line">    path: [],</span><br><span class="line">    pathAndMethod: [],</span><br><span class="line">    route: false</span><br><span class="line">  &#125;;</span><br><span class="line">  // 遍历路由 Router 的 stack 逐个判断</span><br><span class="line">  for (var len = layers.length, i = 0; i &lt; len; i++) &#123;</span><br><span class="line">    layer = layers[i];</span><br><span class="line"></span><br><span class="line">    debug(&apos;test %s %s&apos;, layer.path, layer.regexp);</span><br><span class="line">    // 这里是使用由路由字符串生成的正则表达式判断当前路径是否符合该正则</span><br><span class="line">    if (layer.match(path)) &#123;</span><br><span class="line">      // 将对应的 Layer 实例加入到结果集的 path 数组中</span><br><span class="line">      matched.path.push(layer);</span><br><span class="line">      // 如果对应的 layer 实例中 methods 数组为空或者数组中有找到对应的方法</span><br><span class="line">      if (layer.methods.length === 0 || ~layer.methods.indexOf(method)) &#123;</span><br><span class="line">        // 将 layer 放入到结果集的 pathAndMethod 中</span><br><span class="line">        matched.pathAndMethod.push(layer);</span><br><span class="line">        // 这里是用于判断是否有真正匹配到路由处理函数</span><br><span class="line">        // 因为像 router.use(session()); 这样的中间件也是通过 Layer 来管理的, 它们的 methods 数组为空</span><br><span class="line">        if (layer.methods.length) matched.route = true;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return matched;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面返回的结果集, 我们知道一个请求来临的时候, 我们可以使用正则来匹配路由是否符合, 然后在<code>path</code>数组或者<code>pathAndMethod</code>数组中找到对应的<code>Layer</code>实例对象.</p><h2 id="router处理请求的流程"><a href="#router处理请求的流程" class="headerlink" title="router处理请求的流程"></a>router处理请求的流程</h2><p><img src="https://vfile.meituan.net/xgfe/63d452eb5a23d3fe3e1bf2e0219bceea93599.png" alt="router处理请求的流程"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><code>koa-router</code>用到了第三方的<code>node</code>模块</p><ul><li><p><a href="https://github.com/koajs/compose" target="_blank" rel="noopener">koa-compose</a>:<br> 提供给它一个中间件数组， 返回一个顺序执行所有中间件的执行函数。</p></li><li><p><a href="https://github.com/jshttp/methods" target="_blank" rel="noopener">methods</a>：<br> <code>node</code>中支持的<code>http</code>动词，就是<code>http.METHODS</code>，可以在终端输出看看。 </p></li><li><p><a href="https://github.com/pillarjs/path-to-regexp" target="_blank" rel="noopener">path-to-regexp</a>：<br> 将路径字符串转换成强大的正则表达式，还可以输出路径参数。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文通过分析<code>koa-router</code>的源码，总结了：</p><ul><li><code>koa-router</code>涉及到的<code>router</code>和<code>layer</code>的关系；</li><li><code>koa-router</code>处理请求的整体流程；</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文通过阅读 koa-router 的源码归纳了 koa-router 涉及到的 router 和 layer 两个对象的关系；以及梳理了 koa-router 处理请求的整体流程。&lt;/p&gt;
    
    </summary>
    
      <category term="zuopengfei" scheme="http://xgfe.github.io/categories/zuopengfei/"/>
    
    
      <category term="node" scheme="http://xgfe.github.io/tags/node/"/>
    
      <category term="koa" scheme="http://xgfe.github.io/tags/koa/"/>
    
      <category term="koa-router" scheme="http://xgfe.github.io/tags/koa-router/"/>
    
  </entry>
  
  <entry>
    <title>Category 与Extension 相关知识</title>
    <link href="http://xgfe.github.io/2018/08/24/wanglibin/category%E4%B8%8EExtension%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/"/>
    <id>http://xgfe.github.io/2018/08/24/wanglibin/category与Extension相关知识/</id>
    <published>2018-08-24T07:27:55.863Z</published>
    <updated>2018-08-24T07:27:55.864Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍Category 和 Extension 的相关知识以及使用。<br><a id="more"></a></p><h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><h2 id="Category"><a href="#Category" class="headerlink" title="Category"></a>Category</h2><ul><li>Category的背景和概念</li><li>Category的声明及实现</li><li>Category的使用</li><li>Category扩展属性（变量）</li></ul><h2 id="Extension"><a href="#Extension" class="headerlink" title="Extension"></a>Extension</h2><ul><li>Extension的格式</li><li>Extension的实现</li></ul><h2 id="Category和Extension的区别"><a href="#Category和Extension的区别" class="headerlink" title="Category和Extension的区别"></a>Category和Extension的区别</h2><h3 id="一、Category"><a href="#一、Category" class="headerlink" title="一、Category"></a>一、Category</h3><h4 id="1、Category的背景和概念"><a href="#1、Category的背景和概念" class="headerlink" title="1、Category的背景和概念"></a>1、Category的背景和概念</h4><p>在日常开发中，经常需要对已有类进行功能上的扩展，在学习“类别”之前，常用的类扩展方式有以下三种：</p><ul><li>原有类的修改</li><li>继承</li><li>protocol（协议）</li></ul><p>针对以上三种扩展方式，</p><ol><li><p>第一种为最原始的方法；</p></li><li><p>第二种在继承父类的同时，也扩展自己，包括（方法和变量）。但是在面向对象的开发原则中“优先使用组合慎用继承”，因为继承在一定程度上破坏了封装性、子类随父类变动。</p></li><li><p>第三种协议，主要是依靠实现类的具体方法实现，当扩展功能时，需要修改原有类，协议定义过多，实现类过于庞大。</p></li></ol><p>那么，在oc中，当我们想避免上述两种扩展方式的缺点，又想只对现有类进行扩展些方法，并且不用去修改原有类以及使用它的地方的代码，就用到了Category（类别）。</p><p>类别是OC的特有语法，可以通过在类上声明和实现方法来扩展现有类的功能。原则上只能增加方法（包括对象方法和类方法），不能增加成员变量。</p><h4 id="2、Category的声明及实现"><a href="#2、Category的声明及实现" class="headerlink" title="2、Category的声明及实现"></a>2、Category的声明及实现</h4><pre><code>@interface 需扩展的类 （类别的名称）-（void）appendMethod;@end@implementation 需扩展的类 （类别的名称）-（void）appendMethod{}@end</code></pre><h4 id="3、Category的使用"><a href="#3、Category的使用" class="headerlink" title="3、Category的使用"></a>3、Category的使用</h4><p>如果需要扩展一个类，定义好此类的Category ，则可以通过该类的对象直接调用Category中的扩展方法。与此同时，在Category中也可以访问原有类.h中的属性和方法。</p><p>.h文件：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;@interface pson : NSObject&lt;NSCoding&gt;@property (nonatomic, copy) NSString *name;@property (nonatomic, assign) NSInteger age;- (void) run;+ (void) jump;@end</code></pre><p>.m文件</p><pre><code>#import &quot;pson.h&quot;@implementation pson-(void) run{    NSLog(@&quot;run&quot;);}+(void) jump{    NSLog(@&quot;jump&quot;);}@end</code></pre><p>为pson类添加eat方法，Category的.m文件如下所示：</p><p>pson+eat.h文件</p><pre><code>#import &quot;pson.h&quot;@interface pson (eat)@property (nonatomic, strong) NSString *food;-(void) eat;@end</code></pre><p>pson+eat.m文件</p><pre><code>#import &quot;pson+eat.h&quot;@implementation pson (eat)-(void) eat{   //调用原有类的公共方法[self run];//调用原有类的非私有属性NSLog(@&quot;%@&quot;,self.name);}+(void) drink{    NSLog(@&quot;drink&quot;);}@end</code></pre><p>在main方法中</p><pre><code>pson *me = [[pson alloc] init];    [me run];    //调用扩展类中的对象方法    [me eat];    //调用扩展类中的类方法    [pson drink]</code></pre><h4 id="4、Category扩展属性（变量）"><a href="#4、Category扩展属性（变量）" class="headerlink" title="4、Category扩展属性（变量）"></a>4、Category扩展属性（变量）</h4><p>由于Category本质上是个指向类型的结构体指针，在结构体中只有方法的列表，没有属性的列表，所以理论上只能增加方法不能增加属性。</p><p>如何通过Category来扩展属性呢？</p><p>无法添加属性的根本原因是：在Category中@property声明属性，系统不会生成_成员变量和setter、getter。</p><p>解决方法：手动添加setter和getter方法，采用的就是：关联引用（objc_setAssociatedObject和objc_getAssociatedObject）</p><p>其中，</p><p>objc_setAssociatedObject，接收4个参数：想关联到数据的对象、获取数据的键值、存储引用的值、关联的策略；</p><p>objc_getAssociatedObject，接收2个参数：关联到数据的对象、键值</p><p>常见的关联策略，如下表所示：</p><table><thead><tr><th>一个普通标题</th><th>一个普通标题</th></tr></thead><tbody><tr><td>OBJC _ ASSOCIATION _ ASSIGN</td><td>指定值将被简单赋值、没有保留和释放</td></tr><tr><td>OBJC _ ASSOCIATION _ RETAIN _ NONATOMIC</td><td>指定值通过非线程安全的方式赋值并保留</td></tr><tr><td>OBJC _ ASSOCIATION _ COPY _ NONATOMIC</td><td>指定值通过非线程安全的方式复制</td></tr><tr><td>OBJC _ ASSOCIATION _ RETAIN</td><td>指定值通过线程安全的方式赋值并保留</td></tr><tr><td>OBJC _ ASSOCIATION _ COPY</td><td>指定值通过线程安全的方式复制</td></tr></tbody></table><p>具体实现例子如下所示：</p><p>Category的.h文件</p><pre><code>#import &quot;pson.h&quot;@interface pson (eat)@property (nonatomic, strong) NSString *food;-(void) eat;+(void) drink;@end</code></pre><p>Category的.m文件</p><pre><code>#import &quot;pson+eat.h&quot;#import &quot;objc/runtime.h&quot;static NSString *key = @&quot;personEatKey&quot;;@implementation pson (eat)-(void) eat{    NSLog(@&quot;eat&quot;);}-(void) setFood:(NSString *)food{    objc_setAssociatedObject(self, &amp;key, food,     OBJC_ASSOCIATION_COPY);}-(NSString *) food{    return objc_getAssociatedObject(self, &amp;key);}@end</code></pre><p>main方法中的使用如下：</p><pre><code>#import &lt;Foundation/Foundation.h&gt;#import &quot;pson.h&quot;#import &quot;pson+eat.h&quot;int main(int argc, const char * argv[]) {    @autoreleasepool {        pson *me = [[pson alloc] init];        [me eat];        me.food = @&quot;鸡蛋&quot;;        NSLog(@&quot;%@&quot;,me.food);    }    return 0;}</code></pre><h3 id="二、Extension"><a href="#二、Extension" class="headerlink" title="二、Extension"></a>二、Extension</h3><p>Extension 是Category的特例，少了类别的名称，是匿名分类。声明私有方法和属性的机制。具体实现在原有类的.m文件中。</p><h4 id="1、Extension的格式"><a href="#1、Extension的格式" class="headerlink" title="1、Extension的格式"></a>1、Extension的格式</h4><pre><code>@interface XXX ()    //私有属性    //私有方法（如果不实现，编译时会报警,Method definition for &apos;XXX&apos; not found）@end</code></pre><h4 id="2、Extension的实现"><a href="#2、Extension的实现" class="headerlink" title="2、Extension的实现"></a>2、Extension的实现</h4><ul><li>通过单独的.h声明，在原有类的.m中导入。</li><li>直接在原有类的.m中使用。</li></ul><h2 id="Category和Extension的区别-1"><a href="#Category和Extension的区别-1" class="headerlink" title="Category和Extension的区别"></a>Category和Extension的区别</h2><ul><li>Category原则上只能增加方法；而Extension方法和变量都可以。</li><li>Extension声明方法没有被实现，编译器报警。Category在运行时添加、Extension是编译阶段。</li><li>Extension没有自己独立的实现部分。</li><li>Extension是私有。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍Category 和 Extension 的相关知识以及使用。&lt;br&gt;
    
    </summary>
    
      <category term="wanglibin" scheme="http://xgfe.github.io/categories/wanglibin/"/>
    
    
      <category term="OC" scheme="http://xgfe.github.io/tags/OC/"/>
    
      <category term="Category" scheme="http://xgfe.github.io/tags/Category/"/>
    
      <category term="Extension" scheme="http://xgfe.github.io/tags/Extension/"/>
    
  </entry>
  
  <entry>
    <title>Day.js 源码学习</title>
    <link href="http://xgfe.github.io/2018/07/11/guanxiaofeng/Dayjs/"/>
    <id>http://xgfe.github.io/2018/07/11/guanxiaofeng/Dayjs/</id>
    <published>2018-07-11T04:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.239Z</updated>
    
    <content type="html"><![CDATA[<p>dayjs 是一个轻量的 JavaScript 时间日期处理库，其用法（api）和 Moment.js 完全一样。<br><a id="more"></a></p><p>📚<a href="https://github.com/iamkun/dayjs/blob/master/docs/zh-cn/API-reference.md" target="_blank" rel="noopener">官方 API 文档（中文）</a></p><h2 id="一-特性"><a href="#一-特性" class="headerlink" title="一 特性"></a>一 特性</h2><ul><li>和 Moment.js 相同的 API 和用法</li><li>不可变数据（Immutable）</li><li>支持链式操作（Chainable）</li><li>l18n 国际化</li><li>仅 2kb 大小</li><li>全浏览器兼容</li></ul><p>基本用法如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().startOf(<span class="string">'month'</span>).add(<span class="number">1</span>, <span class="string">'day'</span>).set(<span class="string">'year'</span>, <span class="number">2018</span>).format(<span class="string">'YYYY-MM-DD HH:mm:ss'</span>);</span><br></pre></td></tr></table></figure></p><h2 id="二-解析"><a href="#二-解析" class="headerlink" title="二 解析"></a>二 解析</h2><h3 id="构造器-dayjs-existing-string-number-Date-Dayjs"><a href="#构造器-dayjs-existing-string-number-Date-Dayjs" class="headerlink" title="构造器 dayjs(existing?: string | number | Date | Dayjs)"></a>构造器 dayjs(existing?: string | number | Date | Dayjs)</h3><p>从源码可以看出，调用 dayjs 时会返回一个 Dayjs 对象，Dayjs 构造器调用了 parseDate 方法，返回了一个全新的包含 Javascript Date 对象的 Dayjs 的对象；其他的值都是根据 Javascript Date 对象得来的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 部分源码</span></span><br><span class="line"><span class="keyword">const</span> dayjs = <span class="function">(<span class="params">date, c</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isDayjs(date)) &#123;</span><br><span class="line">    <span class="keyword">return</span> date.clone()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> cfg = c || &#123;&#125;</span><br><span class="line">  cfg.date = date</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Dayjs(cfg) <span class="comment">// eslint-disable-line no-use-before-define</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> parseDate = <span class="function">(<span class="params">date</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> reg</span><br><span class="line">  <span class="keyword">if</span> (date === <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="literal">NaN</span>) <span class="comment">// Treat null as an invalid date</span></span><br><span class="line">  <span class="keyword">if</span> (Utils.isUndefined(date)) <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">  <span class="keyword">if</span> (date <span class="keyword">instanceof</span> <span class="built_in">Date</span>) <span class="keyword">return</span> date</span><br><span class="line">  <span class="comment">// eslint-disable-next-line no-cond-assign</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">typeof</span> date === <span class="string">'string'</span>)</span><br><span class="line">    &amp;&amp; (<span class="regexp">/.*[^Z]$/i</span>.test(date)) <span class="comment">// looking for a better way</span></span><br><span class="line">    &amp;&amp; (reg = date.match(C.REGEX_PARSE))) &#123;</span><br><span class="line">    <span class="comment">// 2018-08-08 or 20180808</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(</span><br><span class="line">      reg[<span class="number">1</span>], reg[<span class="number">2</span>] - <span class="number">1</span>, reg[<span class="number">3</span>] || <span class="number">1</span>,</span><br><span class="line">      reg[<span class="number">5</span>] || <span class="number">0</span>, reg[<span class="number">6</span>] || <span class="number">0</span>, reg[<span class="number">7</span>] || <span class="number">0</span>, reg[<span class="number">8</span>] || <span class="number">0</span></span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Date</span>(date) <span class="comment">// timestamp</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dayjs</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.parse(cfg) <span class="comment">// for plugin</span></span><br><span class="line">  &#125;</span><br><span class="line">  parse(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$d = parseDate(cfg.date)</span><br><span class="line">    <span class="keyword">this</span>.init(cfg)</span><br><span class="line">  &#125;</span><br><span class="line">  init(cfg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.$y = <span class="keyword">this</span>.$d.getFullYear()</span><br><span class="line">    <span class="keyword">this</span>.$M = <span class="keyword">this</span>.$d.getMonth()</span><br><span class="line">    <span class="keyword">this</span>.$D = <span class="keyword">this</span>.$d.getDate()</span><br><span class="line">    <span class="keyword">this</span>.$W = <span class="keyword">this</span>.$d.getDay()</span><br><span class="line">    <span class="keyword">this</span>.$H = <span class="keyword">this</span>.$d.getHours()</span><br><span class="line">    <span class="keyword">this</span>.$m = <span class="keyword">this</span>.$d.getMinutes()</span><br><span class="line">    <span class="keyword">this</span>.$s = <span class="keyword">this</span>.$d.getSeconds()</span><br><span class="line">    <span class="keyword">this</span>.$ms = <span class="keyword">this</span>.$d.getMilliseconds()</span><br><span class="line">    <span class="keyword">this</span>.$L = <span class="keyword">this</span>.$L || parseLocale(cfg.locale, <span class="literal">null</span>, <span class="literal">true</span>) || L</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在 init 实例方法中，使用实例属性 $d（为 JavaScript 原生 Date 对象）来获取 年、月、日、周、时、分、秒、毫秒，且保存在实例中。并且调用 parseLocale 函数来获取语言，赋值给 Dayjs 实例的 $L 属性。</p><p>可传参数有5类：  </p><h5 id="1-当前时间"><a href="#1-当前时间" class="headerlink" title="1.当前时间"></a>1.当前时间</h5><p>dayjs 本质上是个函数，因此可以直接运行该函数，得到包含当前时间和日期的 Dayjs 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs();</span><br></pre></td></tr></table></figure></p><h5 id="2-标准的-ISO-8601-时间字符串"><a href="#2-标准的-ISO-8601-时间字符串" class="headerlink" title="2.标准的 ISO 8601 时间字符串"></a>2.标准的 ISO 8601 时间字符串</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="string">"2018-07-14"</span>);</span><br></pre></td></tr></table></figure><h5 id="3-解析-Unix-时间戳-毫秒"><a href="#3-解析-Unix-时间戳-毫秒" class="headerlink" title="3.解析 Unix 时间戳(毫秒)"></a>3.解析 Unix 时间戳(毫秒)</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="number">1531469940578</span>);</span><br></pre></td></tr></table></figure><h5 id="4-解析-Date-对象"><a href="#4-解析-Date-对象" class="headerlink" title="4.解析 Date 对象"></a>4.解析 Date 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(<span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2018</span>,<span class="number">5</span>,<span class="number">3</span>));</span><br></pre></td></tr></table></figure><h5 id="5-解析-dayjs-对象"><a href="#5-解析-dayjs-对象" class="headerlink" title="5.解析 dayjs 对象"></a>5.解析 dayjs 对象</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs(dayjs());</span><br></pre></td></tr></table></figure><h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>dayjs 对象是不可变的如果要复制对象，需要调用 .clone()，或者是在解析一个 dayjs 对象。 向 dayjs() 里传入一个 Dayjs 对象也能实现同样的效果。<br><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().clone();</span><br><span class="line">dayjs(Dayjs);</span><br></pre></td></tr></table></figure></p><p>部分源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> wrapper = <span class="function">(<span class="params">date, instance</span>) =&gt;</span> dayjs(date, &#123; <span class="attr">locale</span>: instance.$L &#125;)</span><br><span class="line">clone() &#123;</span><br><span class="line">  <span class="keyword">return</span> wrapper(<span class="keyword">this</span>.toDate(), <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>检测当前 Dayjs 对象是否是一个有效的时间。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().isValid();</span><br></pre></td></tr></table></figure></p><p>部分源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isValid() &#123;</span><br><span class="line">  <span class="keyword">return</span> !(<span class="keyword">this</span>.$d.toString() === <span class="string">'Invalid Date'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三-获取-设置"><a href="#三-获取-设置" class="headerlink" title="三 获取+设置"></a>三 获取+设置</h2><h5 id="获取各种时间"><a href="#获取各种时间" class="headerlink" title="获取各种时间"></a>获取各种时间</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">dayjs().year();        <span class="comment">// 年</span></span><br><span class="line">dayjs().month();       <span class="comment">// 月</span></span><br><span class="line">dayjs().date();        <span class="comment">// 日</span></span><br><span class="line">dayjs().day();         <span class="comment">// 星期(星期天 0, 星期六 6)</span></span><br><span class="line">dayjs().hour();        <span class="comment">// 时</span></span><br><span class="line">dayjs().minute();      <span class="comment">// 分</span></span><br><span class="line">dayjs().second();      <span class="comment">// 秒</span></span><br><span class="line">dayjs().millisecond(); <span class="comment">// 毫秒</span></span><br></pre></td></tr></table></figure><h5 id="设置各种时间"><a href="#设置各种时间" class="headerlink" title="设置各种时间"></a>设置各种时间</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().set(unit : <span class="built_in">String</span>, <span class="attr">value</span> : Int);</span><br><span class="line">dayjs().set(<span class="string">'date'</span>, <span class="number">1</span>);</span><br><span class="line">dayjs().set(<span class="string">'month'</span>, <span class="number">3</span>); <span class="comment">// 四月</span></span><br><span class="line">dayjs().set(<span class="string">'second'</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure><p>设置时间也是通过返回一个新的对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(string, int) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.clone().$set(string, int)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="四-格式化显示"><a href="#四-格式化显示" class="headerlink" title="四 格式化显示"></a>四 格式化显示</h2><p>格式化显示和 momentjs 一样，通过 .format() 即可，返回的是 String 。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().format(<span class="built_in">String</span>);</span><br><span class="line">dayjs().format();             <span class="comment">// "2018-07-13T20:10:31+08:00"</span></span><br><span class="line">dayjs().format(<span class="string">'YYYY-MM-DD'</span>); <span class="comment">// "2018-07-13"</span></span><br><span class="line">dayjs().format(<span class="string">'YYYY/MM/DD'</span>); <span class="comment">// "2018/07/13"</span></span><br></pre></td></tr></table></figure></p><h2 id="五-操作"><a href="#五-操作" class="headerlink" title="五 操作"></a>五 操作</h2><h5 id="增加和减少"><a href="#增加和减少" class="headerlink" title="增加和减少"></a>增加和减少</h5><p>在此之前先看看源码实现的逻辑：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 部分源码</span></span><br><span class="line">add(number, units) &#123;</span><br><span class="line">  number = <span class="built_in">Number</span>(number) <span class="comment">// eslint-disable-line no-param-reassign</span></span><br><span class="line">  <span class="keyword">const</span> unit = Utils.prettyUnit(units)</span><br><span class="line">  <span class="keyword">const</span> instanceFactory = <span class="function">(<span class="params">u, n</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> date = <span class="keyword">this</span>.set(C.DATE, <span class="number">1</span>).set(u, n + number)</span><br><span class="line">    <span class="keyword">return</span> date.set(C.DATE, <span class="built_in">Math</span>.min(<span class="keyword">this</span>.$D, date.daysInMonth()))</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unit === C.M) &#123;</span><br><span class="line">    <span class="keyword">return</span> instanceFactory(C.M, <span class="keyword">this</span>.$M)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (unit === C.Y) &#123;</span><br><span class="line">    <span class="keyword">return</span> instanceFactory(C.Y, <span class="keyword">this</span>.$y)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> step</span><br><span class="line">  <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">    <span class="keyword">case</span> C.MIN:</span><br><span class="line">      step = C.MILLISECONDS_A_MINUTE</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.H:</span><br><span class="line">      step = C.MILLISECONDS_A_HOUR</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.D:</span><br><span class="line">      step = C.MILLISECONDS_A_DAY</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.W:</span><br><span class="line">      step = C.MILLISECONDS_A_WEEK</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">case</span> C.S:</span><br><span class="line">      step = C.MILLISECONDS_A_SECOND</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">default</span>: <span class="comment">// ms</span></span><br><span class="line">      step = <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> nextTimeStamp = <span class="keyword">this</span>.valueOf() + (number * step)</span><br><span class="line">  <span class="keyword">return</span> wrapper(nextTimeStamp, <span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line">subtract(number, string) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.add(number * <span class="number">-1</span>, string)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Dayjs 类中 add、subtract 等方法，都会通过 wrapper 返回一个新的 Dayjs 实例，是通过使用 Dayjs 类中的 clone() 方法实现的。所以，通过这个 clone() 方法，实现了 dayjs 的 immutable 特性。<br>当增加或减少的单位是年或月时，会先将日设置为1，然后再加减，最后再比较当前月的总天数和原来的天数（主要是解决像2月只有28天这类问题），取较小的值再返回；对于天／周／时／分／秒则是按照时间戳来计算，再通过 wrapper 返回一个新的 Date 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dayjs().add(value : <span class="built_in">Number</span>, <span class="attr">unit</span> : <span class="built_in">String</span>);</span><br><span class="line">dayjs().add(<span class="number">5</span>, <span class="string">'day'</span>);</span><br><span class="line">dayjs().subtract(value : <span class="built_in">Number</span>, <span class="attr">unit</span> : <span class="built_in">String</span>);</span><br><span class="line">dayjs().subtract(<span class="number">2</span>, <span class="string">'year'</span>);</span><br></pre></td></tr></table></figure></p><h5 id="开头和末尾"><a href="#开头和末尾" class="headerlink" title="开头和末尾"></a>开头和末尾</h5><p>返回当前时间的开头时间的 Dayjs 对象，如月份的第一天。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().startOf(unit : <span class="built_in">String</span>);</span><br><span class="line">dayjs().startOf(<span class="string">'year'</span>).format(<span class="string">'YYYY-MM-DD'</span>);  <span class="comment">// 2018-01-01</span></span><br></pre></td></tr></table></figure></p><p>返回当前时间的末尾时间的 Dayjs 对象，如月份的最后一天。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().endOf(unit : <span class="built_in">String</span>);</span><br><span class="line">dayjs().endOf(<span class="string">'month'</span>).format(<span class="string">'YYYY-MM-DD'</span>); <span class="comment">// 2018-07-31</span></span><br></pre></td></tr></table></figure><h2 id="六-时间差"><a href="#六-时间差" class="headerlink" title="六 时间差"></a>六 时间差</h2><p>时间差是两个 dayjs 对象的之差所得的毫秒数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dayjs().diff(Dayjs, unit);</span><br><span class="line">dayjs().diff(dayjs(<span class="string">'2000-2-1'</span>), <span class="string">'years'</span>); <span class="comment">// 18</span></span><br></pre></td></tr></table></figure></p><p>源码逻辑是先计算出两个时间相差的毫秒数和月数，再根据传入的单位去选择计算。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">diff(input, units, float) &#123;</span><br><span class="line">    <span class="keyword">const</span> unit = Utils.prettyUnit(units)</span><br><span class="line">    <span class="keyword">const</span> that = dayjs(input)</span><br><span class="line">    <span class="keyword">const</span> diff = <span class="keyword">this</span> - that</span><br><span class="line">    <span class="keyword">let</span> result = Utils.monthDiff(<span class="keyword">this</span>, that)</span><br><span class="line">    <span class="keyword">switch</span> (unit) &#123;</span><br><span class="line">      <span class="keyword">case</span> C.Y:</span><br><span class="line">        result /= <span class="number">12</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.M:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.Q:</span><br><span class="line">        result /= <span class="number">3</span></span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.W:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_WEEK</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.D:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_DAY</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.H:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_HOUR</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.MIN:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_MINUTE</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">case</span> C.S:</span><br><span class="line">        result = diff / C.MILLISECONDS_A_SECOND</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">      <span class="keyword">default</span>: <span class="comment">// milliseconds</span></span><br><span class="line">        result = diff</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> float ? result : Utils.absFloor(result)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="七-其他方法"><a href="#七-其他方法" class="headerlink" title="七 其他方法"></a>七 其他方法</h2><h5 id="获取-unix-毫秒时间戳："><a href="#获取-unix-毫秒时间戳：" class="headerlink" title="获取 unix 毫秒时间戳："></a>获取 unix 毫秒时间戳：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().valueOf(); <span class="comment">// 1531633650522</span></span><br></pre></td></tr></table></figure><h5 id="获取-unix-秒级时间戳："><a href="#获取-unix-秒级时间戳：" class="headerlink" title="获取 unix 秒级时间戳："></a>获取 unix 秒级时间戳：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().unix(); <span class="comment">// 1531633677</span></span><br></pre></td></tr></table></figure><h5 id="返回月份的天数："><a href="#返回月份的天数：" class="headerlink" title="返回月份的天数："></a>返回月份的天数：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().daysInMonth(); <span class="comment">// 31</span></span><br></pre></td></tr></table></figure><h5 id="获取-Date-对象："><a href="#获取-Date-对象：" class="headerlink" title="获取 Date 对象："></a>获取 Date 对象：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toDate(); <span class="comment">// Sun Jul 15 2018 13:48:41 GMT+0800 (CST)</span></span><br></pre></td></tr></table></figure><h5 id="获取数组格式："><a href="#获取数组格式：" class="headerlink" title="获取数组格式："></a>获取数组格式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toArray(); <span class="comment">//[2018, 6, 13, 20, 34, 13, 424];</span></span><br></pre></td></tr></table></figure><h5 id="获取对象格式："><a href="#获取对象格式：" class="headerlink" title="获取对象格式："></a>获取对象格式：</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dayjs().toObject();<span class="comment">// &#123;years: 2018, months: 6, date: 13, hours: 20, minutes: 34...&#125;</span></span><br></pre></td></tr></table></figure><h2 id="八-dayjs-插件用法"><a href="#八-dayjs-插件用法" class="headerlink" title="八 dayjs 插件用法"></a>八 dayjs 插件用法</h2><p>dayjs 的插件，通过挂载到 dayjs 函数下的 extend 函数加载，然后使用：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> plugin <span class="comment">// 导入插件</span></span><br><span class="line">dayjs.extend(plugin, options) <span class="comment">// 加载插件的同时，加入插件所需要的参数</span></span><br></pre></td></tr></table></figure></p><p>使用官方的 IsLeapYear 插件(判断是否是闰年):<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> isLeapYear <span class="keyword">from</span> <span class="string">'dayjs/plugin/isLeapYear'</span></span><br><span class="line">dayjs.extend(isLeapYear)</span><br><span class="line">dayjs(<span class="string">'2000-01-01'</span>).isLeapYear() <span class="comment">// true</span></span><br><span class="line">dayjs(<span class="string">'2018-01-01'</span>).isLeapYear() <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>dayjs.extend() 方法，接受两个参数，即插件（函数）和插件的选项。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扩展插件的方法</span></span><br><span class="line"><span class="comment">// plugin：插件函数</span></span><br><span class="line"><span class="comment">// option：插件的选项</span></span><br><span class="line">dayjs.extend = <span class="function">(<span class="params">plugin, option</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 插件函数接受三个参数</span></span><br><span class="line">  <span class="comment">// 1.插件选项 2.Dayjs 类 3.dayjs 函数</span></span><br><span class="line">  <span class="comment">// 插件的方法都是挂载在 Dayjs 类的原型对象上的（Dayjs.prototype）。</span></span><br><span class="line">  plugin(option, Dayjs, dayjs)</span><br><span class="line">  <span class="keyword">return</span> dayjs</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>IsLeapYear 的源码如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> (o, c) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> proto = c.prototype</span><br><span class="line">  proto.isLeapYear = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">this</span>.$y % <span class="number">4</span> === <span class="number">0</span>) &amp;&amp; (<span class="keyword">this</span>.$y % <span class="number">100</span> !== <span class="number">0</span>)) || (<span class="keyword">this</span>.$y % <span class="number">400</span> === <span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将 isLeapYear 函数挂载到 Dayjs 类的原型上，所以每个 Dayjs 实例都可以使用 isLeapYear 方法。</p><hr><h2 id="感谢"><a href="#感谢" class="headerlink" title="感谢"></a>感谢</h2><p> 特别感谢 DaisyXL 和 Young 的支持和分析！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;dayjs 是一个轻量的 JavaScript 时间日期处理库，其用法（api）和 Moment.js 完全一样。&lt;br&gt;
    
    </summary>
    
      <category term="guanxiaofeng" scheme="http://xgfe.github.io/categories/guanxiaofeng/"/>
    
    
      <category term="dayjs" scheme="http://xgfe.github.io/tags/dayjs/"/>
    
      <category term="momentjs" scheme="http://xgfe.github.io/tags/momentjs/"/>
    
  </entry>
  
  <entry>
    <title>webpack 入门</title>
    <link href="http://xgfe.github.io/2018/06/24/matengfei/webpack%E5%85%A5%E9%97%A8/"/>
    <id>http://xgfe.github.io/2018/06/24/matengfei/webpack入门/</id>
    <published>2018-06-24T12:31:49.000Z</published>
    <updated>2018-12-06T11:56:44.285Z</updated>
    
    <content type="html"><![CDATA[<p>Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、AMD 模块、ES6 模块、CSS、图片、JSON、Coffeescript、LESS 等。</p><a id="more"></a><h1 id="1、webpack-简介"><a href="#1、webpack-简介" class="headerlink" title="1、webpack 简介"></a>1、webpack 简介</h1><p>前端是基于多语言、多层次的编码和组织工作，其次前端产品的交付是基于浏览器，这些资源是通过增量加载的方式运行到浏览器端，如何在开发环境组织好这些碎片化的代码和资源，并且保证他们在浏览器端快速、优雅的加载和更新，就需要一个模块化系统。</p><h2 id="webpack-的优势"><a href="#webpack-的优势" class="headerlink" title="webpack 的优势"></a>webpack 的优势</h2><ul><li>1、支持 CommonJs 和 AMD 模块，意思也就是我们基本可以无痛迁移旧项目。</li><li>2、支持模块加载器和插件机制，可对模块灵活定制。babel-loader 更是有效支持 ES6 。 </li><li>3、可以通过配置，打包成多个文件。有效利用浏览器的缓存功能提升性能。 </li><li>4、将样式文件和图片等静态资源也可视为模块进行打包。配合 loader 加载器，可以支持 sass ，less 等 CSS 预处理器。 </li><li>5、内置有 source map ，即使打包在一起依旧方便调试。</li></ul><h2 id="webpack-核心概念"><a href="#webpack-核心概念" class="headerlink" title="webpack 核心概念"></a>webpack 核心概念</h2><p>Webpack 具有四个核心的概念，想要入门 Webpack 就得先好好了解这四个核心概念。它们分别是Entry（入口）、Output（输出）、loader 和 Plugins（插件）。接下来详细介绍这四个核心概念。</p><h3 id="1-Entry"><a href="#1-Entry" class="headerlink" title="1. Entry"></a>1. Entry</h3><p>Entry 是 Webpack 的入口起点指示，它指示 webpack 应该从哪个模块开始着手，来作为其构建内部依赖图的开始。可以在配置文件（webpack.config.js）中配置 entry 属性来指定一个或多个入口点，默认为 ./src（ webpack 4开始引入默认值）。<br>具体配置方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">entry: string | <span class="built_in">Array</span>&lt;string&gt;</span><br></pre></td></tr></table></figure><p>前者一个单独的 string 是配置单独的入口文件，配置为后者（一个数组）时，是多文件入口。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./app.js'</span>,</span><br><span class="line">        vendors: <span class="string">'./vendors.js'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上配置表示从 app 和 vendors 属性开始打包构建依赖树，这样做的好处在于分离自己开发的业务逻辑代码和第三方库的源码，因为第三方库安装后，源码基本就不再变化，这样分开打包有利于提升打包速度，减少了打包文件的个数。</p><h3 id="2-Output"><a href="#2-Output" class="headerlink" title="2. Output"></a>2. Output</h3><p>Output 属性告诉 webpack 在哪里输出它所创建的 bundles ，也可指定 bundles 的名称，默认位置为 ./dist。整个应用结构都会被编译到指定的输出文件夹中去，最基本的属性包括 filename（文件名）和 path（输出路径）。</p><p>值得注意的是，即是你配置了多个入口文件，你也只能有一个输出点。</p><p>具体配置方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: <span class="string">'/home/proj/public/dist'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>值得注意的是，output.filename 必须是绝对路径，如果是一个相对路径，打包时 webpack 会抛出异常。</p><p>多个入口时，使用下面的语法输出多个 bundle ：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: &#123;</span><br><span class="line">        app: <span class="string">'./src/app.js'</span>,</span><br><span class="line">        vendors: <span class="string">'./src/vendors.js'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    output: &#123;</span><br><span class="line">        filename: <span class="string">'[name].js'</span>,</span><br><span class="line">        path: __dirname + <span class="string">'/dist'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-Loaders"><a href="#3-Loaders" class="headerlink" title="3. Loaders"></a>3. Loaders</h3><p>loader 可以理解为 webpack 的编译器，它使得 webpack 可以处理一些非 JavaScript 文件，比如 png、csv、xml、css、json 等各种类型的文件，使用合适的 loader 可以让 JavaScript 的 import 导入非 JavaScript 模块。JavaScript 只认为 JavaScript 文件是模块，而 webpack 的设计思想即万物皆模块，为了使得 webpack 能够认识其他“模块”，所以需要 loader 这个“编译器”。</p><p>webpack 中配置 loader 有两个目标：</p><p>（1）test 属性：标志有哪些后缀的文件应该被处理，是一个正则表达式。</p><p>（2）use 属性：指定 test 类型的文件应该使用哪个 loader 进行预处理。</p><p>比如 webpack.config.js :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'...'</span>,</span><br><span class="line">    output: <span class="string">'...'</span>,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: <span class="string">'css-loader'</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>该配置文件指示了所有的 css 文件在 import 时都应该经过 css-loader 处理，经过 css-loader 处理后，可以在 JavaScript 模块中直接使用 import 语句导入 css 模块。但是使用 css-loader 的前提是先使用 npm 安装 css-loader。</p><p>此处需要注意的是定义 loaders 规则时，不是定义在对象的 rules 属性上，而是定义在 module 属性的 rules 属性中。</p><p>配置多个 loader ：</p><p>有时候，导入一个模块可能要先使用多个 loader 进行预处理，这时就要对指定类型的文件配置多个 loader 进行预处理，配置多个 loader ，把 use 属性赋值为数组即可，webpack 会按照数组中 loader 的先后顺序，使用对应的 loader 依次对模块文件进行预处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">                test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">                use: [</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'style-loader'</span></span><br><span class="line">                    &#125;,</span><br><span class="line">                    &#123;</span><br><span class="line">                        loader: <span class="string">'css-loader'</span></span><br><span class="line">                    &#125;</span><br><span class="line">                ]</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-Plugins"><a href="#4-Plugins" class="headerlink" title="4. Plugins"></a>4. Plugins</h3><p>loader 用于转换非 JavaScript 类型的文件，而插件可以用于执行范围更广的任务，包括打包、优化、压缩、搭建服务器等等，功能十分强大。要是用一个插件，一般是先使用npm包管理器进行安装，然后在配置文件中引入，最后将其实例化后传递给 plugins 数组属性。</p><p>插件是 webpack 的支柱功能，目前主要是解决 loader 无法实现的其他许多复杂功能，通过 plugins 属性使用插件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// webpack.config.js</span></span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin()</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-Mode"><a href="#5-Mode" class="headerlink" title="5. Mode"></a>5. Mode</h3><p>模式（ Mode ）可以通过配置对象的 mode 属性进行配置，主要值为 production 或者 development。两种模式的区别在于一个是为生产环境编译打包，一个是为了开发环境编译打包。生产环境模式下，webpack 会自动对代码进行压缩等优化，省去了配置的麻烦。</p><p>学习完以上基本概念之后，基本也就入门 webpack 了，因为 webpack 的强大就是建立在这些基本概念之上，利用 webpack 多样的 loaders 和 plugins，可以实现强大的打包功能。</p><h1 id="2、js-模块化"><a href="#2、js-模块化" class="headerlink" title="2、js 模块化"></a>2、js 模块化</h1><h2 id="2-1-命名空间"><a href="#2-1-命名空间" class="headerlink" title="2.1 命名空间"></a>2.1 命名空间</h2><p>命名空间是通过为项目或库创建一个全局对象，然后将所有功能添加到该全局变量中。通过减少程序中全局变量的数量，实现单全局变量，从而在具有大量函数、对象和其他变量的情况下不会造成全局污染，同时也避免了命名冲突等问题。</p><p>然而，在不同的文件中给一个命名空间添加属性的时候，首先要保证这个命名空间是已经存在的，同时不对已有的命名空间造成任何破坏。可以通过非破坏性的命名空间函数实现：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> KUI = KUI || &#123;&#125;;</span><br><span class="line">KUI.utils = KUI.utils || &#123;&#125;;</span><br><span class="line"></span><br><span class="line">KUI.utils.namespace = <span class="function"><span class="keyword">function</span>(<span class="params">ns</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parts = ns.split(<span class="string">"."</span>),</span><br><span class="line">        object = KUI,</span><br><span class="line">        i, len;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(parts[<span class="number">0</span>] === <span class="string">"KUI"</span>)&#123;</span><br><span class="line">        parts = parts.slice(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>, len = parts.length; i &lt; len; i+=<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!object[parts[i]])&#123;</span><br><span class="line">            object[parts[i]] = &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        object = object[parts[i]];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>用法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">KUI.utils.namespace(<span class="string">"KUI.common"</span>);</span><br><span class="line">KUI.utils.namespace(<span class="string">"KUI.common.testing"</span>);</span><br><span class="line">KUI.utils.namespace(<span class="string">"KUI.modules.function.plugins"</span>);</span><br><span class="line">KUI.utils.namespace(<span class="string">"format"</span>);</span><br></pre></td></tr></table></figure><p>看一下经过上述后 KUI 都有什么：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"utils"</span>: &#123;&#125;,</span><br><span class="line">    <span class="string">"common"</span>: &#123;</span><br><span class="line">        <span class="string">"testing"</span>: &#123;&#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"modules"</span>: &#123;</span><br><span class="line">        <span class="string">"function"</span>: &#123;</span><br><span class="line">            <span class="string">"plugins"</span>: &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"format"</span>: &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命名空间模式的缺点</p><p>1.需要输入更长的字符，并且需要更长的解析时间；<br>2.对单全局变量的依赖性，即任何代码都可以修改该全局实例，其他代码将获得修改后的实例。</p><h2 id="2-2-CommonJs"><a href="#2-2-CommonJs" class="headerlink" title="2.2 CommonJs"></a>2.2 CommonJs</h2><p>CommonJS 是 nodejs 也就是服务器端广泛使用的模块化机制。<br>该规范的主要内容是，模块必须通过 module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。</p><p>根据这个规范，每个文件就是一个模块，有自己的作用域，文件中的变量、函数、类等都是对其他文件不可见的。</p><p>如果想在多个文件分享变量，必须定义为 global 对象的属性。</p><h3 id="定义模块"><a href="#定义模块" class="headerlink" title="定义模块"></a>定义模块</h3><p>在每个模块内部，module 变量代表当前模块。它的 exports 属性是对外的接口，将模块的接口暴露出去。其他文件加载该模块，实际上就是读取 module.exports 变量。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> addX = <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + x;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">module</span>.exports.x = x;</span><br><span class="line"><span class="built_in">module</span>.exports.addX = addX;</span><br></pre></td></tr></table></figure><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>require 方法用于加载模块，后缀名默认为.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'./app.js'</span>);</span><br></pre></td></tr></table></figure><p>模块加载的顺序，按照其在代码中出现的顺序</p><p>根据参数的不同格式，require 命令去不同路径寻找模块文件。</p><ul><li>如果参数字符串以“/”开头，则表示加载的是一个位于绝对路径的模块文件。</li><li>如果参数字符串以“./”开头，则表示加载的是一个位于相对路径的模块文件</li><li>如果参数字符串不以“./” 或 “/”开头，则表示加载的是一个默认提供的核心模块（ node 核心模块，或者通过全局安装或局部安装在 node_modules 目录中的模块）</li></ul><h3 id="入口文件"><a href="#入口文件" class="headerlink" title="入口文件"></a>入口文件</h3><p>一般都会有一个主文件（入口文件），在 index.html 中加载这个入口文件，然后在这个入口文件中加载其他文件。</p><p>可以通过在 package.json 中配置 main 字段来指定入口文件。</p><h3 id="模块缓存"><a href="#模块缓存" class="headerlink" title="模块缓存"></a>模块缓存</h3><p>第一次加载某个模块时，Node 会缓存该模块。以后再加载该模块，就直接从缓存取出该模块的 module.exports 属性。</p><h3 id="加载机制"><a href="#加载机制" class="headerlink" title="加载机制"></a>加载机制</h3><p>CommonJS 模块的加载机制是，输入的是被输出的值的拷贝。也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。</p><p>由于 CommonJS 是同步加载模块，这对于服务器端不是一个问题，因为所有的模块都放在本地硬盘。等待模块时间就是硬盘读取文件时间很小。但是，对于浏览器而言，它需要从服务器加载模块，涉及到网速，代理等原因，一旦等待时间过长，浏览器处于”假死”状态。</p><h2 id="2-3-AMD"><a href="#2-3-AMD" class="headerlink" title="2.3 AMD"></a>2.3 AMD</h2><p>AMD 是 “Asynchronous Module Definition” 的缩写，即 “异步模块定义”。它采用异步方式加载模块，模块的加载不影响它后面语句的运行。 </p><p>这里异步指的是不堵塞浏览器其他任务（ dom 构建，css 渲染等），而加载内部是同步的（加载完模块后立即执行回调）。</p><blockquote><p>requirejs 即为遵循AMD规范的模块化工具。 </p></blockquote><p>RequireJS 的基本思想是，通过 define 方法，将代码定义为模块；通过 require 方法，实现代码的模块加载。</p><p>RequireJS 主要解决两个问题：</p><ul><li>多个 js 文件可能有依赖关系，被依赖的文件需要早于依赖它的文件加载到浏览器。</li><li>js 加载的时候浏览器会停止页面渲染，加载文件越多，页面失去响应时间越长。</li></ul><h3 id="定义模块-1"><a href="#定义模块-1" class="headerlink" title="定义模块"></a>定义模块</h3><p>RequireJS 定义了一个函数 define，它是全局变量，用来定义模块:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">define(id?, dependencies?, factory);</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><p>id：指定义中模块的名字，可选；如果没有提供该参数，模块的名字应该默认为模块加载器请求的指定脚本的名字。如果提供了该参数，模块名必须是“顶级”的和绝对的（不允许相对名字）。</p></li><li><p>依赖 dependencies：是一个当前模块依赖的，已被模块定义的模块标识的数组字面量。<br>依赖参数是可选的，如果忽略此参数，它应该默认为[“require”, “exports”, “module”]。然而，如果工厂方法的长度属性小于 3 ，加载器会选择以函数的长度属性指定的参数个数调用工厂方法。</p></li><li><p>工厂方法 factory，模块初始化要执行的函数或对象。如果为函数，它应该只被执行一次。如果是对象，此对象应该为模块的输出值。</p></li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="string">"alpha"</span>, [<span class="string">"require"</span>, <span class="string">"exports"</span>, <span class="string">"beta"</span>], <span class="function"><span class="keyword">function</span> (<span class="params">require, exports, beta</span>) </span>&#123;</span><br><span class="line">      exports.verb = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> beta.verb();</span><br><span class="line">          <span class="comment">//Or:</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">require</span>(<span class="string">"beta"</span>).verb();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><h3 id="加载模块-1"><a href="#加载模块-1" class="headerlink" title="加载模块"></a>加载模块</h3><p>AMD 也采用 require 命令加载模块，但是不同于 CommonJS ，它要求两个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>([<span class="string">'math'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">math</span>) </span>&#123;</span><br><span class="line">  math.add(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>第一个参数是一个数组，里面的成员是要加载的模块，第二个参数是加载完成后的回调函数。</p><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>require 方法本身也是一个对象，它带有一个 config 方法，用来配置 require.js 运行参数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.config(&#123;</span><br><span class="line">    paths: &#123;</span><br><span class="line">        <span class="string">"backbone"</span>: <span class="string">"vendor/backbone"</span>,</span><br><span class="line">        <span class="string">"underscore"</span>: <span class="string">"vendor/underscore"</span></span><br><span class="line">    &#125;,</span><br><span class="line">    shim: &#123;</span><br><span class="line">        <span class="string">"backbone"</span>: &#123;</span><br><span class="line">            deps: [ <span class="string">"underscore"</span> ],</span><br><span class="line">            exports: <span class="string">"Backbone"</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"underscore"</span>: &#123;</span><br><span class="line">            exports: <span class="string">"_"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>paths：paths 参数指定各个模块的位置。这个位置可以是同一个服务器上的相对位置，也可以是外部网址。可以为每个模块定义多个位置，如果第一个位置加载失败，则加载第二个位置。上面就是指定了 jquery 的位置，那么就可以直接在文件中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">require（[&apos;jquery&apos;],function($)&#123;&#125;）</span><br></pre></td></tr></table></figure><p>shim：有些库不是 AMD 兼容的，这时就需要指定 shim 属性的值。shim 可以理解成“垫片”，用来帮助require.js 加载非 AMD 规范的库。</p><h2 id="2-4-CMD"><a href="#2-4-CMD" class="headerlink" title="2.4 CMD"></a>2.4 CMD</h2><p>CMD 即 Common Module Definition 通用模块定义，CMD 规范是国内发展出来的，就像 AMD 有个requireJS，CMD 有个浏览器的实现 SeaJS ，SeaJS 要解决的问题和 requireJS 一样，只不过在模块定义方式和模块加载（可以说运行、解析）时机上有所不同。</p><p>在 CMD 规范中，一个模块就是一个文件。代码的书写格式如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 模块代码</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>require 是可以把其他模块导入进来的一个参数; 而 exports 是可以把模块内的一些属性和方法导出的; module 是一个对象，上面存储了与当前模块相关联的一些属性和方法。</p><ul><li>AMD 是依赖关系前置,在定义模块的时候就要声明其依赖的模块;</li><li>CMD 是按需加载依赖就近,只有在用到某个模块的时候再去 require ;</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CMD</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params">require, exports, module</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="built_in">require</span>(<span class="string">'./a'</span>)</span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  <span class="keyword">var</span> b = <span class="built_in">require</span>(<span class="string">'./b'</span>) <span class="comment">// 依赖可以就近书写</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// AMD 默认推荐的是</span></span><br><span class="line">define([<span class="string">'./a'</span>, <span class="string">'./b'</span>], <span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123; <span class="comment">// 依赖必须一开始就写好</span></span><br><span class="line">  a.doSomething()</span><br><span class="line">  <span class="comment">// 此处略去 100 行</span></span><br><span class="line">  b.doSomething()</span><br><span class="line">  ...</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="2-5-ES6-Module"><a href="#2-5-ES6-Module" class="headerlink" title="2.5 ES6 Module"></a>2.5 ES6 Module</h2><p>ES6 正式提出了内置的模块化语法，我们在浏览器端无需额外引入 requirejs 来进行模块化。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。</p><p>ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过 import 命令输入。</p><p>ES6 中的模块有以下特点：</p><ul><li>模块自动运行在严格模式下</li><li>在模块的顶级作用域创建的变量，不会被自动添加到共享的全局作用域，它们只会在模块顶级作用域的内部存在</li><li>模块顶级作用域的 this 值为 undefined</li><li>对于需要让模块外部代码访问的内容，模块必须导出它们</li></ul><h3 id="定义模块-2"><a href="#定义模块-2" class="headerlink" title="定义模块"></a>定义模块</h3><p>使用 export 关键字将任意变量、函数或者类公开给其他模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导出变量</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> color = <span class="string">"red"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> name = <span class="string">"cz"</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出函数</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1,num2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1+num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出类</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(length, width) &#123;</span><br><span class="line">        <span class="keyword">this</span>.length = length;</span><br><span class="line">        <span class="keyword">this</span>.width = width;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 * num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//导出对象，即导出引用</span></span><br><span class="line"><span class="keyword">export</span> &#123;multiply&#125;</span><br></pre></td></tr></table></figure><h3 id="重命名模块"><a href="#重命名模块" class="headerlink" title="重命名模块"></a>重命名模块</h3><p>重命名想导出的变量、函数或类的名称</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123;sum <span class="keyword">as</span> add&#125;</span><br></pre></td></tr></table></figure><p>这里将本地的 sum 函数重命名为 add 导出，因此在使用此模块的时候必须使用 add 这个名称。</p><h3 id="导出默认值"><a href="#导出默认值" class="headerlink" title="导出默认值"></a>导出默认值</h3><p>模块的默认值是使用 default 关键字所指定的单个变量、函数或类，而你在每个模块中只能设置一个默认导出。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此模块将一个函数作为默认值进行了导出， default 关键字标明了这是一个默认导出。此函数并不需要有名称，因为它就代表这个模块自身。对比最前面使用 export 导出的函数，并不是匿名函数而是必须有一个名称用于加载模块的时候使用，但是默认导出则无需一个名字，因为模块名就代表了这个导出值。</p><p>也可以使用重命名语法来导出默认值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; sum <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br></pre></td></tr></table></figure><h3 id="加载模块-2"><a href="#加载模块-2" class="headerlink" title="加载模块"></a>加载模块</h3><p>在模块中使用 import 关键字来导入其他模块。<br>import 语句有两个部分，一是需要导入的标识符，二是需导入的标识符的来源模块。此处是导入语句的基本形式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; identifier1,identifier2 &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span></span><br></pre></td></tr></table></figure><ul><li>大括号中指定了从给定模块导入的标识符</li><li>from 指明了需要导入的模块。模块由一个表示模块路径的字符串来指定。</li></ul><p>当从模块导入了一个绑定时，你不能在当前文件中再定义另一个同名变量（包括导入另一个同名绑定），也不能在对应的 import 语句之前使用此标识符，更不能修改它的值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//导入单个绑定</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入多个绑定</span></span><br><span class="line"><span class="keyword">import</span> &#123;sum,multiply&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//完全导入一个模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> example <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line">example.sum(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">example.multiply(<span class="number">2</span>,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//重命名导入</span></span><br><span class="line"><span class="keyword">import</span> &#123; sum <span class="keyword">as</span> add&#125; <span class="keyword">from</span> <span class="string">'./example.js'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//导入默认值</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br></pre></td></tr></table></figure><p>然而要记住，无论你对同一个模块使用了多少次 import 语句，该模块都只会被执行一次。</p><p>在导出模块的代码执行之后，已被实例化的模块就被保留在内存中，并随时都能被其他 import 所引用.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; sum &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; multiply &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; magicNumber &#125; <span class="keyword">from</span> <span class="string">"./example.js"</span>;</span><br></pre></td></tr></table></figure><p>尽管此处的模块使用了三个 import 语句，但 example.js 只会被执行一次。若同一个应用中的其他模块打算从 example.js 导入绑定，则那些模块都会使用这段代码中所用的同一个模块实例。</p><h3 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h3><p>export 与 import 都有一个重要的限制，那就是它们必须被用在其他语句或表达式的外部，而不能使用在if等代码块内部。原因之一是模块语法需要让 JS 能静态判断需要导出什么，正因为此，你只能在模块的顶级作用域使用 export 与 import。</p><h1 id="3、webpack-使用"><a href="#3、webpack-使用" class="headerlink" title="3、webpack 使用"></a>3、webpack 使用</h1><h2 id="3-1-打包-js"><a href="#3-1-打包-js" class="headerlink" title="3.1 打包 js"></a>3.1 打包 js</h2><p>webpack 对各种模块化的支持</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="comment">// es module</span></span><br><span class="line"><span class="keyword">import</span> sum <span class="keyword">from</span> <span class="string">'./sum'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// commonjs</span></span><br><span class="line"><span class="keyword">var</span> minus = <span class="built_in">require</span>(<span class="string">'./minux'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//amd</span></span><br><span class="line"><span class="built_in">require</span>([<span class="string">'muti'</span>], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(muti(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">2</span>, <span class="number">3</span>))</span><br><span class="line"><span class="built_in">console</span>.log(minus(<span class="number">3</span>, <span class="number">2</span>))</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sum.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// minus.js</span></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// muti.js</span></span><br><span class="line">define(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a * b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="压缩-JS-代码："><a href="#压缩-JS-代码：" class="headerlink" title="压缩 JS 代码："></a>压缩 JS 代码：</h3><p>现在你写的 JS 代码，在上线之前，都是需要进行压缩的，在没有 webpack 和 gulp 这些工具前，你可能需要找一个压缩软件或者在线进行压缩，在 Webpack 中可以很轻松的实现JS代码的压缩，它是通过插件的方式实现的，这里我们就先来引入一个 uglifyjs-webpack-plugin ( JS 压缩插件，简称 uglify )。</p><p>注意：虽然 uglifyjs 是插件，但是 webpack 版本里默认已经集成，不需要再次安装。</p><p>引入：</p><p>我们需要在 webpack.config.js 中引入 uglifyjs-webpack-glugin 插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> uglify = <span class="built_in">require</span>(<span class="string">'uglifyjs-webpack-plugin'</span>);</span><br></pre></td></tr></table></figure><p>引入后在 plugins 配置里new一个 uglify 对象就可以了，代码如下。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">        <span class="keyword">new</span> uglify()</span><br><span class="line">    ],</span><br></pre></td></tr></table></figure><p>这时候在终端中使用 webpack 进行打包，你会发现 JS 代码已经被压缩了。</p><h2 id="3-2-编译-ES6"><a href="#3-2-编译-ES6" class="headerlink" title="3.2 编译 ES6"></a>3.2 编译 ES6</h2><p>在前端开发中都开始使用 ES6 的语法了，虽然说 webpack3 增加了一些 ES6 的转换支持，但是实际效果不是很好。所以我在开发中还是喜欢添加 Babel-loader 的，我也查看了一些别人的 webpack 配置也都增加了 babel-loader，所以这节课我们学习一下如何增加 Babel 支持。</p><p>Babel 是什么？<br>Babel 其实是一个编译 JavaScript 的平台，它的强大之处表现在可以通过便宜帮你达到以下目的：</p><ul><li>使用下一代的 javaScript 代码( ES6, ES7….)，即使这些标准目前并未被当前的浏览器完全支持。</li><li>使用基于 JavaScript 进行了扩展的语言，比如 React 的 JSX 。</li></ul><h3 id="Babel-的安装与配置"><a href="#Babel-的安装与配置" class="headerlink" title="Babel 的安装与配置"></a>Babel 的安装与配置</h3><p>Babel 其实是几个模块化的包，其核心功能位于称为 babel-core 的 npm 包中，webpack 可以把其不同的包整合在一起使用，对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析 ES6 的 babel-preset-es2015 包和解析 JSX 的 babel-preset-react 包）。</p><p>安装依赖包</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-loader babel-core babel-preset-env</span><br></pre></td></tr></table></figure><p>在 webpack 中配置 Babel 的方法如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">        options:&#123;</span><br><span class="line">            presets:[</span><br><span class="line">                <span class="string">"es2015"</span>,<span class="string">"react"</span></span><br><span class="line">            ]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="babelrc配置"><a href="#babelrc配置" class="headerlink" title=".babelrc配置"></a>.babelrc配置</h3><p>虽然 Babel 可以直接在 webpack.config.js 中进行配置，但是考虑到 babel 具有非常多的配置选项，如果卸载 webapck.config.js 中会非常的雍长不可阅读，所以我们经常把配置卸载 .babelrc 文件里。</p><p>在项目根目录新建 .babelrc 文件，并把配置写到文件里。</p><p>. babelrc</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>:[<span class="string">"react"</span>,<span class="string">"es2015"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>.webpack.config.js 里的 loader 配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test:<span class="regexp">/\.(jsx|js)$/</span>,</span><br><span class="line">    use:&#123;</span><br><span class="line">        loader:<span class="string">'babel-loader'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    exclude:<span class="regexp">/node_modules/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ENV："><a href="#ENV：" class="headerlink" title="ENV："></a>ENV：</h3><p>babel-preset-env 代替 babel-preset-ES2015 , babel 官方推出了 babel-preset-env ，并建议在使用的时候选择 env 代替之前的 ES20** 。env 为我们提供了更智能的编译选择。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev babel-preset-env</span><br></pre></td></tr></table></figure><p>然后修改 .babelrc 里的配置文件。其实只要把之前的 es2015 换成 env 就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"presets"</span>:[<span class="string">"react"</span>,<span class="string">"env"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-3-打包公共代码"><a href="#3-3-打包公共代码" class="headerlink" title="3.3 打包公共代码"></a>3.3 打包公共代码</h2><p>CommonsChunkPlugin 插件，是一个可选的用于建立一个独立文件 (又称作 chunk ) 的功能，这个文件包括多个入口 chunk 的公共模块。</p><p>通过将公共模块拆出来，最终合成的文件能够在最开始的时候加载一次，便存到缓存中供后续使用。这个带来速度上的提升，因为浏览器会迅速将公共的代码从缓存中取出来，而不是每次访问一个新页面时，再去加载一个更大的文件。</p><h3 id="公共chunk-用于-入口chunk-entry-chunk"><a href="#公共chunk-用于-入口chunk-entry-chunk" class="headerlink" title="公共chunk 用于 入口chunk (entry chunk)"></a>公共chunk 用于 入口chunk (entry chunk)</h3><p>生成一个额外的 chunk 包含入口 chunk 的公共模块。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">"commons"</span>,</span><br><span class="line">  <span class="comment">// ( 公共chunk(commnons chunk) 的名称)</span></span><br><span class="line"></span><br><span class="line">  filename: <span class="string">"commons.js"</span>,</span><br><span class="line">  <span class="comment">// ( 公共chunk 的文件名)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// minChunks: 3,</span></span><br><span class="line">  <span class="comment">// (模块必须被3个 入口 chunk 共享)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// chunks: ["pageA", "pageB"],</span></span><br><span class="line">  <span class="comment">// (只使用这些 入口chunk)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>你必须在 入口 chunk 之前加载生成的这个公共 chunk:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=<span class="string">"commons.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=<span class="string">"entry.bundle.js"</span> charset=<span class="string">"utf-8"</span>&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure><h3 id="明确第三方库-chunk"><a href="#明确第三方库-chunk" class="headerlink" title="明确第三方库 chunk"></a>明确第三方库 chunk</h3><p>将你的代码拆分成公共代码和应用代码。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">entry: &#123;</span><br><span class="line">  vendor: [<span class="string">"jquery"</span>, <span class="string">"other-lib"</span>],</span><br><span class="line">  app: <span class="string">"./entry"</span></span><br><span class="line">&#125;,</span><br><span class="line">plugins: [</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">    name: <span class="string">"vendor"</span>,</span><br><span class="line">    <span class="comment">// filename: "vendor.js"</span></span><br><span class="line">    <span class="comment">// (给 chunk 一个不同的名字)</span></span><br><span class="line"></span><br><span class="line">    minChunks: <span class="literal">Infinity</span>,</span><br><span class="line">    <span class="comment">// (随着 entry chunk 越来越多，</span></span><br><span class="line">    <span class="comment">// 这个配置保证没其它的模块会打包进 vendor chunk)</span></span><br><span class="line">  &#125;)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="将公共模块打包进父-chunk"><a href="#将公共模块打包进父-chunk" class="headerlink" title="将公共模块打包进父 chunk"></a>将公共模块打包进父 chunk</h3><p>使用代码拆分功能，一个 chunk 的多个子 chunk 会有公共的依赖。为了防止重复，可以将这些公共模块移入父 chunk。这会减少总体的大小，但会对首次加载时间产生不良影响。如果预期到用户需要下载许多兄弟 chunks（例如，入口 trunk 的子 chunk），那这对改善加载时间将非常有用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  <span class="comment">// names: ["app", "subPageA"]</span></span><br><span class="line">  <span class="comment">// (选择 chunks，或者忽略该项设置以选择全部 chunks)</span></span><br><span class="line"></span><br><span class="line">  children: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// (选择所有被选 chunks 的子 chunks)</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// minChunks: 3,</span></span><br><span class="line">  <span class="comment">// (在提取之前需要至少三个子 chunk 共享这个模块)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="额外的异步公共-chunk"><a href="#额外的异步公共-chunk" class="headerlink" title="额外的异步公共 chunk"></a>额外的异步公共 chunk</h3><p>与上面的类似，但是并非将公共模块移动到父 chunk（增加初始加载时间），而是使用新的异步加载的额外公共 chunk 。当下载额外的 chunk 时，它将自动并行下载。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class="line">  name: <span class="string">"app"</span>,</span><br><span class="line">  <span class="comment">// or</span></span><br><span class="line">  names: [<span class="string">"app"</span>, <span class="string">"subPageA"</span>]</span><br><span class="line">  <span class="comment">// the name or list of names must match the name or names</span></span><br><span class="line">  <span class="comment">// of the entry points that create the async chunks</span></span><br><span class="line"></span><br><span class="line">  children: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// (选择所有被选 chunks 的子 chunks)</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">async</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// (创建一个异步 公共chunk)</span></span><br><span class="line"></span><br><span class="line">  minChunks: <span class="number">3</span>,</span><br><span class="line">  <span class="comment">// (在提取之前需要至少三个子 chunk 共享这个模块)</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-4-代码分割和懒加载"><a href="#3-4-代码分割和懒加载" class="headerlink" title="3.4 代码分割和懒加载"></a>3.4 代码分割和懒加载</h2><p>webpack 可以帮助我们将代码分成不同的逻辑块，在需要的时候加载这些代码。</p><h3 id="使用-require-ensure-来拆分代码"><a href="#使用-require-ensure-来拆分代码" class="headerlink" title="使用 require.ensure() 来拆分代码"></a>使用 require.ensure() 来拆分代码</h3><p>require.ensure() 是一种使用 CommonJS 的形式来异步加载模块的策略。在代码中通过 require.ensure([<fileurl>]) 引用模块，其使用方法如下：</fileurl></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure(dependencies: <span class="built_in">String</span>[], <span class="attr">callback</span>: <span class="function"><span class="keyword">function</span>(<span class="params">require</span>), <span class="title">chunkName</span>: <span class="title">String</span>);</span></span><br></pre></td></tr></table></figure><p>第一个参数指定依赖的模块，第二个参数是一个函数，在这个函数里面你可以使用 require 来加载其他的模块，webpack 会收集 ensure 中的依赖，将其打包在一个单独的文件中，在后续用到的时候使用 jsonp 异步地加载进去。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进行代码分割</span></span><br><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'lodash'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> _ = <span class="built_in">require</span>(<span class="string">'lodash'</span>);<span class="comment">//上边的require.ensure只会引入进来，但是并不会执行，再次require才会执行。</span></span><br><span class="line">&#125;,<span class="string">'vendor'</span>)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(page==<span class="string">'subPageA'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageA'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageA'</span>);</span><br><span class="line">    &#125;,<span class="string">'subPageA'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(page==<span class="string">'subPageB'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageB'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageB'</span>);</span><br><span class="line">    &#125;,subPageB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.ensure([<span class="string">'./subPageA'</span>,<span class="string">'./subPageB'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageA'</span>);</span><br><span class="line">        <span class="keyword">var</span> subPageB=<span class="built_in">require</span>(<span class="string">'subPageB'</span>);</span><br><span class="line">    &#125;,common)</span><br><span class="line">    <span class="comment">//common表示这个模块的名字</span></span><br></pre></td></tr></table></figure><p>但是仅仅这样配置并不能把公共 js 抽离出来，在多页面应用中可以通过 new webpack.optimize.CommonsChunkPlugin 这个 plugin 来实现，但是对于单页面来说，就需要借助 require.include 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>.include(<span class="string">'./moduleA'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(page==<span class="string">'subPageA'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageA'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageA'</span>);</span><br><span class="line">    &#125;,<span class="string">'subPageA'</span>)</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(page==<span class="string">'subPageB'</span>)&#123;</span><br><span class="line">    <span class="built_in">require</span>.ensure([<span class="string">'./subPageB'</span>],<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> subPageA=<span class="built_in">require</span>(<span class="string">'subPageB'</span>);</span><br><span class="line">    &#125;,subPageB)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就会把公共模块 moduleA 给抽离出来。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>import 与 require.ensure 最大的区别就是，他在引入的时候会直接执行，而不需要在此 require 了</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">'./subPageA'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>但是这样打包出来的是没有 chunkname 的，怎么添加 chunkname 呢？需要 webpack3+ 的魔法注释</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="comment">/*webpackChunkName:'subPageA'*/</span><span class="string">'./subPageA'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="3-5-处理css"><a href="#3-5-处理css" class="headerlink" title="3.5 处理css"></a>3.5 处理css</h2><h3 id="打包CSS"><a href="#打包CSS" class="headerlink" title="打包CSS"></a>打包CSS</h3><p>首先，在 src 目录下建立 css 文件夹，和 index.css 文件，并编写如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">body&#123;</span><br><span class="line">    background: burlywood;</span><br><span class="line">    color:white;</span><br><span class="line">    font-size:<span class="number">30</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建立好后，需要引入到入口文件中，才可以打包。在 entery.js 的首行加入代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> css <span class="keyword">from</span> <span class="string">'./css/index.css'</span>;</span><br></pre></td></tr></table></figure><p>CSS 和引入做好后，我们就需要使用 loader 来解析 CSS 文件了，这里我们需要两个解析用的 loader，分别是 style-loader 和 css-loader。</p><h3 id="style-loader"><a href="#style-loader" class="headerlink" title="style-loader"></a>style-loader</h3><p>它是用来处理 css 文件中的 url() 等。<br>用 npm install 进行项目安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev style-loader</span><br></pre></td></tr></table></figure><h3 id="CSS-loader"><a href="#CSS-loader" class="headerlink" title="CSS-loader"></a>CSS-loader</h3><p>它是用来将 css 插入到页面的 style 标签。<br>用 npm install 进行项目安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev css-loader</span><br></pre></td></tr></table></figure><h3 id="loaders配置："><a href="#loaders配置：" class="headerlink" title="loaders配置："></a>loaders配置：</h3><p>修改 webpack.config.js 中 module 属性中的配置代码如下：</p><p>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">              use: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><h3 id="提取-CSS"><a href="#提取-CSS" class="headerlink" title="提取 CSS"></a>提取 CSS</h3><p>目前，打包后的文件中，css 是打包在 js 代码里面的，这样不便于以后的维护，所以需要把 CSS 从 js 中分离出来，我们需要使用插件 Extract Text Plugin。</p><p>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev extract-text-webpack-plugin</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中引入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ExtractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br></pre></td></tr></table></figure><p>在 Plugins中配置:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> ExtractTextPlugin(<span class="string">'css/index.css'</span>);</span><br><span class="line"><span class="comment">//css/index.css是分离后的路径位置</span></span><br></pre></td></tr></table></figure><p>修改 Loader 配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.css$/</span>,</span><br><span class="line">            use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback:<span class="string">"style-loader"</span>,</span><br><span class="line">                use:<span class="string">"css-loader"</span></span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置Less"><a href="#配置Less" class="headerlink" title="配置Less"></a>配置Less</h3><p>Less 作为目前很火的 CSS 预处理语言，它扩展了 CSS 语言，增加了变量、Mixin 、函数等特性，使 CSS 更易维护和扩展；</p><p>安装:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev less less-loader</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中配置 Loader:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">            use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback:<span class="string">"style-loader"</span>,</span><br><span class="line">                use:[&#123;</span><br><span class="line">                    loader:<span class="string">"css-loader"</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    loader:<span class="string">"less-loader"</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置sass"><a href="#配置sass" class="headerlink" title="配置sass"></a>配置sass</h3><p>Sass 的打包和分离和 less 的类似，首先下载安装 Sass 所支持的服务与 loader。<br>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev node-sass sass-loader</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中配置 Loader:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">    rules:[</span><br><span class="line">        &#123;</span><br><span class="line">            test:<span class="regexp">/\.less$/</span>,</span><br><span class="line">            use:ExtractTextPlugin.extract(&#123;</span><br><span class="line">                fallback:<span class="string">"style-loader"</span>,</span><br><span class="line">                use:[&#123;</span><br><span class="line">                    loader:<span class="string">"css-loader"</span></span><br><span class="line">                &#125;,&#123;</span><br><span class="line">                    loader:<span class="string">"sass-loader"</span></span><br><span class="line">                &#125;]</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PostCSS-in-webpack"><a href="#PostCSS-in-webpack" class="headerlink" title="PostCSS-in-webpack"></a>PostCSS-in-webpack</h3><p>CSS3 是目前作为一个前端必须要掌握的技能，但是由于现在好多浏览器还是不兼容 CSS3，所以前端需要多写很丑很难看的前缀代码；以前都是边查 Can I Use ，边添加，这样很麻烦，现在配置一个插件 postcss就可以搞定；</p><p>PostCSS 是一个 CSS 的处理平台，它可以帮助你的 CSS 实现更多的功能，但是今天我们就通过其中的一个加前缀的功能，初步了解一下 PostCSS 。</p><p>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev postcss-loader autoprefixer</span><br></pre></td></tr></table></figure><p>在根目录下，建立一个 postcss.config.js 文件：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    plugins:[</span><br><span class="line">        <span class="built_in">require</span>(<span class="string">'autoprefixer'</span>)</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是对 postCSS 一个简单的配置，引入了 autoprefixer 插件。让 postCSS 拥有添加前缀的能力，它会根据 can i use 来增加相应的css3属性前缀。</p><p>在 webpack.config.js 中配置 Loader:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">    use: extractTextPlugin.extract(&#123;</span><br><span class="line">        fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">        use: [</span><br><span class="line">            &#123; <span class="attr">loader</span>: <span class="string">'css-loader'</span>, </span><br><span class="line">                options: &#123; <span class="attr">importLoaders</span>: <span class="number">1</span> &#125; </span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'postcss-loader'</span></span><br><span class="line">        ]</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-6-Tree-shaking"><a href="#3-6-Tree-shaking" class="headerlink" title="3.6 Tree-shaking"></a>3.6 Tree-shaking</h2><p>Tree-shaking 字面意思就是摇晃树， 其实就是去除那些引用的但却没有使用的代码。<br>Tree-shaking 概念最早由 Rollup.js 提出，后来在 webpack2 中被引入进来，但是这个这一特性能够被支持得益于 ES6 modules 的静态特性。ES6的模块声明相比于传统 CommonJS 的同步 require 有着本质区别。这种 modules 设计保证了依赖关系是提前确定的，使得静态分析成为了可能，与运行时无关。<br>并且 webpack 中并没有直接对 tree-shaking 的配置，需要借助 uglifyjs-webpack-plugin。</p><p>webpack 中 tree-shaking主要分为两个方面:</p><ul><li>JS tree shaking： JS 文件中定义的多个方法或者变量没有全部使用。</li><li>CSS tree shaking： 样式通过 css 选择器没有匹配到相应的 DOM 节点。</li></ul><h3 id="JS-Tree-shaking"><a href="#JS-Tree-shaking" class="headerlink" title="JS Tree-shaking"></a>JS Tree-shaking</h3><p>将文件标记为无副作用( side-effect-free )<br>在一个纯粹的 ESM 模块世界中，识别出哪些文件有副作用很简单。然而，我们的项目无法达到这种纯度，所以，此时有必要向 webpack 的 compiler 提供提示哪些代码是“纯粹部分”。</p><p>这种方式是通过 package.json 的 “sideEffects” 属性来实现的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">  <span class="string">"sideEffects"</span>: <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如同上面提到的，如果所有代码都不包含副作用，我们就可以简单地将该属性标记为 false，来告知 webpack，它可以安全地删除未用到的 export 导出。</p><blockquote><p>「副作用」的定义是，在导入时会执行特殊行为的代码，而不是仅仅暴露一个 export 或多个 export 。举例说明，例如 polyfill ，它影响全局作用域，并且通常不提供 export 。</p></blockquote><p>如果你的代码确实有一些副作用，那么可以改为提供一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"your-project"</span>,</span><br><span class="line">  <span class="string">"sideEffects"</span>: [</span><br><span class="line">    <span class="string">"./src/some-side-effectful-file.js"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩输出<br>通过如上方式，我们已经可以通过 import 和 export 语法，找出那些需要删除的“未使用代码(dead code)”，然而，我们不只是要找出，还需要在 bundle 中删除它们。为此，我们将使用 -p(production) 这个 webpack 编译标记，来启用 uglifyjs 压缩插件。</p><blockquote><p>注意，–optimize-minimize 标记也会在 webpack 内部调用 UglifyJsPlugin。<br>从 webpack 4 开始，也可以通过 “mode” 配置选项轻松切换到压缩输出，只需设置为 “production”。</p></blockquote><p>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./src/index.js'</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'bundle.js'</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'dist'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  mode: <span class="string">"production"</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>为了学会使用 tree shaking，你必须……</p><ul><li>使用 ES2015 模块语法（即 import 和 export）。</li><li>在项目 package.json 文件中，添加一个 “sideEffects” 入口。</li><li>引入一个能够删除未引用代码( dead code )的压缩工具( minifier )（例如 UglifyJSPlugin ）。</li></ul><h3 id="CSS-Tree-shaking"><a href="#CSS-Tree-shaking" class="headerlink" title="CSS Tree-shaking"></a>CSS Tree-shaking</h3><p>像 Bootstrap 这样的框架往往会带有很多 CSS。在项目中通常我们只使用它的一小部分。就算我们自己写CSS，随着项目的进展，CSS 也会越来越多，有时候需求更改，带来了 DOM 结构的更改，这时候我们可能无暇关注 CSS 样式，造成很多 CSS 的冗余。</p><p>PurifyCSS<br>使用 PurifyCSS 可以大大减少 CSS 冗余，比如我们经常使用的 BootStrap (140KB)就可以减少到只有 35KB 大小。这在实际开发当中是非常有用的。</p><p>安装 PurifyCSS-webpack<br>从名字你就可以看出这是一个插件，而不是 loader。所以这个需要安装还需要引入。 PurifyCSS-webpack 要以来于 purify-css 这个包，所以这两个都需要安装。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm i –save-dev purifycss-webpack purify-css</span><br></pre></td></tr></table></figure><p>引入 glob<br>因为我们需要同步检查html模板，所以我们需要引入 node 的 glob 对象使用。在 webpack.config.js 文件头部引入 glob。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> glob = <span class="built_in">require</span>(<span class="string">'glob'</span>);</span><br></pre></td></tr></table></figure><p>引入 purifycss-webpack<br>同样在 webpack.config.js 文件头部引入 purifycss-webpack</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> PurifyCSSPlugin = <span class="built_in">require</span>(<span class="string">"purifycss-webpack"</span>);</span><br></pre></td></tr></table></figure><p>配置 plugins<br>引入完成后我们需要在 webpack.config.js 里配置 plugins 。代码如下，重点看标黄部分。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">plugins:[</span><br><span class="line">    <span class="comment">//new uglify() </span></span><br><span class="line">    <span class="keyword">new</span> htmlPlugin(&#123;</span><br><span class="line">        minify:&#123;</span><br><span class="line">            removeAttrubuteQuotes:<span class="literal">true</span></span><br><span class="line">        &#125;,</span><br><span class="line">        hash:<span class="literal">true</span>,</span><br><span class="line">        template:<span class="string">'./src/index.html'</span></span><br><span class="line">        </span><br><span class="line">    &#125;),</span><br><span class="line">    <span class="keyword">new</span> extractTextPlugin(<span class="string">"css/index.css"</span>),</span><br><span class="line">    <span class="keyword">new</span> PurifyCSSPlugin(&#123;</span><br><span class="line">        <span class="comment">// Give paths to parse for rules. These should be absolute!</span></span><br><span class="line">        paths: glob.sync(path.join(__dirname, <span class="string">'src/*.html'</span>)),</span><br><span class="line">        &#125;)</span><br><span class="line"> </span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里配置了一个 paths ，主要是需找 html 模板，purifycss 根据这个配置会遍历你的文件，查找哪些css 被使用了。</p><p>配置好上边的代码，我们可以故意在 css 文件里写一些用不到的属性，然后用 webpack 打包，你会发现没用的 CSS 已经自动给你删除掉了。在工作中记得一定要配置这个 plugins ，因为这决定你代码的质量，非常有用。</p><h2 id="3-7-文件处理"><a href="#3-7-文件处理" class="headerlink" title="3.7 文件处理"></a>3.7 文件处理</h2><h3 id="图片处理"><a href="#图片处理" class="headerlink" title="图片处理"></a>图片处理</h3><p>在 index.html 文件中增加一个放置 div 的标签</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"tupian"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>编写 css 文件，把图片作为背景显示。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#tupian&#123;</span><br><span class="line">   background-image: url(../images/manhua.png);</span><br><span class="line">   width:<span class="number">466</span>px;</span><br><span class="line">   height:<span class="number">453</span>px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>安装 file-loader 和 url-loader</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev file-loader url-loader</span><br></pre></td></tr></table></figure><p>file-loader ：解决引用路径的问题，拿 background 样式用 url 引入背景图来说，我们都知道， webpack 最终会将各个模块打包成一个文件，因此我们样式中的 url 路径是相对入口 html 页面的，而不是相对于原始 css 文件所在的路径的。这就会导致图片引入失败。这个问题是用 file-loader 解决的，file-loader 可以解析项目中的 url 引入（不仅限于 css），根据我们的配置，将图片拷贝到相应的路径，再根据我们的配置，修改打包后文件引用路径，使之指向正确的文件。<br>url-loader：如果图片较多，会发很多 http 请求，会降低页面性能。这个问题可以通过 url-loader 解决。url-loader 会将引入的图片编码，生成 dataURl 。相当于把图片数据翻译成一串字符。再把这串字符打包到文件中，最终只需要引入这个文件就能访问图片了。当然，如果图片较大，编码会消耗性能。因此url-loader 提供了一个 limit 参数，小于 limit 字节的文件会被转为 DataURl ，大于 limit 的还会使用 file-loader 进行 copy。</p><p>配置 url-loader<br>我们安装好后，就可以使用这个 loader 了，记得在 loader 使用时不需要用 require 引入，在plugins 才需要使用 require 引入。</p><p>webpack.config.js文件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模块：例如解读 CSS,图片如何转换，压缩</span></span><br><span class="line">    <span class="built_in">module</span>:&#123;</span><br><span class="line">        rules: [</span><br><span class="line">            &#123;</span><br><span class="line">              test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">              use: [ <span class="string">'style-loader'</span>, <span class="string">'css-loader'</span> ]</span><br><span class="line">            &#125;,&#123;</span><br><span class="line">               test:<span class="regexp">/\.(png|jpg|gif)/</span> ,</span><br><span class="line">               use:[&#123;</span><br><span class="line">                   loader:<span class="string">'url-loader'</span>,</span><br><span class="line">                   options:&#123;</span><br><span class="line">                       limit:<span class="number">500000</span></span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;]</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><ul><li>test： /.(png|jpg|gif)/ 是匹配图片文件后缀名称。</li><li>use：是指定使用的 loader 和 loader 的配置参数。</li><li>limit：是把小于 500000B 的文件打成 Base64 的格式，写入JS 。</li><li>写好后就可以使用 webpack 进行打包了，这回你会发现打包很顺利的完成了。具体的 Base64 的格式，你可以查看视频中的样子。</li></ul><h4 id="为什么只使用了url-loader"><a href="#为什么只使用了url-loader" class="headerlink" title="为什么只使用了url-loader"></a>为什么只使用了url-loader</h4><p>有的小伙伴会发现我们并没有在 webpack.config.js 中使用 file-loader ，但是依然打包成功了。我们需要了解 file-loader 和 url-loader 的关系。url-loader 和 file-loader 是什么关系呢？简答地说，url-loader 封装了 file-loader 。 url-loader 不依赖于 file-loader ，即使用 url-loader 时，只需要安装 url-loader 即可，不需要安装 file-loader ，因为 url-loader内置了 file-loader 。通过上面的介绍，我们可以看到，url-loader 工作分两种情况：</p><ul><li><p>1.文件大小小于 limit 参数， url-loader 将会把文件转为 DataURL（ Base64格式 ）；</p></li><li><p>2.文件大小大于 limit ， url-loader 会调用 file-loader 进行处理，参数也会直接传给 file-loader。</p></li></ul><p>也就是说，其实我们只安装一个 url-loader 就可以了。但是为了以后的操作方便，我们这里就顺便安装上 file-loader。</p><h4 id="如何把图片放到指定的文件夹下"><a href="#如何把图片放到指定的文件夹下" class="headerlink" title="如何把图片放到指定的文件夹下"></a>如何把图片放到指定的文件夹下</h4><p>前边两节课程，打包后的图片并没有放到images文件夹下，要放到 images 文件夹下，其实只需要配置我们的 url-loader 选项就可以了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>:&#123;</span><br><span class="line">     rules: [</span><br><span class="line">         &#123;</span><br><span class="line">           test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">           use: extractTextPlugin.extract(&#123;</span><br><span class="line">             fallback: <span class="string">"style-loader"</span>,</span><br><span class="line">             use: <span class="string">"css-loader"</span></span><br><span class="line">           &#125;)</span><br><span class="line">         &#125;,&#123;</span><br><span class="line">            test:<span class="regexp">/\.(png|jpg|gif)/</span> ,</span><br><span class="line">            use:[&#123;</span><br><span class="line">                loader:<span class="string">'url-loader'</span>,</span><br><span class="line">                options:&#123;</span><br><span class="line">                    limit:<span class="number">5000</span>,</span><br><span class="line">                    outputPath:<span class="string">'images/'</span>,</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;]</span><br><span class="line">         &#125;</span><br><span class="line">       ]</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure><h3 id="CSS-分离时图片路径处理"><a href="#CSS-分离时图片路径处理" class="headerlink" title="CSS 分离时图片路径处理"></a>CSS 分离时图片路径处理</h3><p>在处理 css 时我们已经学会如何使用 extract-text-webpack-plugin 插件提取 css，利用 extract-text-webpack-plugin 插件很轻松的就把 CSS 文件分离了出来，但是 CSS 路径并不正确，很多小伙伴就在这里搞个几天还是没有头绪，网上也给出了很多的解决方案，我觉的最好的解决方案是使用 publicPath 解决，我也一直在用。</p><p>publicPath：是在 webpack.config.js 文件的 output 选项中，主要作用就是处理静态文件路径的。</p><p>在处理前，我们在 webpack.config.js 上方声明一个对象，叫 website。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> website =&#123;</span><br><span class="line">    publicPath:<span class="string">"http://192.168.1.108:1717/"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，这里的 IP 和端口，是你本机的 ip 或者是你 devServer 配置的 IP 和端口。<br>然后在 output 选项中引用这个对象的 publicPath 属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出口文件的配置项</span></span><br><span class="line">    output:&#123;</span><br><span class="line">        <span class="comment">//输出的路径，用了Node语法</span></span><br><span class="line">        path:path.resolve(__dirname,<span class="string">'dist'</span>),</span><br><span class="line">        <span class="comment">//输出的文件名称</span></span><br><span class="line">        filename:<span class="string">'[name].js'</span>,</span><br><span class="line">        publicPath:website.publicPath</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>配置完成后，你再使用 webpack 命令进行打包，你会发现原来的相对路径改为了绝对路径，这样来讲速度更快。</p><h3 id="处理字体文件"><a href="#处理字体文件" class="headerlink" title="处理字体文件"></a>处理字体文件</h3><h4 id="将字体图标和-css-打包到同一个文件中"><a href="#将字体图标和-css-打包到同一个文件中" class="headerlink" title="将字体图标和 css 打包到同一个文件中"></a>将字体图标和 css 打包到同一个文件中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test:<span class="regexp">/\.(png|woff|woff2|svg|ttf|eot)$/</span>,</span><br><span class="line">   use:&#123;</span><br><span class="line">        loader:<span class="string">'url-loader'</span>,</span><br><span class="line">        options: &#123;</span><br><span class="line">            limit: <span class="number">100000</span>,  <span class="comment">//这里要足够大这样所有的字体图标都会打包到css中</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上文中的 limit 一定要保证大于最大字体文件的大小，因为这个参数是告诉 url-loader，如果文件小于这个参数，那么就以 Data Url 的方式直接构建到文件中。使用这种方式最方便，不用打包后路径的问题，但是缺点就是构建出来的文件特别大，如果线上不要使用这种方式打包。 </p><h4 id="将字体图标独放打包到一个文件夹中"><a href="#将字体图标独放打包到一个文件夹中" class="headerlink" title="将字体图标独放打包到一个文件夹中"></a>将字体图标独放打包到一个文件夹中</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   test: <span class="regexp">/\.(woff|woff2|svg|ttf|eot)$/</span>,</span><br><span class="line">   use:[</span><br><span class="line">        &#123;</span><br><span class="line">        loader:<span class="string">'file-loader'</span>,</span><br><span class="line">        options:&#123;<span class="attr">name</span>:<span class="string">'fonts/[name].[hash:8].[ext]'</span>&#125;&#125;</span><br><span class="line">        <span class="comment">//项目设置打包到dist下的fonts文件夹下</span></span><br><span class="line">     ]</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>打包中会遇到的问题就是路径不对，可以通过配置 publicPath 解决。</p><h3 id="Json-配置文件使用"><a href="#Json-配置文件使用" class="headerlink" title="Json 配置文件使用"></a>Json 配置文件使用</h3><p>在实际工作中，我们的项目都会配置一个 Json 的文件或者说 API 文件，作为项目的配置文件。有时候你也会从后台读取到一个 json 的文件，这节课就学习如何在 webpack 环境中使用 Json。如果你会 webpack1 或者 webpack2 版本中，你是需要加载一个 json-loader 的 loader 进来的，但是在webpack3.x 版本中，你不再需要另外引入了。</p><p>读出 Json 内容<br>第一步：现在我们的 index.html 模板中加入一个层，并给层一个 Id，为了是在 javascript 代码中可以方便引用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;div id=<span class="string">"json"</span>&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>第二步：到 src 文件夹下，找到入口文件，我这里是 entry.js 文件。修改里边的代码，如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> json =<span class="built_in">require</span>(<span class="string">'../config.json'</span>);</span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">"json"</span>).innerHTML= json.name;</span><br></pre></td></tr></table></figure><p>这两行代码非常简单，第一行是引入我们的 json 文件，第二行驶写入到到 DOM 中。</p><h2 id="3-8-html-in-webpack"><a href="#3-8-html-in-webpack" class="headerlink" title="3.8 html in webpack"></a>3.8 html in webpack</h2><h3 id="生成html"><a href="#生成html" class="headerlink" title="生成html"></a>生成html</h3><p>html-webpack-plugin 可以根据你设置的模板，在每次运行后生成对应的模板文件，同时所依赖的 CSS/JS 也都会被引入，如果 CSS/JS 中含有 hash 值，则 html-webpack-plugin 生成的模板文件也会引入正确版本的 CSS/JS 文件。</p><p>安装</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure><p>引入</p><p>在webpack.config.js中引入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> HtmlWebpackPlugin = <span class="built_in">require</span>(<span class="string">'html-webpack-plugin'</span>);</span><br></pre></td></tr></table></figure><p>配置</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    entry: <span class="string">'./app/index.js'</span>,</span><br><span class="line">    output: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">module</span>: &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;,</span><br><span class="line">    plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebpackPlugin(&#123;</span><br><span class="line">            title: <span class="string">"This is the result"</span>,</span><br><span class="line">            filename: <span class="string">"./index.html"</span>,</span><br><span class="line">            template: <span class="string">"./app/index.html"</span>,</span><br><span class="line">            inject: <span class="string">"body"</span>,</span><br><span class="line">            favicon: <span class="string">""</span>,</span><br><span class="line">            minify: &#123;</span><br><span class="line">                caseSensitive: <span class="literal">false</span>,</span><br><span class="line">                collapseBooleanAttributes: <span class="literal">true</span>,</span><br><span class="line">                collapseWhitespace: <span class="literal">true</span></span><br><span class="line">            &#125;,</span><br><span class="line">            hash: <span class="literal">true</span>,</span><br><span class="line">            cache: <span class="literal">true</span>,</span><br><span class="line">            chunks: <span class="string">""</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后看一下这些参数的意义：</p><ul><li>title: 生成的HTML模板的 title，如果模板中有设置 title 的名字，则会忽略这里的设置</li><li>filename: 生成的模板文件的名字</li><li>template: 模板来源文件</li><li>inject: 引入模块的注入位置；取值有 true/false/body/head</li><li>favicon: 指定页面图标；</li><li>minify: 是 html-webpack-plugin 中集成的 html-minifier ，生成模板文件压缩配置</li><li>caseSensitive: false, //是否大小写敏感</li><li>collapseBooleanAttributes: true, //是否简写 boolean 格式的属性如：disabled=”disabled” 简写为 disabled </li><li>collapseWhitespace: true //是否去除空格</li><li>hash: 是否生成hash添加在引入文件地址的末尾，类似于我们常用的时间戳</li><li>cache: 是否需要缓存，如果填写 true，则文件只有在改变时才会重新生成</li><li>chunks: 引入的模块，这里指定的是 entry 中设置多个 js 时，在这里指定引入的 js，如果不设置则默认全部引入</li></ul><h3 id="html中引入图片"><a href="#html中引入图片" class="headerlink" title="html中引入图片"></a>html中引入图片</h3><p>html-withimg-loader<br>html-withimg-loader 就是我们今天的重点了，这个插件并不是很火，也是我个人喜欢的一个小loader 。解决的问题就是在hmtl文件中引入 <img> 标签的问题。</p><p>安装：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-withimg-loader --save</span><br></pre></td></tr></table></figure><p>配置 loader<br>webpack.config.js</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.(htm|html)$/i</span>,</span><br><span class="line">     use:[ <span class="string">'html-withimg-loader'</span>] </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在终端中可以进行打包了。你会发现 images 被很好的打包了。并且路径也完全正确。</p><h1 id="webpack-环境配置"><a href="#webpack-环境配置" class="headerlink" title="webpack 环境配置"></a>webpack 环境配置</h1><h2 id="搭建开发环境"><a href="#搭建开发环境" class="headerlink" title="搭建开发环境"></a>搭建开发环境</h2><p>在使用 webpack-cli 进行打包时，通过命令 webpack –watch 即可开启 watch 模式，进入 watch 模式之后，一旦依赖树中的某一个模块发生了变化，webpack 就会重新进行编译。</p><h3 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h3><p>在 webpack 中打包生成的文件会覆盖之前的文件，不过生成文件的时候文件名加了 hash 之后会每次都生成不一样的文件，这就会很麻烦，不但会生成很多冗余的文件，还很难搞清楚到底是哪个文件，这就需要引入该插件 </p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install –save-dev clean-webpack-plugin</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//webpack.config.js</span></span><br><span class="line"><span class="comment">//引入clean-webpack-plugin</span></span><br><span class="line"><span class="keyword">const</span> CleanWebpackPlugin = <span class="built_in">require</span>(<span class="string">'clean-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//plugin 插入你想删除的路径，注意在生成出来文件之前，他会删除 public 的文件夹，而不是根据生成的文件来删除对应的文件。</span></span><br><span class="line"><span class="keyword">new</span> CleanWebpackPlugin([<span class="string">'public'</span>]);</span><br></pre></td></tr></table></figure><h3 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack dev server"></a>webpack dev server</h3><p>webpack-dev-server 简介：</p><ul><li>是一个小型 node.js express 服务器</li><li>新建一个开发服务器，可以 serve 我们 pack 以后的代码，并且当代码更新的时候自动刷新浏览器</li><li>启动 webpack-dev-server 后，你在目标文件夹中是看不到编译后的文件的，实时编译后的文件都保存到了内存当中。<br>两种自动刷新方式：</li><li>iframe mode<br>在网页中嵌入了一个 iframe ，将我们自己的应用注入到这个 iframe 当中去，因此每次你修改的文件后，都是这个 iframe 进行了 reload<br>命令行：webpack-dev-server，无需 –inline<br>浏览器访问：<a href="http://localhost:8080/webpack-dev-server/index.html" target="_blank" rel="noopener">http://localhost:8080/webpack-dev-server/index.html</a></li><li>inline mode<br>命令行：webpack-dev-server –inline<br>浏览器访问：<a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a></li></ul><p>安装 webpack-dev-server</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-dev-server --save-dev</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中添加配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var webpack=require(&apos;webpack&apos;);</span><br><span class="line">module.exports = &#123;</span><br><span class="line">……</span><br><span class="line">devServer: &#123;</span><br><span class="line">    historyApiFallback: true,</span><br><span class="line">    inline: true,//注意：不写hot: true，否则浏览器无法自动更新；也不要写  colors:true，progress:true等，webpack2.x已不支持这些</span><br><span class="line">&#125;,</span><br><span class="line">plugins:[</span><br><span class="line">    ……</span><br><span class="line">    new webpack.HotModuleReplacementPlugin()</span><br><span class="line"> ]</span><br><span class="line">    ……</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在 package.json 里配置运行的命令</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: </span><br><span class="line">&#123; </span><br><span class="line">　　<span class="string">"start"</span>: <span class="string">"webpack-dev-server --inline"</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2 id="代理远程接口"><a href="#代理远程接口" class="headerlink" title="代理远程接口"></a>代理远程接口</h2><p>如果你有单独的后端开发服务器 API，并且希望在同域名下发送 API 请求 ，那么代理某些 URL 会很有用。<br>webpack-dev-server 使用了非常强大的 http-proxy-middleware 包。</p><p>配置如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">proxy: &#123;</span><br><span class="line">    <span class="string">'/apis'</span>: &#123;</span><br><span class="line">        target: <span class="string">''</span>, <span class="comment">//要代理到的地址</span></span><br><span class="line">        secure: <span class="literal">false</span>, <span class="comment">//若地址为https，需要设置为false</span></span><br><span class="line">        onProxyReq: <span class="function"><span class="keyword">function</span>(<span class="params">proxyReq, req, res</span>) </span>&#123; <span class="comment">//提前设置一些代理的头部，如token信息等</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">//...其他配置请自行查阅文档http-proxy-middleware文档</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模块热更新"><a href="#模块热更新" class="headerlink" title="模块热更新"></a>模块热更新</h2><p>DevServer 还支持一 种叫做模块热替换( Hot Module Replacement )的技术可在不刷新整个网页的情况下 做到超 灵敏实时预览。原理是在一个源码发生变化时，只需重新编译发生变化的模块，再用新输 出 的模块替换掉浏览器中对应的老模块 。</p><p>模块热替换技术的优势如下：</p><ul><li>实时预览反应更快，等待时间更短。</li><li>不刷新浏览器时能保留当前网页的运行状态，例如在使用 Redux 管理数据的应用中搭配模块热替换能做到在代码更新时 Redux 中的数据保持不变。</li></ul><p>总的来说，模块热替换技术在很大程度上提升了开发效率和体验 。</p><p>DevServer 默认不会开启模块热替换模式，要开启该模式，则只 需在启动时带上参数 –hot ，完整的命令是 webpack-dev-server –hot。</p><p>除了通过在启动时带上 –hot 参数，还可以通过接入 Plugin 实现，相关代码如下 :</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">canst HotModuleReplacementPlugin = <span class="built_in">require</span> (’ webpack/lib/HotModuleReplacementPlugin ’);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123; </span><br><span class="line">entry:&#123;</span><br><span class="line"><span class="comment">//为每个入口都注入代理客户端</span></span><br><span class="line">main: [’ webpack-dev-server/client?http:<span class="comment">//localhost:8080 /’, ’webpack/hot/dev-server ’,’. / src/main.j s ’],</span></span><br><span class="line">&#125;,</span><br><span class="line"> plugIns : [</span><br><span class="line"><span class="comment">//该插件的作用就是实现模块热替换，实际上若启动时带上 、 --hot 、参数，就会注入该插件，生 成 .hot-update.json 文件。</span></span><br><span class="line"><span class="keyword">new</span> HotModuleReplacementPlugin() ,</span><br><span class="line">],</span><br><span class="line">devServer : &#123;</span><br><span class="line"><span class="comment">//告诉 DevServer 要开启 模块热替换模式 </span></span><br><span class="line">hot: <span class="literal">true</span> ,</span><br><span class="line">&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>借助于 style-loader 的帮助，CSS 的模块热替换实际上是相当简单的。当更新 CSS 依赖模块时，此 loader 在后台使用 module.hot.accept 来修补(patch) <code>&lt;style&gt;</code>标签。</p><p>但当修改 js 文件时，我们会发现模块热替换没有生效，而是整个页面被刷新了，为了让使用者在使用模块热替换功能时能灵活地控制老模块被替换时的逻辑，webpack 允许在源码中定义一些代码去做相应的处理。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有当开启了模块热替换时 module.hot 才存在 </span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept([<span class="string">'.IAppComponent'</span>],()=&gt;&#123;</span><br><span class="line"><span class="comment">//在新的 AppComponent 加载成功后重新执行组建渲染逻辑 render(&lt;AppComponentl&gt;, window.document.getElementByid ('app'));</span></span><br><span class="line">&#125;) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中的 module.hot 是当开启模块热替换后注入全局的 API，用于控制模块热替换的逻辑 。<br>当子模块发生更新时，更新事件会一层层地向上传递，也就是从 AppComponent.js 文件传递到 main.js 文件，直到有某层的文件接收了当前变化的模块，即 main.js 文 件中定义的 module.hot.accept([‘.IAppComponent’], callback)，这时就会调用 callback 函数去执行自定义逻辑。 如果事件一直往上抛，到最外层都没有文件接收它，则会直接刷新网页。</p><h2 id="开启调试-SourceMap"><a href="#开启调试-SourceMap" class="headerlink" title="开启调试 SourceMap"></a>开启调试 SourceMap</h2><p>作为一个程序员每天的大部分工作就是调试自己写的程序，那我们使用了webpack后，所以代码都打包到了一起，给调试带来了麻烦，但是 webpack 已经为我们充分考虑好了这点，它支持生产 Source Maps 来方便我们的调试。<br>在使用 webpack 时只要通过简单的 devtool 配置，webapck 就会自动给我们生产 source maps 文件，map 文件是一种对应编译文件和源文件的方法，让我们调试起来更简单。</p><p>在配置 devtool 时，webpack 给我们提供了四种选项：</p><ul><li>source-map: 在一个单独文件中产生一个完整且功能完全的文件。这个文件具有最好的 source map ，但是它会减慢打包速度；</li><li>cheap-module-source-map: 在一个单独的文件中产生一个不带列映射的map ，不带列映射提高了打包速度，但是也使得浏览器开发者工具只能对应到具体的行，不能对应到具体的列（符号），会对调试造成不便。</li><li>eval-source-map: 使用 eval 打包源文件模块，在同一个文件中生产干净的完整版的 sourcemap ，但是对打包后输出的JS文件的执行具有性能和安全的隐患。在开发阶段这是一个非常好的选项，在生产阶段则一定要不开启这个选项。</li><li>cheap-module-eval-source-map: 这是在打包文件时最快的生产 source map 的方法，生产的 Source map 会和打包后的 JavaScript 文件同行显示，没有影射列，和 eval-source-map 选项具有相似的缺点。<br>四种打包模式，有上到下打包速度越来越快，不过同时也具有越来越多的负面作用，较快的打包速度的后果就是对执行和调试有一定的影响。</li></ul><p>个人意见是，如果大型项目可以使用 source-map，如果是中小型项目使用 eval-source-map 就完全可以应对，需要强调说明的是，source map 只适用于开发阶段，上线前记得修改这些调试设置。</p><p>简单的配置：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  devtool: <span class="string">'eval-source-map'</span>,</span><br><span class="line">  entry:  __dirname + <span class="string">"/app/main.js"</span>,</span><br><span class="line">  output: &#123;</span><br><span class="line">    path: __dirname + <span class="string">"/public"</span>,</span><br><span class="line">    filename: <span class="string">"bundle.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设置-ESLint-检查代码格式"><a href="#设置-ESLint-检查代码格式" class="headerlink" title="设置 ESLint 检查代码格式"></a>设置 ESLint 检查代码格式</h2><p>首先，要使 webpack 支持 eslint，就要要安装 eslint-loader ，命令如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint-loader</span><br></pre></td></tr></table></figure><p>在 webpack.config.js 中添加如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    test: <span class="regexp">/\.js$/</span>,</span><br><span class="line">    loader: <span class="string">'eslint-loader'</span>,</span><br><span class="line">    enforce: <span class="string">"pre"</span>,</span><br><span class="line">    include: [path.resolve(__dirname, <span class="string">'src'</span>)], <span class="comment">// 指定检查的目录</span></span><br><span class="line">    options: &#123; <span class="comment">// 这里的配置项参数将会被传递到 eslint 的 CLIEngine </span></span><br><span class="line">        formatter: <span class="built_in">require</span>(<span class="string">'eslint-friendly-formatter'</span>) <span class="comment">// 指定错误报告的格式规范</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注：formatter 默认是 stylish ，如果想用第三方的可以安装该插件，如上方的示例中的 eslint-friendly-formatter 。</p></blockquote><p>其次，要想 webpack 具有 eslint 的能力，就要安装 eslint，命令如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev eslint</span><br></pre></td></tr></table></figure><p>最后，项目想要使用那些 eslin 规则，可以创建一个配置项文件 ‘.eslintrc.js’，代码如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    root: <span class="literal">true</span>, </span><br><span class="line">    parserOptions: &#123;</span><br><span class="line">        sourceType: <span class="string">'module'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    env: &#123;</span><br><span class="line">        browser: <span class="literal">true</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    rules: &#123;</span><br><span class="line">        <span class="string">"indent"</span>: [<span class="string">"error"</span>, <span class="number">2</span>],</span><br><span class="line">        <span class="string">"quotes"</span>: [<span class="string">"error"</span>, <span class="string">"double"</span>],</span><br><span class="line">        <span class="string">"semi"</span>: [<span class="string">"error"</span>, <span class="string">"always"</span>],</span><br><span class="line">        <span class="string">"no-console"</span>: <span class="string">"error"</span>,</span><br><span class="line">        <span class="string">"arrow-parens"</span>: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个简单的 webpack 引入 eslint 已经完成了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>webpack 确实是一个功能强大的模块打包工具，丰富的 loader 和 plugin 使得其功能多而强。学习 webpack 使得我们可以自定义自己的开发环境，无需依赖 create-react-app 和 Vue-Cli 这类脚手架，也可以针对不同的需求对代码进行不同方案的处理。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Webpack 是当下最热门的前端资源模块化管理和打包工具。它可以将许多松散的模块按照依赖和规则打包成符合生产环境部署的前端资源。还可以将按需加载的模块进行代码分隔，等到实际需要的时候再异步加载。通过loader的转换，任何形式的资源都可以视作模块，比如 CommonJs 模块、AMD 模块、ES6 模块、CSS、图片、JSON、Coffeescript、LESS 等。&lt;/p&gt;
    
    </summary>
    
      <category term="matengfei" scheme="http://xgfe.github.io/categories/matengfei/"/>
    
    
      <category term="webpack" scheme="http://xgfe.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>Web 前端安全科普之 XSS</title>
    <link href="http://xgfe.github.io/2018/06/13/wangpeiyu/web-security-XSS/"/>
    <id>http://xgfe.github.io/2018/06/13/wangpeiyu/web-security-XSS/</id>
    <published>2018-06-13T03:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.258Z</updated>
    
    <content type="html"><![CDATA[<p>Web 前端的安全主要有三类：XSS、CSRF、界面操作劫持。</p><p>XSS（Cross Site Scripting），即跨站脚本攻击，是一种代码注入攻击，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中的 Script 代码会被执行，从而达到恶意攻击用户的目的。</p><p>CSRF（Cross Site Request Forgery），即跨站请求伪造，通过伪装来自受信任用户的请求来利用受信任的网站。</p><p>界面劫持操作是一种基于视觉欺骗的Web会话劫持攻击，包括点击劫持、拖放劫持和触屏劫持三种类型。</p><p>在 OWASP TOP 10中，XSS 一直都是名列前茅，有了 XSS 漏洞，就意味着可以注入任意的 JavaScript，被攻击者的任意操作都可以进行模拟，任何隐私信息都可以获取到。基于上述背景，本文将对 XSS 攻击的原理、类型及防御进行介绍。</p><a id="more"></a><h2 id="XSS-原理"><a href="#XSS-原理" class="headerlink" title="XSS 原理"></a>XSS 原理</h2><p>跨站脚本的重点在脚本上，绝大多数的 XSS 会采用一段远程或者第三方域上的脚本资源，这样做的好处是攻击代码容易控制。script 标签可以嵌入第三方资源，这是浏览器允许的，对于嵌入的脚本内容，会与本域的脚本内容一样，在整个脚本上下文环境中存在，那么在这个场景中的各种功能都可以由嵌入的脚本实现，也就是说 JavaScript 能做到什么效果，XSS 的威力就有多大。</p><p>JavaScript 可以用用来获取的 Cookie、改变网页内容、URL 跳转，那么存在 XSS 漏洞的网站，就可以盗取用户 Cookie、黑掉页面、导航到恶意网站，而攻击者需要做的仅仅是向 Web 页面中注入 JavaScript 代码。</p><p>XSS 攻击原理主要包括三个部分：</p><ul><li><p>攻击者对某含有漏洞的服务器发起 XSS 攻击（注入 JS 代码）。</p></li><li><p>诱使受害者打开受到攻击的服务器 URL（邮件、留言等，此步骤可选项）。</p></li><li><p>受害者在 Web 浏览器中打开 URL，恶意脚本执行。</p></li></ul><p>XSS 构造的例子：</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在服务端将用户输入内容直接拼接到返回 HTML 里</span><br><span class="line">res.body = &apos;...&lt;div&gt;&apos; + data.用户输入的内容 + &apos;&lt;/div&gt;...&apos;</span><br><span class="line"></span><br><span class="line">// 攻击者在页面中提交了这样的内容：</span><br><span class="line">&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在服务端将用户输入的内容直接拼接到了页面元素的属性中</span><br><span class="line">res.body = &apos;...&lt;img src=&quot; + data.用户输入的图片地址 + &quot;&gt;...&apos;</span><br><span class="line"></span><br><span class="line">// 攻击者在页面中提交了这样的内容：</span><br><span class="line">&quot; /&gt;&lt;script&gt;alert(123)&lt;/script&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在页面中将通过 AJAX 取得的用户输入的内容填到页面中</span><br><span class="line">div.innerHTML = data.用户输入的内容</span><br><span class="line"></span><br><span class="line">// 不同于直接拼接，innerHTML 中的 script 标签不会被执行，但是攻击者可以这么写：</span><br><span class="line">&lt;img src=&quot;x.png&quot; onload=&quot;alert(123)&quot;&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 目标网站在页面中将通过 AJAX 取得的用户输入的内容填到页面元素的属性中</span><br><span class="line">a.href = data.用户输入的链接</span><br><span class="line"></span><br><span class="line">// 不同于直接拼接，给元素的属性赋值时内容总会被当成字符串，但是攻击者可以这么写，如用户点了链接就会受到攻击：</span><br><span class="line">javascript:alert(123)</span><br></pre></td></tr></table></figure></code></pre><h2 id="XSS-类型"><a href="#XSS-类型" class="headerlink" title="XSS 类型"></a>XSS 类型</h2><p>XSS 有三种类型，分别是反射型 XSS、存储型 XSS、DOM XSS，下面分别对这三种 XSS 进行介绍。</p><h3 id="反射型-XSS"><a href="#反射型-XSS" class="headerlink" title="反射型 XSS"></a>反射型 XSS</h3><p>反射型 XSS 也被称为非持久性 XSS，是最容易出现的一种 XSS 漏洞，指的是发送请求时，XSS 代码出现在 URL 中，作为输入提交到服务端，服务端解析后响应，在响应内容中出现这段 XSS 代码，最后被浏览器解析执行。这个过程就像是一次反射，故称为反射型 XSS。它的数据流向是：浏览器 -&gt; 后端 -&gt; 浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 服务端代码</span><br><span class="line">&lt;?php</span><br><span class="line">    echo $_GET[&apos;x&apos;];</span><br><span class="line">?&gt;</span><br><span class="line"></span><br><span class="line">// 在浏览器地址栏中输入</span><br><span class="line">http://xssdemo.wpy.com/domxss.html#alert(1)</span><br></pre></td></tr></table></figure><p><img src="http://vfile.meituan.net/xgfe/a7271f75b155dbab2e0c3fb758cbe111100565.png" alt="反射型XSS"></p><h3 id="存储型-XSS"><a href="#存储型-XSS" class="headerlink" title="存储型 XSS"></a>存储型 XSS</h3><p>存储型 XSS 又被称为永久性 XSS，是最危险的一种跨站脚本，指的是发送请求时，提交的 XSS 代码会存储在服务端（不管是数据库、内存还是文件系统），下次请求目标页面时不用再提交 XSS 代码，存储型 XSS 的攻击是最隐蔽的，其危害性也更大。与反射型 XSS 和 DOM XSS 相比，存储型 XSS 的执行不需要手动触发。最典型的例子是留言板 XSS，用户提交一条包含 XSS 代码的留言存储到数据库，目标用户查看留言板时，那些留言的内容就会从数据库查询出来并显示，浏览器发现有 XSS 代码，就当做正常的 HTML 与 JS 解析执行，于是就触发了 XSS 攻击。它的数据流向是：浏览器 -&gt; 后端 -&gt; 数据库 -&gt; 后端 -&gt; 浏览器。</p><h3 id="DOM-XSS"><a href="#DOM-XSS" class="headerlink" title="DOM XSS"></a>DOM XSS</h3><p>DOM XSS 指的是 XSS 代码并不需要服务器解析响应的直接参与，触发 XSS 靠的就是浏览器端的 DOM 解析，可以认为完全是客户端的事情。它的数据流向是：URL-&gt;浏览器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 客户端的脚本</span><br><span class="line">&lt;script&gt;eval(location.hash.substr(1));&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">// 用户点击这个 URL# 后的内容不会发送到服务端，仅在客户端被接收并解释执行。</span><br><span class="line">http://xssdemo.wpy.com/domxss.html#alert(1)</span><br></pre></td></tr></table></figure><p><img src="http://vfile.meituan.net/xgfe/919bcf853c27bbd16656cfa83b8b6ef887889.png" alt="DOM XSS"></p><h4 id="DOM-XSS-场景一：在前端实现页面跳转"><a href="#DOM-XSS-场景一：在前端实现页面跳转" class="headerlink" title="DOM XSS 场景一：在前端实现页面跳转"></a>DOM XSS 场景一：在前端实现页面跳转</h4><p>在前端实现页面跳转，前端通常会通过 JavaScript 实现跳转，最常用到的方法有: location.href / location.replace() / location.assign()。 在该场景下，可以通过伪协议“javascript:”、“data:”在浏览器下执行脚本。但是这种通过伪协议进行攻击已经随着前端工程处理对相关跳转代码逻辑做了很好的完善，基本上不会再出现上述的这种情况。但是如下两种情况却为 Web 攻击打开了天窗：</p><ul><li><p>使用 indexOf 判断 URL 参数是否合法，indexOf() 方法可返回某个指定的字符串值在字符串中首次出现的位置。该方法将从头到尾地检索字符串 stringObject，看它是否含有子串 searchvalue。所以如果 URL 中包含了伪代码及攻击代码，就会被攻击。</p></li><li><p>正则表达式判断 URL 是否合法，为了避免使用 indexOf 判断 URL 带来的缺陷，有些开发人员会想到用正则表达式，但忘了一个神奇的符号“^”，加上和不加上，过滤的效果具有天壤之别，如果没有加“^”，攻击者仍然可以绕过正则的过滤，在URL中植入伪代码和攻击代码。</p></li><li><p>修复方案：在前端实现页面跳转业务场景下，正确的过滤实现方法是，严格限制跳转范围。一方面要限制能够跳转页面的协议：只能是 http、https 或是其他指可控协议；另一方面，要严格限制跳转的范围，如果业务只要跳转到指定的几个页面，可以直接从数组中取值判断是否这几个页面，如果跳转范围稍大，正确使用正则表达式将跳转URL严格限制到可控范围内。 </p></li></ul><h4 id="DOM-XSS-场景二：取值写入页面或动态执行"><a href="#DOM-XSS-场景二：取值写入页面或动态执行" class="headerlink" title="DOM XSS 场景二：取值写入页面或动态执行"></a>DOM XSS 场景二：取值写入页面或动态执行</h4><p>除接收 URL 参数经后端处理最后在前端展示外，在 Web 前端通过 JavaScript 获取不同来源的参数值，不经后端处理即刻在 Web 页面进行展示或动态执行的业务场景也十分常见，想要在客户端实现接受参数并写入页面或动态执行，就不得不用到 innerHTML、document.write、eval。因为 JavaScript 取值的来源纷繁复杂，如果忘记做转义处理，或过分相信取值来源的数据，直接将分离出的参数值交给 JavaScriptinnerHTML、document.write、eval处理，就有可能招来 DOM-XSS。下面是三种常见的缺陷： </p><ul><li><p>从 URL 中的取参数值写入页面或动态执行，如直接从 URL 的锚参数（即位于#后面的参数）中取值，不经过任何处理直接 innerHTML 写入页面，导致攻击者只需要构造如下URL即可完成一次 DOM XSS 攻击。由于整个攻击过程在客户端侧完成，不需要向服务器发送任何请求数据，所以即便业务接入了对抗反射型 XSS 的 Web 应用防火墙（WAF），这类 DOM XSS 也无法被感知，攻击者便可畅通无阻的利用漏洞对用户开展攻击。 </p></li><li><p>从 Cookie 中的取参数值写入页面或动态执行，原理基本同从 URL 中的取参数值写入页面或动态执行，只是换了一个取值来源而已。</p></li><li><p>从 LocalStorage、Referer、Window name、SessionStorage中的取参数值写入页面或动态执行 ，如取 window.name 的值，最后直接 innerHTML 到页面中。一般情况下，页面的 window.name 攻击者不可控，故往往会被认为来源相对可信。但借助i frame 的 name 属性，攻击者可以将页面的 window.name 设置为攻击代码，仍然可以构造 DOM XSS。</p></li><li><p>修复方案：</p><ul><li><p>写入页面前先转义。在取值写入页面或动态执行的业务场景下，在将各种来源获取到的参数值传入JavaScript“三姐妹”函数（innerHTML、document.write、eval）处理前，对传入数据中的 HTML 特殊字符进行转义处理能防止大部分 DOM-XSS 的产生。此外，根据不同业务的真实情况，还应使用正则表达式，针对传入的数据做更严格的过滤限制，才能保证万无一失。 </p></li><li><p>慎用危险的“eval”。需要强调的是，由于 JavaScript 中的 eval 函数十分灵活，能够支持执行的字符串编码纷繁复杂。强烈建议，不到万不得已，不要使用 eval<br>函数处理不可控的外部数据。 </p></li><li><p>编写安全的函数方法，从看似“可靠”的数据源获取参数值。无论是从 Cookie，还是从LocalStorage、Referer、Window name、SessionStorage 中获取数据，都应使用安全的函数，对传入的数据做过滤后，再传递给相关函数写入页面或执行。 </p></li></ul></li></ul><h2 id="XSS-危害"><a href="#XSS-危害" class="headerlink" title="XSS 危害"></a>XSS 危害</h2><ul><li><p>盗取用户的 Cookie，Cookie 经常被用来存储用户的会话信息，比如用户登录认证后的 session，之后同域内发出的请求都会自动带上认证后的会话信息。如果 Cookie被盗取，攻击者就可以不用通过密码而直接登录用户的账户。Cookie 的重要字段：[name] [value] [domain] [path] [expires] [httponly] [secure]，其含义依次是：名称、值、所属域名、所属相对根路径、过期时间、是否有 HttpOnly 标志、是否有 Secure 标志。如果设置了 HttpOnly 标志，客户端脚本就无法通过document.cookie 获取该 Cookie，这样就能有效地防御 XSS 攻击获取 Cookie。</p></li><li><p>构建 GET 和 POST 请求，如果 Cookie 设置了 HttpOnly 标志，则无法直接劫持 Cookie 来使用了，但是 XSS 可以在 JavaScript 中构建 GET 或者 POST 请求，来实现自己的攻击。只要让用户执行下面这段脚本，就能发起 GET 请求，攻击者通过 XSS 诱导用户来执行。XSS 的攻击过程都是在浏览器通过执行 JavaScript 脚本自动进行，缺少与用户交互的过程。例如在 POST 的请求中，如果需要输入验证码，JS 代码无法解析验证码，攻击也就无法实现。但是针对验证码这种情况，如果 XSS 可以通过把验证码的图片发到远端攻击服务器，服务器解析验证码然后把结果返回给 JS 代码，JS 获取后继续进行攻击，不过就是成本有点高。</p></li><li><p>XSS 钓鱼：上面模拟用户的 POST 请求貌似成本有点高，攻击者可以将 XSS 和钓鱼结合在一起，例如通过 JavaScript 代码模拟出网站的登录框，用户输入用户名和密码后，XSS 将这些信息发送到服务器端，用来进行攻击。</p></li><li><p>获取用户系统信息，此外 XSS 还可以识别用户的浏览器信息、用户安装的软件以及用户真实的 IP 等信息。</p></li><li><p>XSS Worm：这是 XSS 的一种终极利用方式，破坏力和影响力是巨大的，与蠕虫病毒一样具有“传染性”，与系统病毒的唯一区别就是无法对系统底层操作。XSS 蠕虫是针对浏览器的攻击，网站规模越大，攻击效果就越大。一般来说，用户直接发生交互行为的页面，如果存在存储型 XSS，则比较容易发起 Worm 攻击。</p></li></ul><h2 id="XSS-防御"><a href="#XSS-防御" class="headerlink" title="XSS 防御"></a>XSS 防御</h2><ul><li><p>任何由用户输出的数据都是不可信的。</p></li><li><p>不要在奇怪的地方插入不可信的数据。</p><p><img src="http://vfile.meituan.net/xgfe/0a853e1b33a7dfaeb4aa47f12453026b97763.png" alt="不可信数据"></p></li><li><p>进行输入输出检查，将期望被当成字符串的不可信数据转义后再插入文档中，不同位置需要使用不同的转义逻辑。</p><p><img src="http://vfile.meituan.net/xgfe/3df441ed85fa308c54a059924acd16e0248873.png" alt="输入输出检查"></p></li><li><p>将期望被当成 HTML 的不可信数据使用专业的库消毒后再插入文档中。</p></li><li><p>使用 HttpOnly 的 Cookie，给关键的 Cookie 设置 HttpOnly 属性，这样能够避免 JS 读取 Cookie信息，设置后有助于缓解 XSS，但是 XSS 除了劫持 Cookie 之外，还可以模拟用户的身份进行操作。</p></li><li><p>使用内容安全策略（CSP）是对抗 XSS 的深度防御策略，内容安全策略可以以白名单的方式限定哪些地方的内容可以被加载和执行，如果不存在可以通过本地文件放置恶意代码的其他漏洞，则该策略是有效的。</p></li><li><p>使用设计上就会自动编码来解决XSS问题的框架，如：React JS。了解每个框架的 XSS 保护的局限性，并适当地处理未覆盖的用例。</p></li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><p><a href="https://www.owasp.org/index.php/XSS_Filter_Evasion_Cheat_Sheet" target="_blank" rel="noopener">XSS攻击手册</a></p></li><li><p><a href="https://www.owasp.org/index.php/XSS_Prevention_Cheat_Sheet" target="_blank" rel="noopener">XSS防御手册</a></p></li><li><p>《Web前端黑客技术揭秘》</p></li><li><p>《Web安全深度剖析》</p></li><li><p>《白帽子讲Web安全》</p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Web 前端的安全主要有三类：XSS、CSRF、界面操作劫持。&lt;/p&gt;
&lt;p&gt;XSS（Cross Site Scripting），即跨站脚本攻击，是一种代码注入攻击，恶意攻击者往 Web 页面里插入恶意 Script 代码，当用户浏览该页之时，嵌入其中的 Script 代码会被执行，从而达到恶意攻击用户的目的。&lt;/p&gt;
&lt;p&gt;CSRF（Cross Site Request Forgery），即跨站请求伪造，通过伪装来自受信任用户的请求来利用受信任的网站。&lt;/p&gt;
&lt;p&gt;界面劫持操作是一种基于视觉欺骗的Web会话劫持攻击，包括点击劫持、拖放劫持和触屏劫持三种类型。&lt;/p&gt;
&lt;p&gt;在 OWASP TOP 10中，XSS 一直都是名列前茅，有了 XSS 漏洞，就意味着可以注入任意的 JavaScript，被攻击者的任意操作都可以进行模拟，任何隐私信息都可以获取到。基于上述背景，本文将对 XSS 攻击的原理、类型及防御进行介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="wangpeiyu" scheme="http://xgfe.github.io/categories/wangpeiyu/"/>
    
    
      <category term="XSS" scheme="http://xgfe.github.io/tags/XSS/"/>
    
      <category term="Web 安全" scheme="http://xgfe.github.io/tags/Web-%E5%AE%89%E5%85%A8/"/>
    
      <category term="前端安全" scheme="http://xgfe.github.io/tags/%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>前后端通信的几种方式</title>
    <link href="http://xgfe.github.io/2018/06/10/anjing/Communication-between-front-end/"/>
    <id>http://xgfe.github.io/2018/06/10/anjing/Communication-between-front-end/</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-10-26T08:09:54.357Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要总结了前后端通信的几种方式。本文分为两个部分，第一部分是主要是介绍同源的前后端通信的方式，第二部分是介绍前后端跨域通信的方式。</p><a id="more"></a><h2 id="一、前后端通信（同源）简介"><a href="#一、前后端通信（同源）简介" class="headerlink" title="一、前后端通信（同源）简介"></a>一、前后端通信（同源）简介</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>同源策略显示从一个源加载的文档或脚本如何来自另一个源的资源进行交互。这是一个用于隔离潜在恶意文件的关键的安全机制。源包含三部分内容（协议，端口和域名，默认端口是 80 ）。<br>同源的限制：<br>（1）Cookie , LocalStorage 和 IndexDB 无法获取<br>（2）DOM无法获得和操作<br>（3）Ajax请求不能发送，只是用与同源通信</p><h3 id="2-前后端通信的几种方式"><a href="#2-前后端通信的几种方式" class="headerlink" title="2.前后端通信的几种方式"></a>2.前后端通信的几种方式</h3><ul><li>Ajax（同源下面的通信方式）</li><li>WebSocket（不受同源策略限制）</li><li>CORS（支持跨域也支持同源）</li></ul><h3 id="3-如何创建一个Ajax"><a href="#3-如何创建一个Ajax" class="headerlink" title="3.如何创建一个Ajax"></a>3.如何创建一个Ajax</h3><p>发送 Ajax 请求的五个步骤（XMLHttpRequest的工作原理）<br>（1）创建 XMLHttpRequest 对象。<br>（2）使用 open 方法设置请求的参数。open ( method , url, 是否异步)。<br>（3）发送请求。<br>（4）注册事件。 注册 onreadystatechange 事件，状态改变时就会调用。如果要在数据完整请求回来的时候才调用，我们需要手动写一些判断的逻辑。<br>（5）获取返回的数据，更新UI。<br>post 请求举例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 建立XMLHttpRequest对象       </span><br><span class="line">var xhr = new XMLHttpRequest();        </span><br><span class="line">xhr.open(&apos;post&apos;, &apos;02.post.php&apos;);           </span><br><span class="line">xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);  </span><br><span class="line">// 将数据通过send方法传递       </span><br><span class="line">xhr.send(&apos;name=fox&amp;age=18&apos;);            </span><br><span class="line">xhr.onreadystatechange = function () &#123;                 </span><br><span class="line">    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; </span><br><span class="line">        //判断返回状态  </span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="4-实际开发中用的原生Ajax请求"><a href="#4-实际开发中用的原生Ajax请求" class="headerlink" title="4.实际开发中用的原生Ajax请求"></a>4.实际开发中用的原生Ajax请求</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">var util = &#123;&#125;;      </span><br><span class="line">//获取 Ajax 请求之后的 json     </span><br><span class="line">util.json = function (options) &#123;</span><br><span class="line">    var opt = &#123;</span><br><span class="line">        url: &apos;&apos;,</span><br><span class="line">        type: &apos;get&apos;,</span><br><span class="line">        data: &#123;&#125;,</span><br><span class="line">        success: function () &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: function () &#123;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">    Object.assign(opt, options);</span><br><span class="line">    //IE兼容性处理：浏览器特征检查。检查该浏览器是否存在XMLHttpRequest这个api，没有的话，就用IE的api             </span><br><span class="line">    var xhr = XMLHttpRequest ? new XMLHttpRequest() : new window.ActiveXObject(&apos;Microsoft.XMLHTTP&apos;);</span><br><span class="line">    var data = opt.data,</span><br><span class="line">    var type = opt.type.toUpperCase();</span><br><span class="line">    var dataArr = [];</span><br><span class="line">    if (opt.url) &#123;   </span><br><span class="line">        var url = opt.url;</span><br><span class="line">    &#125;</span><br><span class="line">    for (var key in data) &#123;</span><br><span class="line">        dataArr.push(key + &apos;=&apos; + data[key]);</span><br><span class="line">    &#125; </span><br><span class="line">    if (type === &apos;GET&apos;) &#123;</span><br><span class="line">        url = url + &apos;?&apos; + dataArr.join(&apos;&amp;&apos;);</span><br><span class="line">        xhr.open(type, url.replace(/\?$/g, &apos;&apos;), true);</span><br><span class="line">        xhr.send();</span><br><span class="line">    &#125;</span><br><span class="line">    if (type === &apos;POST&apos;) &#123;</span><br><span class="line">        xhr.open(type, url, true);</span><br><span class="line">        // 如果想要使用post提交数据,需要明确设置Request Header    </span><br><span class="line">        xhr.setRequestHeader(&quot;Content-type&quot;, &quot;application/x-www-form-urlencoded&quot;);</span><br><span class="line">        xhr.send(dataArr.join(&apos;&amp;&apos;));</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.onreadystatechange = function () &#123;</span><br><span class="line">        if (xhr.status === 200 || xhr.status === 304) &#123;</span><br><span class="line">            //304表示：用缓存即可。206表示获取媒体资源的前面一部分                </span><br><span class="line">            var res;</span><br><span class="line">            if (opt.success &amp;&amp; opt.success instanceof Function) &#123;</span><br><span class="line">                res = xhr.responseText;</span><br><span class="line">                if (typeof res === &apos;string&apos;) &#123;</span><br><span class="line">                    //将字符串转成json</span><br><span class="line">                    res = JSON.parse(res);                           </span><br><span class="line">                    opt.success.call(xhr, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if (opt.error &amp;&amp; opt.error instanceof Function) &#123;</span><br><span class="line">                opt.error.call(xhr, res);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-WebSocket-介绍"><a href="#5-WebSocket-介绍" class="headerlink" title="5.WebSocket 介绍"></a>5.WebSocket 介绍</h3><p>HTTP 协议有一个缺陷：通信只能由客户端发起。所以出现了 WebSocket 。它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。<br>其他特点包括：<br>（1）建立在 TCP 协议之上，服务器端的实现比较容易。<br>（2）与 HTTP 协议有着良好的兼容性。默认端口也是 80 和 443 ，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。<br>（3）数据格式比较轻量，性能开销小，通信高效。<br>（4）可以发送文本，也可以发送二进制数据。<br>（5）没有同源限制，客户端可以与任意服务器通信。<br>（6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。</p><p>通常WebSocket协议的链接如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ws://example.com:80/some/path</span><br></pre></td></tr></table></figure></p><p>WebSocket 的实现需要后端搭建一个 WebSocket 服务器，但是如果想搭建一个 WebSocket 服务器就没有那么轻松了，因为 WebSocket 是一种新的通信协议，目前还是草案，没有成为标准，比如 PyWebSocket , WebSocket-Node , LibWebSockets 等等，这些库文件已经实现了WebSocket 数据包的封装和解析，我们可以调用这些接口，这在很大程度上减少了我们的工作量。<br>具体的实现方式：（在客户端）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 再js文件中 创建WebSocket对象</span><br><span class="line">var ws = new WebSocket(‘wss://echo.WebSocket.org’);</span><br><span class="line">ws.onopen = function (evt) &#123;</span><br><span class="line">    console.log(‘connnection……’);</span><br><span class="line">    ws.send(&apos;hello WebSocket&apos;);</span><br><span class="line">&#125;</span><br><span class="line">ws.onmessage = function (evt) &#123;</span><br><span class="line">    console.log(&apos;received message&apos; + evt.data);</span><br><span class="line">    ws.close();</span><br><span class="line">&#125;</span><br><span class="line">ws.onclose = dunction(evt)&#123;</span><br><span class="line">    console.log(&apos;connection closed.&apos;);</span><br><span class="line">&#125;   </span><br><span class="line">// ws的使用，以为按钮添加发送信息事件为例</span><br><span class="line">$(&quot;#send&quot;).click(function()&#123;</span><br><span class="line">    ws.send($(&quot;#msg&quot;).val());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="6-CORS-介绍"><a href="#6-CORS-介绍" class="headerlink" title="6.CORS 介绍"></a>6.CORS 介绍</h3><p>CORS是一个 W3C 标准，跨域资源共享（CORS ）是一种网络浏览器的技术规范，它为Web服务器定义了一种方式，允许网页从不同的域访问其资源。而这种访问是被同源策略所禁止的。CORS 系统定义了一种浏览器和服务器交互的方式来确定是否允许跨域请求。 它是一个妥协，有更大的灵活性，但比起简单地允许所有这些的要求来说更加安全。简言之， CORS 就是为了让 AJAX 可以实现可控的跨域访问而生的。<br>下图为各浏览器对于 CORS 的支持情况，看起来相当乐观。主流浏览器都已基本提供对跨域资源共享的支持，所以，CORS 才会在国外使用的如此普遍。<br><img src="http://vfile.meituan.net/xgfe/d87439988ef5ab43251311a668d027d6233940.png" alt=""><br>使用 CORS 需要做服务端和前端的配置：</p><h4 id="服务端的配置"><a href="#服务端的配置" class="headerlink" title="服务端的配置"></a>服务端的配置</h4><p>以下是 CORS 协议规定的 HTTP 头，用来进行浏览器发起跨域资源请求时进行协商：</p><ol><li>Origin。HTTP 请求头，任何涉及 CORS 的请求都必需携带。</li><li>Access-Control-Request-Method。HTTP 请求头，在带预检( Preflighted )的跨域请求中用来表示真实请求的方法。</li><li>Access-Control-Request-Headers。HTTP 请求头，在带预检( Preflighted )的跨域请求中用来表示真实请求的自定义 Header 列表。</li><li>Access-Control-Allow-Origin。HTTP 响应头，指定服务器端允许进行跨域资源访问的来源域。可以用通配符 * 表示允许任何域的JavaScript 访问资源，但是在响应一个携带身份信息( Credential )的 HTTP 请求时，Access-Control-Allow-Origin 必需指定具体的域，不能用通配符。</li><li>Access-Control-Allow-Methods。HTTP 响应头，指定服务器允许进行跨域资源访问的请求方法列表，一般用在响应预检请求上。</li><li>Access-Control-Allow-Headers。HTTP 响应头，指定服务器允许进行跨域资源访问的请求头列表，一般用在响应预检请求上。</li><li>Access-Control-Max-Age。HTTP 响应头，用在响应预检请求上，表示本次预检响应的有效时间。在此时间内，浏览器都可以根据此次协商结果决定是否有必要直接发送真实请求，而无需再次发送预检请求。</li><li>Access-Control-Allow-Credentials。HTTP 响应头，凡是浏览器请求中携带了身份信息，而响应头中没有返回。</li></ol><p>实际应用中，服务端例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//允许跨域访问  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;);  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Methods&quot;, &quot;POST, GET, OPTIONS, DELETE,PUT&quot;);  </span><br><span class="line">HttpContext.Current.Response.AddHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Test&quot;);</span><br></pre></td></tr></table></figure><h4 id="前端的配置"><a href="#前端的配置" class="headerlink" title="前端的配置"></a>前端的配置</h4><p>前端的配置主要从简单请求、非简单请求和携带身份凭证这三点进行讲解。<br>浏览器将CORS请求分成两类：简单请求（ simple request ）和非简单请求（ not-so-simple request ）。<br>1.简单请求：<br>使用下列方法：GET、 HEAD、 POST<br>HTTP的头信息主要是以下几种字段：</p><ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Content-Type 的值属于下列之一: <ul><li>application/x-www-form-urlencoded</li><li>multipart/form-data</li><li>text/plain</li></ul></li></ul><p>简单请求如图所示：<br><img src="http://vfile.meituan.net/xgfe/63958e7743ea262c379f4466c52844a636486.png" alt=""><br>2.非简单请求：<br>不满足简单请求条件的请求则要先进行预检请求，即使用 OPTIONS 方法发起一个预检请求到服务器，已获知服务器是否允许该实际请求。<br>非简单请求如下所示：<br><img src="http://vfile.meituan.net/xgfe/cf3757d6cc10ac2d4c9c023af564900f126443.png" alt=""><br>浏览器与服务器之间请求只进行了一次。<br>下面是 PUT 请求第一次返回的结果：<br><img src="http://vfile.meituan.net/xgfe/33d389422e08f9f730faa7757ef26bba81218.png" alt=""><br><img src="http://vfile.meituan.net/xgfe/000d4cf1b6d92837affcddef925df2a176640.png" alt=""><br>通过PUT请求结果可以看出，当检测到 PUT 请求为非简单请求时，浏览器便会发送一个预检请求，目的是询问，自定义头部 X-Custom-Header 的 PUT 请求是否被允许，浏览器返回了所有可以请求的方法和自定义的头部（把所有可以的返回是为了避免多次预检请求），这时候预检请求成功了，便会发送真正的PUT请求。</p><p>关于预检请求，需要注意一下两点：</p><ul><li>预检请求对 js 来说是透明的，js 获取不到预检请求的任何信息。</li><li>预检请求并不是每次请求都发生，服务端设置的 Access-Control-Max-Age 头部指定了预检请求的有效期，在有效期内的非简单请求不需要再次发生预检请求。</li></ul><p>3.携带身份凭证<br>大部分的请求是需要用户携带着用户信息的，比如在一个登录的系统中，用户会携带着相应的 cookie 或 token ，但 CORS 跨域默认是不带身份凭证的。<br>如果需要附带身份凭证，在发送请求时，通过将 withCredentials 属性设置为 true ，可以指定某个请求可以发送凭据。<br>下面提供针对 XMLHttpRequest 附带身份凭证的兼容性写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function createCORSRequest(method, url) &#123;</span><br><span class="line">    var xhr = new XMLHttpRequest();</span><br><span class="line">    xhr.onreadystatechange = function() &#123;</span><br><span class="line">        if(xhr.readyState == 4) &#123;</span><br><span class="line">            if((xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300) || xhr == 304) &#123;</span><br><span class="line">                console.log(xhr.response);</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                console.log(&apos;Request was unsuccessful: &apos; + xhr.status);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    if(&apos;withCredentials&apos; in xhr) &#123;</span><br><span class="line">        xhr.open(method,url, true);</span><br><span class="line">    &#125; else if(typeof XDomainRequest != &apos;undefined&apos;) &#123;</span><br><span class="line">        xhr = new XDomainRequest();</span><br><span class="line">        xhr.open(method, url);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        xhr = null;</span><br><span class="line">    &#125;</span><br><span class="line">    return xhr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>附带身份凭证对服务端有两个要求：</p><ol><li>服务端的 Access-Control-Allow-Origin 头部不能设置为 *</li><li>服务端的 Access-Control-Allow-Credentials 头部设置为 true</li></ol><h2 id="二、-前后端跨域通信"><a href="#二、-前后端跨域通信" class="headerlink" title="二、 前后端跨域通信"></a>二、 前后端跨域通信</h2><ul><li>JSONP</li><li>Hash</li><li>WebSocket</li><li>CORS</li></ul><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><p>JSONP 的工作原理：<br>本质是利用了 script 标签具有可跨域的特性，由服务端返回预先定义好的 javascript 全局函数的调用，并且将服务端数据以该函数参数的形式传递过来。比如说，客户端这样写：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src=&quot;http://www.smyhvae.com/?data=name&amp;callback=myjsonp&quot;&gt;&lt;/script&gt;</span><br></pre></td></tr></table></figure></p><p>实际开发中，前端的 JSONP 是这样实现的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> var util = &#123;&#125;; </span><br><span class="line"> //定义方法：动态创建script标签</span><br><span class="line"> util.createScript = function (url, charset) &#123;</span><br><span class="line">     var script = document.createElement(&apos;script&apos;);</span><br><span class="line">     script.setAttribute(&apos;type&apos;, &apos;text/javascript&apos;);</span><br><span class="line">     charset &amp;&amp; script.setAttribute(&apos;charset&apos;, charset);</span><br><span class="line">     script.setAttribute(&apos;src&apos;, url);</span><br><span class="line">     script.async = true;</span><br><span class="line">     return script;</span><br><span class="line">&#125;;</span><br><span class="line"> util.jsonp = function (url, onsuccess, onerror, charset) &#123;  </span><br><span class="line">     //事先约定好的函数名</span><br><span class="line">     var callbackName = util.getName(&apos;tt_player&apos;);  </span><br><span class="line">     //根据回调名称注册一个全局的函数 </span><br><span class="line">     window[callbackName] = function () &#123;               </span><br><span class="line">         if (onsuccess &amp;&amp; util.isFunction(onsuccess)) &#123;</span><br><span class="line">             onsuccess(arguments[0]);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     //动态创建一个script标签</span><br><span class="line">     var script = util.createScript(url + &apos;&amp;callback=&apos; + callbackName, charset);   </span><br><span class="line">     //监听加载成功的事件，获取数据</span><br><span class="line">     script.onreadystatechange = function () &#123;      </span><br><span class="line">         if (!script.readyState || /loaded|complete/.test(script.readyState)) &#123;              </span><br><span class="line">             if (script.parentNode) &#123;</span><br><span class="line">                 // 删除函数或变量</span><br><span class="line">                 script.parentNode.removeChild(script);  </span><br><span class="line">             &#125;      </span><br><span class="line">             //最后不要忘了删除           </span><br><span class="line">             window[callbackName] = null;  </span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     script.onerror = function () &#123;                              </span><br><span class="line">         if (onerror &amp;&amp; util.isFunction(onerror)) &#123;</span><br><span class="line">             onerror();</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     //往html中增加这个标签，目的是把请求发送出去</span><br><span class="line">     document.getElementsByTagName(&apos;head&apos;)[0].appendChild(script);  </span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></p><h3 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h3><p>url 的#后面的内容就叫 Hash 。Hash 的改变，页面不会刷新。这就是用 Hash 做跨域通信的基本原理。<br>补充：url 的?后面的内容叫 Search 。 Search 的改变，会导致页面刷新，因此不能做跨域通信。<br>使用举例：<br>场景：我的页面 A 通过 iframe 或 frame 嵌入了跨域的页面 B。<br>现在，我这个 A 页面想给B页面发消息，怎么操作呢？<br>（1）首先，在我的A页面中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//伪代码  </span><br><span class="line">var B = document.getElementsByTagName(&apos;iframe&apos;);  </span><br><span class="line">//我们可以把JS对象，通过JSON.stringify()方法转成json字符串，发给B   </span><br><span class="line">B.src = B.src + &apos;#&apos; + &apos;jsonString&apos;;</span><br></pre></td></tr></table></figure><p>（2）然后，在 B 页面中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// B 中的伪代码     </span><br><span class="line">window.onhashchange = function () &#123; </span><br><span class="line">     //通过onhashchange方法监听，url中的hash是否发生变化         </span><br><span class="line">     var data = window.location.hash;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>总结：<br>本文主要对前后端通信的几种方式做了简单介绍，希望对大家对前后端通信方面的学习有所帮助，总结不到位的地方还请大家批评指正。<br>友情参考链接：<br><a href="https://blog.csdn.net/a54654132/article/details/77604597" target="_blank" rel="noopener">https://blog.csdn.net/a54654132/article/details/77604597</a><br><a href="https://www.cnblogs.com/yanglang/p/6720887.html" target="_blank" rel="noopener">https://www.cnblogs.com/yanglang/p/6720887.html</a><br><a href="https://www.cnblogs.com/smyhvae/p/8523576.html" target="_blank" rel="noopener">https://www.cnblogs.com/smyhvae/p/8523576.html</a><br><a href="https://www.cnblogs.com/liugang-vip/p/6337580.html" target="_blank" rel="noopener">https://www.cnblogs.com/liugang-vip/p/6337580.html</a><br><a href="https://blog.csdn.net/qq_27905183/article/details/71023542" target="_blank" rel="noopener">https://blog.csdn.net/qq_27905183/article/details/71023542</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要总结了前后端通信的几种方式。本文分为两个部分，第一部分是主要是介绍同源的前后端通信的方式，第二部分是介绍前后端跨域通信的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="ANJING" scheme="http://xgfe.github.io/categories/ANJING/"/>
    
    
      <category term="前后端通信" scheme="http://xgfe.github.io/tags/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1/"/>
    
  </entry>
  
  <entry>
    <title>数组去重的十种方法</title>
    <link href="http://xgfe.github.io/2018/06/07/yuxue/%E6%95%B0%E7%BB%84%E5%8E%BB%E9%87%8D%E7%9A%84%E5%8D%81%E7%A7%8D%E6%96%B9%E6%B3%95/"/>
    <id>http://xgfe.github.io/2018/06/07/yuxue/数组去重的十种方法/</id>
    <published>2018-06-07T03:12:00.000Z</published>
    <updated>2018-10-24T08:01:13.336Z</updated>
    
    <content type="html"><![CDATA[<p>数组去重可以说是老生常谈的话题了，工作中经常用到，面试中经常问到。那接下来就对数组去重这个老梗，做一个简单的总结与记录。</p><a id="more"></a><h2 id="一、-双重遍历"><a href="#一、-双重遍历" class="headerlink" title="一、 双重遍历"></a>一、 双重遍历</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;<span class="keyword">this</span>.length;j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>[i] === <span class="keyword">this</span>[j]) &#123;</span><br><span class="line">                <span class="keyword">this</span>.splice(j,<span class="number">1</span>);</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line">arr.unique();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr1 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique1 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> j=i+<span class="number">1</span>;j&lt;<span class="keyword">this</span>.length;j++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>[i] === <span class="keyword">this</span>[j]) &#123;</span><br><span class="line">i++;</span><br><span class="line">j = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr1.unique1();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>双重遍历的方式是最容易想到且最容易实现的方式，兼容性比较好，但是时间复杂度比较高；还有一点是不能对 NaN 进行去重。</p><h2 id="二、-indexOf"><a href="#二、-indexOf" class="headerlink" title="二、 indexOf"></a>二、 indexOf</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr2 =  [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(newArr.indexOf(<span class="keyword">this</span>[i]) === <span class="number">-1</span>) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr2.unique2();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h2 id="三、-数组下标判断"><a href="#三、-数组下标判断" class="headerlink" title="三、 数组下标判断"></a>三、 数组下标判断</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr3 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique3 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>.indexOf(<span class="keyword">this</span>[i]) === i) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line">arr3.unique3();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>因为 indexOf 使用的内部严格相等比较算法，所以在检索NaN时会返回-1 ，进而会导致方法3直接过滤掉了 NaN。</p><h2 id="四、排序再去重"><a href="#四、排序再去重" class="headerlink" title="四、排序再去重"></a>四、排序再去重</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr4 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique4 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];<span class="keyword">this</span>.sort();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">this</span>[i] !== newArr[newArr.length<span class="number">-1</span>]) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr4.unique4();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">5678</span>, <span class="string">"5678"</span>, <span class="number">6</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">"Start"</span>, <span class="literal">null</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>优点是利用 js 内置的排序方法，速度快，比较的是排序后的相邻元素。最大的不同是更改了原数组的排序。</p><h2 id="五、利用对象的属性"><a href="#五、利用对象的属性" class="headerlink" title="五、利用对象的属性"></a>五、利用对象的属性</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本1</span></span><br><span class="line"><span class="keyword">let</span> arr5 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique5 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!obj[<span class="keyword">this</span>[i]])&#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">obj[<span class="keyword">this</span>[i]] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr5.unique5();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h3 id="优化-1"><a href="#优化-1" class="headerlink" title="优化"></a>优化</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//版本2</span></span><br><span class="line"><span class="keyword">let</span> arr6 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique6 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">let</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> tmpKey;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line">tmpKey = <span class="keyword">typeof</span> <span class="keyword">this</span>[i] + <span class="built_in">JSON</span>.stringify(<span class="keyword">this</span>[i]);</span><br><span class="line"><span class="keyword">if</span>(!obj[tmpKey]) &#123;</span><br><span class="line">obj[tmpKey] = <span class="number">1</span>;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr6.unique6();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>由于对象的键名只能是 String，所以版本1的局限性在于</p><ol><li><p>无法区分隐式类型转换成字符串后一样的值，比如 1 和 “1”</p></li><li><p>无法处理复杂类型，比如对象（因为对象作为key会变成[ object Object ]）</p></li><li><p>特殊数据，比如 <code>__proto__</code> 会挂掉，因为obj对象的 <code>__proto__</code> 属性无法被重写</p></li></ol><p>版本2的优化则解决了这三个问题。缺点就是实现的方式比较麻烦。</p><h2 id="六、-reduce"><a href="#六、-reduce" class="headerlink" title="六、 reduce"></a>六、 reduce</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr7 =  [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique7 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = <span class="keyword">this</span>.sort().reduce(<span class="function">(<span class="params">initialValue, current</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="keyword">if</span>(initialValue.length === <span class="number">0</span> || initialValue[initialValue.length - <span class="number">1</span>] !== current)&#123;</span><br><span class="line">initialValue.push(current);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> initialValue;</span><br><span class="line">&#125;, []);</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr7.unique7();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">5678</span>, <span class="string">"5678"</span>, <span class="number">6</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>, <span class="string">"Start"</span>, <span class="literal">null</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><p>原理实际同方法四，都是进行排序后比较相邻的两个值。</p><h2 id="七、-filter"><a href="#七、-filter" class="headerlink" title="七、 filter"></a>七、 filter</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr8 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique8 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.filter(<span class="function"><span class="keyword">function</span>(<span class="params">ele,index,res</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> res.indexOf(ele) === index;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">arr8.unique8();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure><h2 id="八、-es6-includes"><a href="#八、-es6-includes" class="headerlink" title="八、 es6 includes"></a>八、 es6 includes</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr9 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>,  <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique9 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="keyword">this</span>.length;i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(!newArr.includes(<span class="keyword">this</span>[i])) &#123;</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr9.unique9();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>与 indexOf 类似，但不同的是 indexOf 使用的严格比较，includes 使用的是叫做 SameValueZero 的比较，规范中给出 If x is NaN and y is NaN, return true. 也就是 includes 可以对NaN去重。</p><h2 id="九、-es6-Map"><a href="#九、-es6-Map" class="headerlink" title="九、 es6 Map"></a>九、 es6 Map</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr10 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>,<span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.unique10 = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> newArr = [];</span><br><span class="line"><span class="keyword">let</span> tmp = <span class="keyword">new</span> <span class="built_in">Map</span>();</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i&lt;<span class="keyword">this</span>.length; i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(!tmp.get(<span class="keyword">this</span>[i]))&#123;</span><br><span class="line">tmp.set(<span class="keyword">this</span>[i], <span class="number">1</span>);</span><br><span class="line">newArr.push(<span class="keyword">this</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> newArr;</span><br><span class="line">&#125;</span><br><span class="line">arr10.unique10();</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><h2 id="十、-es6-Set"><a href="#十、-es6-Set" class="headerlink" title="十、 es6 Set"></a>十、 es6 Set</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr11 = [<span class="number">6</span>, <span class="number">6</span>, <span class="number">6</span>, <span class="number">5678</span>, <span class="string">'5678'</span>, <span class="string">'Start'</span>, <span class="string">'start'</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>, <span class="literal">NaN</span>];</span><br><span class="line"><span class="built_in">console</span>.log([...new <span class="built_in">Set</span>(arr11)]);</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result: [<span class="number">6</span>, <span class="number">5678</span>, <span class="string">"5678"</span>, <span class="string">"Start"</span>, <span class="string">"start"</span>, <span class="literal">true</span>, <span class="literal">null</span>, <span class="literal">undefined</span>, <span class="literal">NaN</span>]</span><br></pre></td></tr></table></figure><p>利用 set 对象存储任何类型的唯一值的特性来达到去重的目的。</p><p>再来来看看这几种方式直观的性能对比。<br>通过以下的模拟数据的形式来执行我们上面介绍的每一种方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重复100次生成1~10000的数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createArr</span> (<span class="params">size</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> create = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">100</span>; i++ ) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j=<span class="number">0</span>; j&lt;<span class="number">10000</span>; j++) &#123;</span><br><span class="line">            create.push(j)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> create</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算去重函数的时间</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkTime</span> (<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> date1 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line">    fn();</span><br><span class="line"><span class="keyword">var</span> date2 = <span class="keyword">new</span> <span class="built_in">Date</span>().getTime()</span><br><span class="line"><span class="keyword">var</span> result = date2 - date1;</span><br><span class="line">    <span class="keyword">return</span>  result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> lgArr = createArr();</span><br><span class="line"><span class="keyword">const</span> res = checkTime(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">return</span> lgArr.unique()&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"&#123;method：loop，time:"</span> + res + <span class="string">"&#125;"</span>);</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="http://vfile.meituan.net/xgfe/84a60f898fc7283c3ce2dc70d770b137116872.png" alt=""></p><p>在考虑兼容性,并且可以接受以上所说的 Object.key 的限制时，用对象属性方式是最快的。如果考虑这些限制，就要用到对象属性的优化方案，增加对 key 的类型的判断，但这样做显然会麻烦很多，如果处理不好还可能导致结果出错。那么在数据量比较小的情况下，选用 indexof 不失为一种更加稳妥的办法。</p><p>在现代浏览器中当然首选的是 es6 的 set 和 map ,方便易用。在不关注排序的情况下，reduce 和 sort 也是比较可取的方式。<br>以上仅仅是从时间维度上的个人分析。实际工作中还要根据情况进行综合考虑来选择最合适的方式。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;数组去重可以说是老生常谈的话题了，工作中经常用到，面试中经常问到。那接下来就对数组去重这个老梗，做一个简单的总结与记录。&lt;/p&gt;
    
    </summary>
    
      <category term="yuxue" scheme="http://xgfe.github.io/categories/yuxue/"/>
    
    
      <category term="数组" scheme="http://xgfe.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
      <category term="去重" scheme="http://xgfe.github.io/tags/%E5%8E%BB%E9%87%8D/"/>
    
  </entry>
  
  <entry>
    <title>移动前端开发中的伪装术</title>
    <link href="http://xgfe.github.io/2018/05/30/zhaojun/hybrid/"/>
    <id>http://xgfe.github.io/2018/05/30/zhaojun/hybrid/</id>
    <published>2018-05-30T04:00:00.000Z</published>
    <updated>2018-10-24T07:51:20.238Z</updated>
    
    <content type="html"><![CDATA[<p>本文从一个web前端的角度讲述了在移动端开发中H5,Hybrid,react-native与原生应用的差距，探讨了如何将自己的应用，尽可能在UI，交互体验，流畅度方面去接近原生应用。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>去年双十一，中国客单占比中，有近90%的用户，使用移动设备下单。移动互联网在中国的普及程度可见一斑。正是因为用户终端的转变，前端攻城狮们的技能树也需要改变。</p><h2 id="战场的转移"><a href="#战场的转移" class="headerlink" title="战场的转移"></a>战场的转移</h2><p>目前前端攻城狮（由于背景是针对原本的web前端，本文暂时不把iOS和Android开发归入前端攻城狮的队伍中，虽然现在广义上来说app开发也属于前端开发）在移动端的主要战场有以下几个：</p><ol><li>普通浏览器网页的移动端响应式适配</li><li>hybrid（含微信小程序）</li><li>react native</li><li>PWA（暂时还是非主流）</li></ol><p>用一个表格整理一下</p><table><thead><tr><th></th><th>流畅度</th><th>交互体验</th><th>开发学习成本</th><th>功能及限制</th><th>发布</th></tr></thead><tbody><tr><td>移动端网页</td><td>最低</td><td>差</td><td>低，兼容性和响应式</td><td>需要浏览器运行，功能被浏览器限制</td><td>与web前端一致</td></tr><tr><td>Hybrid（含小程序）</td><td>低</td><td>较好</td><td>一套代码两端复用</td><td>通过JSBridge，SDK调用原生功能</td><td>通过热更新</td></tr><tr><td>React Native</td><td>高</td><td>好</td><td>一套代码两端复用，有个别组件和属性有平台差异</td><td>本身有组件和API可以调用部分原生功能，也可以用Bridge</td><td>通过热更新</td></tr><tr><td>原生APP</td><td>最高</td><td>最佳</td><td>学习成本大，需要开发ios端和安卓端</td><td>无限制</td><td>有审核，版本兼容问题多</td></tr></tbody></table><p>前端攻城狮在移动互联网的时代中是既希望保留前端开发敏捷灵活的特点，也希望可以给用户更好的交互体验。</p><h2 id="原生APP的交互体验"><a href="#原生APP的交互体验" class="headerlink" title="原生APP的交互体验"></a>原生APP的交互体验</h2><p>一个好的APP到底会和一个移动端网页有什么样的区别，这些差异能不能通过一些技术上的优化来抹平？</p><h3 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h3><p>原生APP与WEB网页最直观的的区别就是UI上，APP和网页在设计上有很多各自的风格，当然这种风格上的差距是可以轻易抹平的。<br>UI的设计资源在前端团队中是非常的重要。比如说Ant Design提供的一些思路和实践：字体，行高，空白的大小都可以固定为一些常量，交互和组件UI包含在了组件之中。<br>简单说一下取色的过程。<a href="http://ant.design/docs/spec/colors-cn" target="_blank" rel="noopener">参考链接</a><br><img src="https://ws1.sinaimg.cn/large/6f3ac581gy1fv7x26gopdj20ow0gkmy0.jpg" alt=""><br>一般来说在设计过程中，一个应用多数是会有主色，辅助色，强调色。而在实际的开发中，例如图中蓝色的主色又会衍生为hover、click、disable等几种状态，如果一个项目并没有UI的介入，此时自动通过一个主色调，衍生出多种色彩就显得很重要。除了通过类似<a href="https://ant.design/docs/spec/colors-cn" target="_blank" rel="noopener">Ant Design的取色板</a>帮助取色外，也可以通过代码的手段。衍生颜色的过程其实就是HSV颜色空间的变化。这里不详述这一点了。</p><h3 id="交互感"><a href="#交互感" class="headerlink" title="交互感"></a>交互感</h3><p>以下是一些良好交互的例子：</p><ul><li>每个按钮在用户点击后都有反馈，例如颜色的变化或者是出现波纹</li><li>每个页面进出时或者是tab切换时都有动画</li><li>列表下拉上拉时出现弹性的动作</li></ul><p>这些良好的交互都是需要前端去实现的。<br>目前用户已经养成了一些移动端APP的使用习惯，比如用户会认为一个列表下拉的时候数据会重新刷新，上拉到底的时候数据会加载更多，一个按钮点击的时候会产生背景颜色的变化等等。所以需要将交互的模式和动画利用UI、UE积累的设计资源沉淀到组件中。假设这些交互动画都可以流畅的实现，并且形成一套移动端的组件库，那么使用这套组件库开发的一个应用就可以有比较优秀的用户体验。比如说RN官方提供的<a href="https://reactnative.cn/docs/0.51/touchablenativefeedback.html#content" target="_blank" rel="noopener">TouchableNativeFeedback组件</a>，就实现了可以实现涟漪状的波纹。<br>另一个问题就是交互动画的流畅度能不能和原生应用媲美呢。由于手机的性能瓶颈，目前在移动端的动画仍然需要去进行优化保证动画的流畅度，就动画方面是有一些手段可以提升流畅度的：</p><ol><li>动画尽可能使用transform，而非直接操作dom</li><li>必要情况下使用will-change或者transform3D()去让Webview调用GPU做渲染</li><li>如果有dom操作考虑回流和重绘的优化。<a href="http://xgfe.github.io/2018/04/15/zhangjianfeng/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">可参考</a></li><li>防抖和节流，优化一些频繁操作</li></ol><p>RN实现动画的话，则可以通过Animated库实现流畅又好看的动效。<a href="https://reactnative.cn/docs/0.51/animations.html" target="_blank" rel="noopener">RN动画参考</a></p><h3 id="手势操作"><a href="#手势操作" class="headerlink" title="手势操作"></a>手势操作</h3><p>多点触控可以组成一系列的手势操作，这个是智能手机的体验优势，原生的APP可以很好的支持手势事件，做出流畅的交互体验。JS也可以通过touch库去监听到手势，并作出交互；另外在RN上对手势则有天然的支持。<a href="https://reactnative.cn/docs/0.51/gesture-responder-system.html#content" target="_blank" rel="noopener">参考链接</a></p><h3 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h3><p>下图是一个react的Hybrid项目在webview中渲染出来的过程<br><img src="http://ww1.sinaimg.cn/large/6f3ac581gy1frt5z11h1kj20ta088q37.jpg" alt=""></p><p>基于这个过程有以下一些加速方案，主要分为两类，网络类和渲染类。<br>首先是网络类</p><ul><li>在兼顾APP包大小的前提下，将一部分资源放入离线包。</li><li>采用HTTP缓存，减少资源的重复请求。</li><li>拆分快慢接口，首屏展示时尽可能不要先请求慢接口。</li><li>升级到HTTP2，多路复用。</li><li>DNS寻址优化。</li><li>本地数据缓存，先使用本地数据渲染页面，然后等线上数据更新下来后再更新视图。</li><li>缓存的差分更新。</li><li>减少cookie的传输。</li></ul><p>附上一个<a href="https://zhuanlan.zhihu.com/p/24202408" target="_blank" rel="noopener">美团大众点评Hybrid</a>资源预加载的方案<br><img src="http://ww1.sinaimg.cn/large/6f3ac581gy1fv7wzeaxgfj20k00d6aar.jpg" alt=""></p><p>渲染类</p><ul><li>在页面拿到基础的dom结构后，优先用占位符的方式，尽快缩减页面渲染的体感时长。</li><li>MVVM框架中减少不必要的的DOM更新。</li><li>首屏渲染的直出。</li><li>尽可能减少Webview中的JS代码，让Webview专一的处理渲染工作，业务和框架JS放入JSCore中，Webview和JSCore通过桥通信更新DOM<br>节点。</li></ul><h4 id="Webview与jsCore"><a href="#Webview与jsCore" class="headerlink" title="Webview与jsCore"></a>Webview与jsCore</h4><p>微信小程序就是二者分离的典型实践。微信小程序直接进行平时前端的DOM操作是不支持的，原因就是脚本的运行环境是JSCore并不支持DOM和BOM对象。微信小程序对MVVM模式在Hybrid上给出的最佳实践就是：业务脚本，虚拟DOM的diff交给JSCore，让Webview可以专心致志的去完成DOM的渲染，事件监听，DOM的更新工作。<br>Hybrid一个桥连接Webview和native的实践很常见，如果像微信一样用到Webview和JSCore的话需要两个桥。<br><img src="http://ww1.sinaimg.cn/large/6f3ac581gy1frtbophcnfj20g503xmx5.jpg" alt=""><br>JSBridge实际上可以算作是一个<a href="https://segmentfault.com/a/1190000014206309" target="_blank" rel="noopener">EventEmitter</a>的变形。<br>JS部分的核心接口的伪代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注册函数，用于被native调用</span></span><br><span class="line"><span class="keyword">const</span> addListener = <span class="function"><span class="keyword">function</span>(<span class="params">type, fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isFunction(fn)) <span class="keyword">return</span>;<span class="comment">//判断是否在监听中添加的是合法的函数</span></span><br><span class="line">    <span class="comment">//判断type是否添加过，添加过一个还是多个函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.event[type]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isArray(<span class="keyword">this</span>.event[type]))&#123;</span><br><span class="line">            <span class="comment">//如果想要实现preadd将push改为unshift即可</span></span><br><span class="line">            <span class="keyword">this</span>.event[type].push(fn);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果想要实现preadd改变顺序</span></span><br><span class="line">            <span class="keyword">this</span>.event[type] = [<span class="keyword">this</span>.event[type], fn];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.event[type] = fn;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是向native发送消息的postMessage函数，核心的信息是option</p><ul><li>name: 对应了在addListener中的type</li><li>data: 给native中传递的数据</li><li>callback: 回调函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//postMessage是用于调用native</span></span><br><span class="line"><span class="keyword">const</span> nativeBridge = getBridge();<span class="comment">//根据平台获取bridge</span></span><br><span class="line"><span class="keyword">const</span> postMessage = <span class="function"><span class="keyword">function</span> (<span class="params">option</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> id = createID(option.name);<span class="comment">//生成唯一id</span></span><br><span class="line">    addListener(id, option.callBack);</span><br><span class="line">    nativeBridge.post(&#123;</span><br><span class="line">        name: option.name,</span><br><span class="line">        data: option.data,</span><br><span class="line">        cbId: id</span><br><span class="line">    &#125;);<span class="comment">//通知native</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> receiveMessage = <span class="function"><span class="keyword">function</span>(<span class="params">option</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> handle = <span class="keyword">this</span>.event[option.cbId];</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(handle.call(<span class="literal">null</span>, option.message)).then(<span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">        postMessage(&#123;</span><br><span class="line">            name: option.name,</span><br><span class="line">            data: args</span><br><span class="line">        &#125;);<span class="comment">//执行native的回调</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用两个桥在JSCore中可以在执行业务逻辑代码，及虚拟dom diff后将需要进行dom修改结果通过告知native<br>option可以如下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    name: <span class="string">'domUpdate'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">        pageId: <span class="string">'xxx'</span>,</span><br><span class="line">        componentId: <span class="string">'xxx'</span>,</span><br><span class="line">        children: [&#123;</span><br><span class="line">            type: <span class="string">'text'</span>,</span><br><span class="line">            content: <span class="string">'换了换了'</span></span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            type: <span class="string">'span'</span>,</span><br><span class="line">            children: [&#123;</span><br><span class="line">                type: <span class="string">'text'</span>,</span><br><span class="line">                content: <span class="string">'我也换了'</span></span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;],</span><br><span class="line">        type:</span><br><span class="line">    &#125;,</span><br><span class="line">    callback: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="built_in">console</span>.log(<span class="string">'updateDown'</span>)&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>native发现是domUpdate后通知webview的DomUpdate，根据page，component及data进行DOM的更新</p><p>以上就是利用JSCore进行渲染加速的一点思路。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在做Hybrid项目和RN项目中，更多的关注性能和体验，渲染层面的优化很多需要整体方案的革新或者整个框架的支持，不过在组件层面交互的优化是性价比最高，也相对容易实现的手段。这就需要在移动端的业务开发工作中积累组件，雕琢交互体验。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文从一个web前端的角度讲述了在移动端开发中H5,Hybrid,react-native与原生应用的差距，探讨了如何将自己的应用，尽可能在UI，交互体验，流畅度方面去接近原生应用。&lt;/p&gt;
    
    </summary>
    
      <category term="zhaojun" scheme="http://xgfe.github.io/categories/zhaojun/"/>
    
    
      <category term="React Native" scheme="http://xgfe.github.io/tags/React-Native/"/>
    
      <category term="前端优化实践" scheme="http://xgfe.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    
      <category term="移动端" scheme="http://xgfe.github.io/tags/%E7%A7%BB%E5%8A%A8%E7%AB%AF/"/>
    
      <category term="hybrid" scheme="http://xgfe.github.io/tags/hybrid/"/>
    
  </entry>
  
  <entry>
    <title>Egg.js 体验</title>
    <link href="http://xgfe.github.io/2018/05/26/guanxiaofeng/Eggjs/"/>
    <id>http://xgfe.github.io/2018/05/26/guanxiaofeng/Eggjs/</id>
    <published>2018-05-26T07:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.239Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍了 Egg.js 在项目中的使用以及框架的扩展。<br><a id="more"></a></p><h2 id="Egg-js-是什么"><a href="#Egg-js-是什么" class="headerlink" title="Egg.js 是什么?"></a>Egg.js 是什么?</h2><p>﻿Egg.js 是一个强约束的 Node 框架，这也是和 Express / Koa 最大的不同，后者对开发者相对宽松，主要体现在目录结构、编写方式等均可以自定义，标准的 mvc 模式有千奇百怪的写法。</p><p> Egg.js 奉行『约定优于配置』，他规定一定的约定，让开发者都按照统一的约定去开发，降低团队协作成本，减少差异，求同存异，提升项目阅读和维护性。但约定不等于扩展性差，相反 Egg.js 有很高的扩展性。</p><h3 id="特性"><a href="#特性" class="headerlink" title="﻿特性"></a>﻿特性</h3><pre><code>* 提供基于 Egg 定制上层框架的能力* 高度可扩展的插件机制* 内置多进程管理* 基于 Koa 开发，性能优异* 框架稳定，测试覆盖率高* 渐进式开发</code></pre><h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><p>官方推荐使用脚手架快速生成项目：</p><pre><code>$ npm install egg-init -g$ egg-init egg-test --type=simple$ cd egg-test$ npm install$ npm run dev$ open localhost:7001</code></pre><p>Egg.js 给我们规定的目录结构如下图：</p><pre><code>﻿egg-project├── package.json├── app.js (可选)├── agent.js (可选)├── app|   ├── router.js│   ├── controller│   |   └── home.js│   ├── service (可选)│   |   └── user.js│   ├── middleware (可选)│   |   └── response_time.js│   ├── schedule (可选)│   |   └── my_task.js│   ├── public (可选)│   |   └── reset.css│   ├── view (可选)│   |   └── home.tpl│   └── extend (可选)│       ├── helper.js (可选)│       ├── request.js (可选)│       ├── response.js (可选)│       ├── context.js (可选)│       ├── application.js (可选)│       └── agent.js (可选)├── config|   ├── plugin.js|   ├── config.default.js│   ├── config.prod.js|   ├── config.test.js (可选)|   ├── config.local.js (可选)|   └── config.unittest.js (可选)└── test    ├── middleware    |   └── response_time.test.js    └── controller        └── home.test.js</code></pre><p>﻿其中包括 controller、router 、config 等等，然后我们需要先添加一个渲染模版；Eggjs 提供了很多 view 模版，这里选择 Egg-view-ejs 为例，安装完插件后需要在 config 里面开启插件，同时需要在 app 文件夹下新建 view 文件夹，放置页面文件。<br> 配置需要用的插件，在 config / plugin.js 中添加</p><pre><code>﻿exports.ejs = {    enable: true,    package: &apos;egg-view-ejs&apos;};// 使用 mysql 插件exports.mysql = {    enable: true,    package: &apos;egg-mysql&apos;,};</code></pre><p>开启插件，config.default.js 中增加</p><pre><code>﻿config.view = {    defaultViewEngine: &apos;ejs&apos;,    mapping: {        &apos;.html&apos;: &apos;ejs&apos;,    }，};// 设置 mysqlconfig.mysql = {    clients: {        // clientId, 获取 client 实例，需要通过 app.mysql.get(&apos;clientId&apos;) 获取        db: {            ...        }    },    // 是否加载到 app 上，默认开启    app: true,};</code></pre><p>﻿其中 defaultViewEngine 表示使用的模版，当然也可以使多种模版。mapping 设置的属性名表示 view 中文件的扩展名，属性值表示对应的模板；接下来就可以编写 controller 和 router 了。<br> 定义 controller，﻿在 controller 文件夹下的 home.js 中：</p><pre><code>﻿const Controller = require(&apos;egg&apos;).Controller;// eggjs 推荐使用类形式来定义class HomeController extends Controller {  async index() {      await this.ctx.render(&apos;site/home.html&apos;);  }}module.exports = HomeController;</code></pre><p>定义路 router，在 router.js 文件中：</p><pre><code>﻿module.exports = app =&gt; {    const { router, controller } = app;    router.get(&apos;/&apos;, controller.home.index);    router.get(&apos;/login&apos;, controller.login.index);};</code></pre><p>﻿Context 对象上提供了 3 个渲染模版的接口，返回值均为 Promise:</p><pre><code>﻿// render ：渲染模版文件，data 为传入模版的数据，并赋值给 ctx.bodyawait ctx.render(&apos;home/index.tpl&apos;, data);// renderView ：渲染模版文件，data 为传入模版的数据，需要主动赋值ctx.body = await ctx.renderView(&apos;path/to/file.tpl&apos;, data);// renderString ：渲染模版字符串，data 为传入模版的数据，需要主动赋值ctx.body = await ctx.renderString(&apos;hi, {{ name }}&apos;, data, {    // 需要指定模板引擎    viewEngine: &apos;nunjucks&apos;,});</code></pre><h2 id="内置基础对象扩展"><a href="#内置基础对象扩展" class="headerlink" title="内置基础对象扩展"></a>内置基础对象扩展</h2><p>框架包括从 Koa 继承而来的 4 个对象（ Application、Context、Request、Response )以及框架扩展的一些对象（ Controller、Service、Helper、Config、Logger ）。</p><h3 id="Application-扩展"><a href="#Application-扩展" class="headerlink" title="Application 扩展"></a>Application 扩展</h3><p>app 对象指的是 Koa 的全局应用对象，全局只有一个，在应用启动时被创建。在 Controller、Middleware、Helper、Service 中都可以通过<br>this.app 访问到 Application 对象。框架会把 app/extend/application.js 中定义的对象与 Koa Application 的 prototype 对象进行合并，在应用启动时会基于扩展后的 prototype 生成 app 对象。这样能在其他地方使用 Application 中扩展的方法。</p><pre><code>﻿// app/extend/application.jsmodule.exports = {  foo(params) {    // this 就是 app 对象，在其中可以调用 app 上的其他方法，或访问属性  },};</code></pre><h3 id="Context-扩展"><a href="#Context-扩展" class="headerlink" title="﻿Context 扩展"></a>﻿Context 扩展</h3><p>Context 指的是 Koa 的请求上下文，这是请求级别的对象，每次请求生成一个 Context 实例，通常我们也简写成 ctx。在所有的文档中，Context 和 ctx 都是指 Koa 的上下文对象。如下做的是对数据返回的扩展：</p><pre><code>﻿// app/extend/context.jsmodule.exports = {  returnJson(code,data,msg) {    // this 就是 ctx 对象，在其中可以调用 ctx 上的其他方法，或访问属性    this.body={code,data,msg};    return  }};在 controller 中就可以直接使用这个方法了async info() {    const userId = this.ctx.query.id;    const res = await this.ctx.service.getInfo(userId);    this.ctx.returnJson(0, res, &quot;请求成功&quot;);}</code></pre><h3 id="Request-和-Response-扩展"><a href="#Request-和-Response-扩展" class="headerlink" title="﻿Request 和 Response 扩展"></a>﻿Request 和 Response 扩展</h3><p> ﻿ctx 上的很多属性和方法都被代理到 request 和 response 对象上，对于这些属性和方法使用 ctx 和使用 request 去访问它们是等价的，例如 ctx.url === ctx.request.url、ctx.status === ctx.response.status 。<br> 框架会把 app/extend/request.js 中定义的对象与内置 request 的 prototype 对象进行合并，在处理请求时会基于扩展后的 prototype 生成 request 对象；Response 的扩展和 Request 相同。</p><pre><code>﻿// app/extend/request.jsmodule.exports = {  get foo() {    return this.get(&apos;request-foo&apos;);  },};// app/extend/response.jsmodule.exports = {  set bar(value) {    this.set(&apos;response-bar&apos;, value);  },};</code></pre><h3 id="Helper-扩展"><a href="#Helper-扩展" class="headerlink" title="﻿Helper 扩展"></a>﻿Helper 扩展</h3><p>﻿Helper 函数用来提供一些常用的方法或自定义的方法，可以将项目中用的多的函数封装在成对的函数，并且 Helper 对象可以在 ctx 对象里面访问到。</p><pre><code>﻿// app/extend/helper.jsmodule.exports = {  foo(param) {    // this 是 helper 对象，在其中可以调用其他 helper 方法    // this.ctx =&gt; context 对象    // this.app =&gt; application 对象  },};</code></pre><h2 id="service-服务层"><a href="#service-服务层" class="headerlink" title="﻿service 服务层"></a>﻿service 服务层</h2><p>﻿service 就是在复杂业务场景下用于做业务逻辑封装的一个抽象层，比如要展现的信息需要从数据库获取，还要经过一定的规则计算，才能返回用户显示。可以将数据逻辑的处理都放在 service 中</p><pre><code>﻿const Service = require(&apos;egg&apos;).Service;class UserService extends Service {  async find(uid) {    const user = await app.mysql.get(&apos;db&apos;).query(`select * from user where uid = ${uid}`);    return user;  }}module.exports = UserService;</code></pre><h2 id="Middleware-中间件"><a href="#Middleware-中间件" class="headerlink" title="﻿Middleware 中间件"></a>﻿Middleware 中间件</h2><p>﻿Egg 的中间件形式和 Koa 的中间件形式是一样的，都是基于洋葱圈模型。约定中间件是一个放置在 app/middleware 目录下的单独文件，它需要 exports 一个普通的 function，接受两个参数：</p><pre><code>options: 中间件的配置项，框架会将 app.config[${middlewareName}] 传递进来。app: 当前应用 Application 的实例。</code></pre><p>﻿定义一个中间件：</p><pre><code>﻿module.exports = (options,app) =&gt; {    return async function checkLogin() {        if(!(this.session &amp;&amp; this.session.userid)){            this.redirect(&apos;/login&apos;);            return;        };        // 刷新 session 时间        this.session.save();    };}</code></pre><p>﻿在应用中，我们可以完全通过配置来加载自定义的中间件，并决定它们的顺序。配置最终将在启动时合并到 app.config.appMiddleware 中。在 config.default.js 中配置如下：</p><pre><code>﻿// 配置需要的中间件，数组顺序即为中间件的加载顺序config.middleware= [&apos;checkLogin&apos;];// 配置 checkLogin 中间件的配置config.checkLogin= {    // 设置需要忽略检查的路径    ignore: &apos;/login&apos;};</code></pre><p> ﻿利用上述定义的中间件，如下是做的一个简单的登录</p><pre><code>﻿// router.jsmodule.exports = app =&gt; {    const { router, controller } = app;    router.get(&apos;/login&apos;, controller.login.index);    router.post(&apos;/login/vaild&apos;, controller.login.valid);    // 登陆后获取用户名    router.get(&apos;/user/admin&apos;, controller.login.userinfo);    // 退出登录    router.get(&apos;/logout&apos;, controller.login.logout);}// app/controller/login.jsmodule.exports = app =&gt; {    class LoginController extends app.Controller {        async index() {                await this.ctx.render(&apos;site/login.html&apos;);        }        async valid() {            const name = this.ctx.request.body.username;            const pwd = this.ctx.request.body.password;            if (!name || !pwd) {                // 1表示没有填写                this.ctx.returnJson(1,&apos;&apos;,&quot;请填写帐号和密码。&quot;)                return;            }            const user = await app.mysql.get(&apos;db&apos;).query(`select id,username  from user WHERE username= &apos;${name}&apos; AND password =&apos;${pwd}&apos;`);            if (user.length != 0) {                // 登录成功，下发 session                this.ctx.session.username = user[0].username;                this.ctx.session.userid = user[0].id;                // 设置过期时间为3小时                this.ctx.session.maxAge = 3 * 3600 * 1000;                // 调用 rotateCsrfSecret 刷新用户的 CSRF token                this.ctx.rotateCsrfSecret();                this.ctx.returnJson(0, &apos;&apos;, &quot;登录成功&quot;);            } else {                this.ctx.returnJson(2,&apos;&apos;,&quot;帐号或密码错误&quot;);            };        }        async userinfo() {            const uid = this.ctx.query.uid;            let user = await this.ctx.service.UserService.find(uid)            this.ctx.returnJson(0,user ,&quot;操作成功&quot;);        }        async logout() {            this.ctx.session = null;            this.ctx.redirect(&apos;/login&apos;);        }    }    return LoginController;};</code></pre><p>在这里面遇到一个坑就是通过 get 请求和 post 请求时，获取参数的方式不一样。</p><pre><code>* 在 get 请求中要通过 this.ctx.query 去获取参数；在 post 请求中是通过 this.ctx.request.body 去获取参数。</code></pre><p>﻿这些只是 Eggjs 的一小部分内容，框架还有很多扩展，插件，进程管理等等，接下来会通过自己的学习慢慢总结，有不对的地方还希望各位前辈指出。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍了 Egg.js 在项目中的使用以及框架的扩展。&lt;br&gt;
    
    </summary>
    
      <category term="guanxiaofeng" scheme="http://xgfe.github.io/categories/guanxiaofeng/"/>
    
    
      <category term="nodejs" scheme="http://xgfe.github.io/tags/nodejs/"/>
    
      <category term="Eggjs" scheme="http://xgfe.github.io/tags/Eggjs/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 WEB 缓存</title>
    <link href="http://xgfe.github.io/2018/05/07/zhangjihu/%E6%B5%85%E8%B0%88web%E7%BC%93%E5%AD%98/"/>
    <id>http://xgfe.github.io/2018/05/07/zhangjihu/浅谈web缓存/</id>
    <published>2018-05-06T16:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.264Z</updated>
    
    <content type="html"><![CDATA[<p>在 web 前端开发中，网页反应速度是判断一个网站的性能最重要的指标之一。一个优秀的缓存策略可以提高网页访问速度，减少延迟，减少带宽，降低网络负荷。下面我们就来梳理一下 Web 缓存的工作方式。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Web 缓存是指一个 Web 资源（如 html 页面，图片，js ，数据等）存在于 Web 服务器和客户端（浏览器）之间的副本。缓存根据进来的请求保存输出内容的副本，当再次请求的时候，如果是相同的URL，会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器发送请求。<br>Web 缓存机制的有多种，在这里主要探讨以浏览器为载体的 HTTP 缓存机制，希望对自己和大家都有所帮助。</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>浏览器缓存（ Brower Caching ）是浏览器在本地磁盘对用户最近请求过的文档进行存储，当访问者再次访问同一页面时，浏览器就可以直接从本地磁盘加载文档，浏览器缓存的优点：</p><ul><li>减少了冗余的数据传输，节省了网费</li><li>减少了服务器的负担，大大提升了网站的性能</li><li>加快了客户端加载网页的速度</li></ul><h2 id="缓存过程分析"><a href="#缓存过程分析" class="headerlink" title="缓存过程分析"></a>缓存过程分析</h2><p>浏览器与服务器通信的方式为应答模式，即：浏览器发起 HTTP 请求–服务器响应该请求。那么浏览器第一次向服务器发起该请求后拿到请求结果，会根据响应报文中 HTTP 头的缓存标识，决定是否缓存结果，是则将请求结果和缓存标识存入浏览器缓存中，简单的过程如下图：</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/fbbc80627083b6bbe7ecb9525a36189434504.webp" alt=""></p><p>由上图我们可以知道：</p><ul><li>浏览器每次发起请求，都会先在浏览器缓存中查找该请求的结果以及缓存标识</li><li>浏览器每次拿到返回的请求结果都会将该结果和缓存标识存入浏览器缓存中</li></ul><p>以上两点结论就是浏览器缓存机制的关键，它确保了每个请求的缓存存入与读取。</p><h2 id="浏览器缓存类型"><a href="#浏览器缓存类型" class="headerlink" title="浏览器缓存类型"></a>浏览器缓存类型</h2><p>我们根据是否需要向服务器重新发起 HTTP 请求将缓存过程分为两个部分：<strong>强制缓存</strong>和<strong>协商缓存</strong>。</p><h3 id="强制缓存"><a href="#强制缓存" class="headerlink" title="强制缓存"></a>强制缓存</h3><p>当浏览器向服务器发起请求时，服务器会将缓存规则放入 HTTP 响应报文的 HTTP 头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 Expires 和 Cache-Control ，<strong>其中 Cache-Control 优先级比 Expires 高</strong>。</p><h4 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h4><p>Expires 是 HTTP / 1.0 控制网页缓存的字段，其值为服务器返回该请求结果缓存的到期时间，即再次发起该请求时，如果客户端的时间小于 Expires 的值时，直接使用缓存结果。</p><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Expires 的 header ，如：</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/417893a96e4205a4c13acbc58941d25850878.png"></p><p>2、浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来（所以缓存命中的请求返回的 header 并不是来自服务器，而是来自之前缓存的 header ）；<br>3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，拿出它的 Expires 跟当前的请求时间比较，如果请求时间在 Expires 指定的时间之前，就能命中缓存，否则就不行。<br>4、如果缓存没有命中，浏览器直接向服务器发送请求，Expires Header 在重新加载的时候会被更新。<br>到了 HTTP / 1.1 ，Expire 已经被 Cache-Control 替代，原因在于 Expires 控制缓存的原理是使用客户端的时间与服务端返回的时间做对比，那么如果客户端与服务端的时间因为某些原因（例如时区不同；客户端和服务端有一方的时间不准确）发生误差，那么强制缓存则会直接失效，这样的话强制缓存的存在则毫无意义，那么 Cache-Control 又是如何控制的呢？</p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>在 HTTP / 1.1 中，Cache-Control 是最重要的规则，主要用于控制网页缓存，主要取值为：</p><ul><li>public：可以被所有的用户缓存，包括客户端和 CDN 等中间代理服务器，默认值</li><li>private：只能被客户端缓存，不允许 CDN 等中间代理服务器对其缓存，Cache-Control 的默认取值</li><li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li><li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存，每次请求该资源直接向服务器发送请求，每次都会下载完整的资源</li><li>max-age=xxx：（单位为 s ）：缓存内容将在 xxx 秒后失效，当浏览器向服务器发送请求后，在 max-age 这段时间里浏览器就不会再向服务器发送请求了</li><li>s-maxage=xxx：（单位为 s ）：同 max-age ，只用于共享缓存（比如 CDN 缓存），覆盖掉 max-age 和 Expires</li></ul><p>接下来，我们直接看一个例子，如下：</p><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 Cache-Control 的 header ；<br>2、浏览器在接收到这个资源后，会把这个资源连同所有 response header 一起缓存下来；<br>3、浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和 Cache-Control 设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/2f10fb6c2edd15f829d36330bee33b6b57447.png" alt=""></p><p>4、如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header 在重新加载的时候会被更新。</p><p>由上面的例子我们可以知道：</p><ul><li>HTTP 响应报文中 expires 的时间值，是一个绝对时间的GMT格式的时间字符串</li><li>HTTP 响应报文中 Cache-Control 为 max-age = 7200 ，是相对值，代表着资源的有效期</li></ul><p>由于 Cache-Control 的优先级比 expires ，那么直接根据 Cache-Control 的值进行缓存，意思就是说在 7200 秒内再次发起该请求，则会直接使用缓存结果，强制缓存生效。<br>注：在无法确定客户端的时间是否与服务端的时间同步的情况下， Cache-Control 相比于 expires 是更好的选择，所以同时存在时，只有 Cache-Control 生效。</p><h3 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h3><p>当浏览器对某个资源的请求没有命中强缓存，就会携带缓存标识向服务器发起请求，验证协商缓存是否命中，由服务器根据缓存标识决定是否使用缓存，如果协商缓存命中，请求响应返回的 http 状态为 304 。</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/165599b6e70d5fcc1258be192f6db41b36954.png" alt=""></p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/0416603a7ed8b6c6d8af6f548a6c570c26337.png" alt=""></p><p>查看单个请求的 ResponseHeader，也能看到 304 的状态码和 Not Modified 的字符串，只要看到这个就可说明这个资源是命中了协商缓存，然后从客户端缓存中加载的，而不是服务器最新的资源。</p><h4 id="主要有以下两种情况："><a href="#主要有以下两种情况：" class="headerlink" title="主要有以下两种情况："></a>主要有以下两种情况：</h4><p>协商缓存生效，返回 304 ，如下:</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/cac3ffaa672010fee74692465e9c17f021484.webp" alt=""></p><blockquote><p>304</p></blockquote><p>协商缓存失效，返回 200 和请求结果结果，如下:</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/76908dc6fb49340ad92d97ff2ed759ba22094.riff" alt=""></p><blockquote><p>200</p></blockquote><p>同样，协商缓存的标识也是在响应报文的 HTTP 头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：Last-Modified / If-Modified-Since 和 Etag / If-None-Match ，其中 Etag / If-None-Match 的优先级比 Last-Modified / If-Modified-Since 高。</p><h5 id="【-Last-Modified，If-Modified-Since-】"><a href="#【-Last-Modified，If-Modified-Since-】" class="headerlink" title="【 Last-Modified，If-Modified-Since 】:"></a>【 Last-Modified，If-Modified-Since 】:</h5><p>Last-Modified 是该资源文件最后一次更改时间，服务器会在 response header 里返回，同时浏览器会将这个值保存起来，在下一次发送请求时，放到 request header 里的 If-Modified-Since 里，服务器在接收到后也会做比对，如果相同则命中协商缓存，具体情况如下：</p><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 response 的 header 加上 Last-Modified 的 header，这个 header 表示这个资源在服务器上的最后修改时间：</p><p><img src="http://vfile.meituan.net/xgfe/d5788526358fd1f02278de827d0cc8f481865.png" alt=""></p><p>2、浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-Modified-Since 的 header，这个 header 的值就是上一次请求时返回的 Last-Modified 的值：</p><p><img src="http://vfile.meituan.net/xgfe/b150d289f5ec7c2921d175d4aad1dd8a81884.png" alt=""></p><p>3、服务器再次收到资源请求时，根据浏览器传过来 If-Modified-Since 和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回 304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容，状态码为 200。当服务器返回 304 Not Modified 的响应时，response header 中不会再添加 Last-Modified 的 header，因为既然资源没有变化，那么 Last-Modified 也就不会改变，这是服务器返回 304 时的 response header 。<br>4、浏览器收到 304 的响应后，就会从缓存中加载资源。<br>5、如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header 在重新加载的时候会被更新，下次请求时，If-Modified-Since 会启用上次返回的 Last-Modified 值。</p><h5 id="【-ETag-、If-None-Match-】"><a href="#【-ETag-、If-None-Match-】" class="headerlink" title="【 ETag 、If-None-Match 】:"></a>【 ETag 、If-None-Match 】:</h5><p>1、浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在 respone 的 header 加上 ETag 的 header ，这个 header 是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充 Last-Modified 的问题：</p><p><img src="http://vfile.meituan.net/xgfe/f8e13201a0acfa1c34a07f978ab8eb1560458.png" alt=""></p><p>2、浏览器再次跟服务器请求这个资源时，在 request 的 header 上加上 If-None-Match 的 header ，这个 header 的值就是上一次请求时返回的 ETag 的值：</p><p><img src="http://vfile.meituan.net/xgfe/b3ee027ffc12d12ee34cfdeaebff931f103431.png" alt=""></p><p>3、服务器再次收到资源请求时，根据浏览器传过来 If-None-Match 和然后再根据资源生成一个新的 ETag ，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回 304 Not Modified ，但是不会返回资源内容；如果有变化，就正常返回资源内容。与 Last-Modified 不一样的是，当服务器返回 304 Not Modified 的响应时，由于 ETag 重新生成过，response header 中还会把这个 ETag 返回，即使这个 ETag 跟之前的没有变化：<br>4、浏览器收到 304 的响应后，就会从缓存中加载资源。</p><h5 id="为什么要有-Etag"><a href="#为什么要有-Etag" class="headerlink" title="为什么要有 Etag"></a>为什么要有 Etag</h5><p>你可能会觉得使用 Last-Modified 已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要 Etag 呢？ HTTP 1.1 中 Etag 的出现主要是为了解决几个 Last-Modified 比较难解决的问题：<br>    • 一些文件也许会周期性的更改，但是他的内容并不改变（仅仅改变的修改时间），这个时候我们并不希望客户端认为这个文件被修改了，而重新 GET ；<br>    • 某些文件修改非常频繁，比如在秒以下的时间内进行修改，（比方说 1 s 内修改了 N 次），If-Modified-Since 能检查到的粒度是 s 级的，这种修改无法判断（或者说 UNIX 记录 MTIME 只能精确到秒）；<br>    • 某些服务器不能精确的得到文件的最后修改时间。<br>Last-Modified 与 ETag 是可以一起使用的，服务器会优先验证 ETag ，一致的情况下，才会继续比对 Last-Modified ，最后才决定是否返回 304 。</p><h3 id="强缓存与协商缓存的区别"><a href="#强缓存与协商缓存的区别" class="headerlink" title="强缓存与协商缓存的区别"></a>强缓存与协商缓存的区别</h3><p>强缓存与协商缓存的区别可以用下表来表示：</p><p><img src="http://vfile.meituan.net/xgfe/f0eb26fac54900ef2272f4c3e3e233ef20064.png" alt=""></p><p>强制缓存优先于协商缓存进行，若强制缓存（ Expires 和 Cache-Control ）生效则直接使用缓存，若不生效则进行协商缓存（ Last-Modified / If-Modified-Since 和 Etag / If-None-Match ），协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，重新获取请求结果，再存入浏览器缓存中；生效则返回 304 ，继续使用缓存。</p><h3 id="浏览器缓存过程"><a href="#浏览器缓存过程" class="headerlink" title="浏览器缓存过程"></a>浏览器缓存过程</h3><p>1、浏览器第一次加载资源，服务器返回 200，浏览器将资源文件从服务器上请求下载下来，并把 response header 及该请求的返回时间一并缓存；<br>2、下一次加载资源时，先比较当前时间和上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age ，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持 HTTP 1.1 ，则用 expires 判断是否过期）；如果时间过期，则向服务器发送 header 带有 If-None-Match 和 If-Modified-Since 的请求；<br>3、服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304 ；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200 ；<br>4、如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304 ；不一致则返回新的 last-modified 和文件并返回 200 ；</p><p><img width="600px" height="300px" src="http://vfile.meituan.net/xgfe/735836ddebf6bf03fb577902c88afd6925020.webp" alt=""></p><h3 id="用户行为对缓存的影响"><a href="#用户行为对缓存的影响" class="headerlink" title="用户行为对缓存的影响"></a>用户行为对缓存的影响</h3><p>地址栏访问，点击链接跳转是正常用户行为，将会触发浏览器缓存机制，浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容；<br>F5 刷新，浏览器会设置 max-age = 0，跳过强缓存判断，会进行协商缓存判断；<br>ctrl + F5 刷新，跳过强缓存和协商缓存，直接从服务器拉取资源。</p><p><img src="http://vfile.meituan.net/xgfe/72ef16289230d836b2027eb7f6a6845c27545.png" alt=""></p><h3 id="已经缓存的响应，如何更新或废弃？"><a href="#已经缓存的响应，如何更新或废弃？" class="headerlink" title="已经缓存的响应，如何更新或废弃？"></a>已经缓存的响应，如何更新或废弃？</h3><p>一般情况下，浏览器发出的所有 HTTP 请求会首先被路由到浏览器的缓存，以查看是否缓存了可以用于实现请求的有效响应。如果有匹配的响应，会直接从缓存中读取响应，这样就避免了网络延迟以及传输产生的数据成本。然而，如果我们希望更新或废弃已缓存的响应，该怎么办？<br>假设我们已经告诉访问者某个 CSS 样式表缓存长达 24 小时（ max-age = 86400 ），但是设计人员刚刚提交了一个更新，我们希望所有用户都能使用。我们该如何通知所有访问者缓存的 CSS 副本已过时，需要更新缓存？<br>实际上以前没有请求过该资源的新的用户会得到更新的资源，但是请求过资源的用户将在过期时间达到之前一直得到旧的被缓存的资源，直到他手动的去清理了浏览器的缓存。手动清理浏览器缓存这种事可能只有程序员才会做，那么我们要怎么做才能让用户得到更新后的资源呢？<br>其实很简单，我们可以在资源的内容更改后，更改资源的网址，强制用户下载新响应。比如在资源链接后添加参数：</p><p><img src="http://vfile.meituan.net/xgfe/29b12a26033d0eccff1a6d503ae8f9f674695.png" alt=""></p><p>（有兴趣的可以阅读：<a href="https://www.zhihu.com/question/20790576）" target="_blank" rel="noopener">https://www.zhihu.com/question/20790576）</a></p><h2 id="web-缓存作用"><a href="#web-缓存作用" class="headerlink" title="web 缓存作用"></a>web 缓存作用</h2><p>1、减少网络带宽消耗<br>无论对于网站运营者或者用户，带宽都代表着金钱，过多的带宽消耗，只会便宜了网络运营商。当 Web 缓存副本被使用时，只会产生极小的网络流量，可以有效的降低运营成本。</p><p>2、降低服务器压力<br>给网络资源设定有效期之后，用户可以重复使用本地的缓存，减少对源服务器的请求，间接降低服务器的压力。同时，搜索引擎的爬虫机器人也能根据过期机制降低爬取的频率，也能有效降低服务器的压力。</p><p>3、减少网络延迟，加快页面打开速度<br>缓存的使用能够明显加快页面打开速度，提高网页性能，达到更好的体验。</p><h2 id="其它-web-缓存机制"><a href="#其它-web-缓存机制" class="headerlink" title="其它 web 缓存机制"></a>其它 web 缓存机制</h2><p>1、数据库缓存<br>我们可能听说过 memcached ，它就是一种数据库层面的缓存方案。数据库缓存是指，当 web 应用的关系比较复杂，数据库中的表很多的时候，如果频繁进行数据库查询，很容易导致数据库不堪重荷。为了提供查询的性能，将查询后的数据放到内存中进行缓存，下次查询时，直接从内存缓存直接返回，提供响应效率。</p><p>2、CDN 缓存<br>CDN缓存一般是由网站管理员自己部署，为了让他们的网站更容易扩展并获得更好的性能。通常情况下，浏览器先向 CDN 网关发起 Web 请求，网关服务器后面对应着一台或多台负载均衡源服务器，会根据它们的负载请求，动态将请求转发到合适的源服务器上。从浏览器角度来看，整个 CDN 就是一个源服务器，从这个层面来说，浏览器和服务器之间的缓存机制，在这种架构下同样适用。</p><p>3、代理服务器缓存<br>代理服务器是浏览器和源服务器之间的中间服务器，浏览器先向这个中间服务器发起 Web 请求，经过处理后（比如权限验证，缓存匹配等），再将请求转发到源服务器。代理服务器缓存的运作原理跟浏览器的运作原理差不多，只是规模更大。</p><p>4、应用层缓存<br>应用层缓存是指我们在代码层面上做的缓存。通过代码逻辑，把曾经请求过的数据或资源等，缓存起来，再次需要数据时通过逻辑上的处理选择可用的缓存的数据。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>在前端开发中，浏览器缓存是 web 性能优化的重要方面，是提升 web 性能的一大利器，但是浏览器缓存如果使用不当，也会产生很多问题。所以对于缓存的应用需要综合考虑。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 web 前端开发中，网页反应速度是判断一个网站的性能最重要的指标之一。一个优秀的缓存策略可以提高网页访问速度，减少延迟，减少带宽，降低网络负荷。下面我们就来梳理一下 Web 缓存的工作方式。&lt;/p&gt;
    
    </summary>
    
      <category term="zhangjihu" scheme="http://xgfe.github.io/categories/zhangjihu/"/>
    
    
      <category term="缓存" scheme="http://xgfe.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="web 缓存" scheme="http://xgfe.github.io/tags/web-%E7%BC%93%E5%AD%98/"/>
    
      <category term="浏览器缓存" scheme="http://xgfe.github.io/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>redux,react-redux简单实现</title>
    <link href="http://xgfe.github.io/2018/05/01/wangpan/redux,react-redux%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xgfe.github.io/2018/05/01/wangpan/redux,react-redux简单实现/</id>
    <published>2018-04-30T16:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.258Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>redux解决了react只专注view层却没有涉及到的 代码结构 和组件通信的关键问题，本文主要目的是实现一个简单的redux和react-redux并且实现其middleware中间件机制。</p><a id="more"></a><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>在react项目中，如果你的UI层非常简单，没有很多的互动，那么redux是没有必要的。<br>redux是一个有用状态架构，所有的状态保存在一个对象中，对于大型的复杂应用， 代码结构和组件通信是极为关键的，而redux就是解决这两方面的问题。</p><h3 id="一、redux使用场景"><a href="#一、redux使用场景" class="headerlink" title="一、redux使用场景"></a>一、redux使用场景</h3><p><strong>适用redux的场景</strong>：</p><ul><li>用户的使用方式复杂</li><li>不同身份的用户有不同的使用方式（比如普通用户和管理员）</li><li>多个用户之间可以协作</li><li>与服务器大量交互，或者使用了WebSocket</li><li>View要从多个来源获取数据</li></ul><p><strong>从组件角度看</strong>:</p><ul><li>某个组件的状态，需要共享</li><li>某个状态需要在任何地方都可以拿到</li><li>一个组件需要改变全局状态</li><li>一个组件需要改变另一个组件的状态</li></ul><h3 id="二、redux常用API"><a href="#二、redux常用API" class="headerlink" title="二、redux常用API"></a>二、redux常用API</h3><ul><li>createStore<store>()    创建stroe 返回store对象</store></li><li>store.getState<state>() 返回state</state></li><li>store.subscribe()       订阅store</li><li>store.dispatch()        提交状态变更的申请</li></ul><h3 id="三、redux简单实现"><a href="#三、redux简单实现" class="headerlink" title="三、redux简单实现"></a>三、redux简单实现</h3><p>整体架构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span>(<span class="params">reducer</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> currentState = &#123;&#125;</span><br><span class="line">    <span class="keyword">let</span> currentListeners = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentState</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">subscirbe</span>(<span class="params">listener</span>) </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">action</span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 初始执行一次，获得初始化状态</span></span><br><span class="line">    dispatch(&#123; <span class="attr">type</span>: <span class="string">'@first_init@wangpan'</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getState, subscribe, dispatch</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindActionCreator</span> (<span class="params">creator, dispatch</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(creator(...args))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> bindAcitonCreators(creators, dispatch) &#123;</span><br><span class="line">    <span class="keyword">let</span> bound = &#123;&#125;</span><br><span class="line">    <span class="built_in">Object</span>.keys(creators).forEach(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">let</span> creator = creators[v]</span><br><span class="line">        bound[v] = bindActionCreator(creator, dispatch)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">return</span> bound</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>subcribe函数，传入监听函数，注意对参数校验，因为只是简单实现，我这就不写啦<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// subscribe订阅函数 传入listener函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">subscribe</span> (<span class="params">listenr</span>) </span>&#123;</span><br><span class="line">    currentListeners.push(listener)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>dispatch函数，传入action,同样可以对参数进行校验<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dispatch</span> (<span class="params">action</span>) </span>&#123;</span><br><span class="line">    currentState = reducer(currentState, aciton)</span><br><span class="line">    <span class="comment">// state改变，执行订阅函数，这就是一个最基本的发布者订阅者模式</span></span><br><span class="line">    currentListeners.forEach(<span class="function"><span class="params">v</span> =&gt;</span> v())</span><br><span class="line">    <span class="keyword">return</span> aciton</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以上一个最简单的redux就是实现了，现在暂且不实现redux中间件，下面我们看看react-redux实现</p><h3 id="四、react-redux简单实现"><a href="#四、react-redux简单实现" class="headerlink" title="四、react-redux简单实现"></a>四、react-redux简单实现</h3><p>在实现react-redux之前，先来看看react的context,这是实现react-redux的关键<br>在react父子组件通信是非常简单的，通过props就可以实现，但是在多层级的场景下通信通过props一层一层传递是非常麻烦而且不友好的,所以react提供context实现组件的跨多层级通信。</p><p>react-redux基本架构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Children &#125; <span class="keyword">from</span> <span class="string">'react'</span></span><br><span class="line"><span class="keyword">import</span> Proptypes <span class="keyword">from</span> <span class="string">'prop-types'</span></span><br><span class="line"><span class="keyword">import</span> &#123; bindAcitonCreators &#125; <span class="keyword">from</span> <span class="string">'redux'</span></span><br><span class="line"><span class="comment">// 负责链接组件，将redux中的数据放入组件</span></span><br><span class="line"><span class="comment">// 高阶组件</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> connect(mapStateToProps = <span class="function"><span class="params">state</span> =&gt;</span> state, mapDispatchToProps = &#123;&#125;) =&gt;<span class="function">(<span class="params">WrapComponent</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> contextTypes = &#123;</span><br><span class="line">            store: PropTpes.object</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">constructor</span> (props, context) &#123;</span><br><span class="line">            <span class="keyword">super</span>(props)</span><br><span class="line">            <span class="keyword">this</span>.state = &#123;</span><br><span class="line">                props: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        componentDidMount() &#123;</span><br><span class="line">            <span class="keyword">this</span>.update()</span><br><span class="line">            <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">            store.subscribe(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.update())</span><br><span class="line">            <span class="keyword">this</span>.update()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        update () &#123;</span><br><span class="line">            <span class="keyword">const</span> &#123; store &#125; = <span class="keyword">this</span>.context</span><br><span class="line">            <span class="keyword">const</span> stateProps = mapStateToProps(store.getState())</span><br><span class="line">            <span class="keyword">const</span> dispatchProps = bindAcitonCreators(mapDispatchToProps, store.dispatch)</span><br><span class="line">            <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">                props: &#123;</span><br><span class="line">                    ...this.state.props</span><br><span class="line">                    ...stateProps</span><br><span class="line">                    ...dispatchProps</span><br><span class="line">                    ...this.props</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        render() &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">WrapComponent</span> &#123;<span class="attr">...this.state.props</span>&#125; /&gt;</span></span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">// Provider组件，把strore放入context中，所有子元素可以直接去到store</span></span><br><span class="line"><span class="xml">export class Provider extends React.Component &#123;</span></span><br><span class="line"><span class="xml">    static childContextTypes = &#123;</span></span><br><span class="line"><span class="xml">        store: Proptypes.object</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    getchildContext () &#123;</span></span><br><span class="line"><span class="xml">        return &#123;</span></span><br><span class="line"><span class="xml">            store: this.store</span></span><br><span class="line"><span class="xml">        &#125;</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    constructor (props, context) &#123;</span></span><br><span class="line"><span class="xml">        super(props, context)</span></span><br><span class="line"><span class="xml">        this.store = props.store</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">    render () &#123;</span></span><br><span class="line"><span class="xml">        return Children.only(this.props.children)</span></span><br><span class="line"><span class="xml">    &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure></p><h3 id="五、中间件机制"><a href="#五、中间件机制" class="headerlink" title="五、中间件机制"></a>五、中间件机制</h3><p>在之前的redux基础上添加applyMiddleware函数，并且扩展crateStore函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">createStore</span> (<span class="params">reducer, enhancer</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 如果中间件存在</span></span><br><span class="line">    <span class="keyword">if</span> (enhancer) &#123;</span><br><span class="line">        <span class="keyword">return</span> enhancer(createStore)(reducer)</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">applyMiddleware</span>(<span class="params">middleware</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">createStore</span> =&gt;</span> (...args) =&gt; &#123;</span><br><span class="line">        <span class="keyword">const</span> store = createStore(...args)</span><br><span class="line">        <span class="keyword">const</span> dispatch = store.dispatch</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> midApi = &#123;</span><br><span class="line">            getState: store.getState,</span><br><span class="line">            dispatch: <span class="function">(<span class="params">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dispatch = middleware(midApi)(store, dispatch)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> &#123;</span><br><span class="line">            ...store,</span><br><span class="line">            dispatch</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="六、redux-thunk简单实现"><a href="#六、redux-thunk简单实现" class="headerlink" title="六、redux-thunk简单实现"></a>六、redux-thunk简单实现</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> thunk = <span class="function">(<span class="params">&#123;dispatch, getState&#125;</span>) =&gt;</span> next =&gt; <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> action === <span class="function"><span class="keyword">function</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> action(dispatch, getState)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next(action)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> thunk</span><br></pre></td></tr></table></figure><p>以上就基本实现了一个最简单的redux和react-redux</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;redux解决了react只专注view层却没有涉及到的 代码结构 和组件通信的关键问题，本文主要目的是实现一个简单的redux和react-redux并且实现其middleware中间件机制。&lt;/p&gt;
    
    </summary>
    
      <category term="wangpan" scheme="http://xgfe.github.io/categories/wangpan/"/>
    
    
      <category term="react" scheme="http://xgfe.github.io/tags/react/"/>
    
      <category term="redux" scheme="http://xgfe.github.io/tags/redux/"/>
    
  </entry>
  
  <entry>
    <title>动画库 Lottie 的使用</title>
    <link href="http://xgfe.github.io/2018/04/26/wangpeng/lottie_android/"/>
    <id>http://xgfe.github.io/2018/04/26/wangpeng/lottie_android/</id>
    <published>2018-04-26T08:26:00.000Z</published>
    <updated>2018-08-24T03:48:57.259Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要介绍动画开源库 Lottie 在 Android 中的使用。</p><a id="more"></a><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常APP开发中，为了提升用户感官舒适度等原因，我们会在APP中加入适量动画。<br>而传统手写动画方式往往存在诸多问题:</p><ul><li><p><strong>动画复杂而实现困难</strong></p></li><li><p><strong>图片素材占用体积过大</strong></p></li><li><p><strong>不同Native平台都需各自实现，开发成本高</strong></p></li><li><p><strong>不同Native平台实现的最终效果不一致</strong></p></li><li><p><strong>后期视觉联调差异化大</strong></p></li></ul><p><img src="http://p0.meituan.com/tuanpic/lottie_android_headache.jpeg" alt="">  </p><p><em>难道就没有一种简便且高效的方案来减缓或解决上述问题吗？</em></p><p>答: 有的，那就是本文要介绍的主角 <strong>Lottie</strong>。</p><h2 id="一、Lottie-是什么？"><a href="#一、Lottie-是什么？" class="headerlink" title="一、Lottie 是什么？"></a>一、Lottie 是什么？</h2><blockquote><p>Lottie是Airbnb开源的一个面向IOS、Android、React Native的动画库，可以解析用 Adobe After Effects 制作动画后通过 Bodymovin 插件导出的 Json 数据文件并在移动端原生渲染。</p></blockquote><p>通俗点说，它是一款动画开源库，通过解析特定的Json文件或Json文本，可直接在移动端上渲染出复杂的动画效果。</p><p><img src="http://p0.meituan.com/tuanpic/lottie_android_flow.png" alt="参考图释"></p><h2 id="二、Lottie-能干什么"><a href="#二、Lottie-能干什么" class="headerlink" title="二、Lottie 能干什么?"></a>二、Lottie 能干什么?</h2><p><strong>它可以简便高效的实现复杂动画，替代传统低效的手写动画方式。</strong> </p><p>动画展示:</p><p><img src="http://p0.meituan.com/tuanpic/lottie_android_example_4.gif" alt=""></p><p>上方的动画是通过Lottie直接实现的。</p><p>如果我们使用手写代码方式实现，可以说是很难！  </p><p>而通过 Lottie 实现时，需要的仅是一个Json文件或一段Json文本，并通过简洁的代码集成即可。</p><p>集成代码可能精简到如下模样:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.airbnb.lottie.LottieAnimationView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/animation_view"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_rawRes</span>=<span class="string">"@raw/anim_lottie"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_loop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_autoPlay</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="三、为什么使用-Lottie"><a href="#三、为什么使用-Lottie" class="headerlink" title="三、为什么使用 Lottie?"></a>三、为什么使用 Lottie?</h2><ul><li><p><strong>简便，开发成本低</strong><br>相对于传统方式，动画不再是全部手写，所需做得只是嵌入XML并配置动画属性，集成快，开发时间少，开发成本低。    </p></li><li><p><strong>不同 Native 平台效果基本一致</strong><br>渲染交由Lottie引擎内部实现，无需开发者处理平台差异，多平台共用同一个动画配置文件，效果一致性高。    </p></li><li><p><strong>占用包体积小</strong><br>Lottie配置文件由Json文本串构成，相对于图片，占用体积更小。</p></li><li><p><strong>动画效果不失真</strong><br>传统图片拉伸或压缩导致失真，而Lottie为矢量图展示，不会出现失真情况。</p></li><li><p><strong>动画效果可以云端控制</strong><br>由于Lottie动画基于Json文件或文本解析，因此可以实现云端下发，实现动态加载，动态控制动画样式。</p></li></ul><h2 id="四、如何使用-Lottie？"><a href="#四、如何使用-Lottie？" class="headerlink" title="四、如何使用 Lottie？"></a>四、如何使用 Lottie？</h2><p>Lottie 仅支持用 Gradle 构建配置，最低支持安卓版本 16。     </p><h3 id="1-添加依赖到-build-gradle"><a href="#1-添加依赖到-build-gradle" class="headerlink" title="1. 添加依赖到 build.gradle"></a>1. 添加依赖到 build.gradle</h3><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">'com.airbnb.android:lottie:2.5.4'</span></span><br><span class="line">&#125;</span><br><span class="line">或</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    implementation <span class="string">"com.airbnb.android:lottie:$&#123;全局版本变量&#125;"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-添加-Adobe-After-Effects-导出的动画-Json-文件"><a href="#2-添加-Adobe-After-Effects-导出的动画-Json-文件" class="headerlink" title="2. 添加 Adobe After Effects 导出的动画 Json 文件"></a>2. 添加 Adobe After Effects 导出的动画 Json 文件</h3><p>通常由视觉工程师确认动效后通过AE导出, 我们只需将该Json文件保存至 /raw 或 /assets文件夹下。  </p><h3 id="3-XML中嵌入基本布局"><a href="#3-XML中嵌入基本布局" class="headerlink" title="3. XML中嵌入基本布局"></a>3. XML中嵌入基本布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.airbnb.lottie.LottieAnimationView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/animation_view"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="4-加载播放动画，两类方式可选"><a href="#4-加载播放动画，两类方式可选" class="headerlink" title="4. 加载播放动画，两类方式可选"></a>4. 加载播放动画，两类方式可选</h3><h4 id="①-XML中静态配置-举例"><a href="#①-XML中静态配置-举例" class="headerlink" title="① XML中静态配置, 举例:"></a>① XML中静态配置, 举例:</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.airbnb.lottie.LottieAnimationView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">"@+id/animation_view"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>  </span></span><br><span class="line"><span class="tag">       </span></span><br><span class="line"><span class="tag">    //加载方式如下<span class="attr">2</span>种任选其一</span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_rawRes</span>=<span class="string">"@raw/hello_world"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_fileName</span>=<span class="string">"hello_world.json"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    //循环播放</span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_loop</span>=<span class="string">"true"</span></span></span><br><span class="line"><span class="tag">    //加载完毕后自动播放</span></span><br><span class="line"><span class="tag">    <span class="attr">app:lottie_autoPlay</span>=<span class="string">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure><h4 id="②-代码动态配置-举例"><a href="#②-代码动态配置-举例" class="headerlink" title="② 代码动态配置, 举例:"></a>② 代码动态配置, 举例:</h4><p><em>如下代码会在后台异步加载动画文件，并在加载完成后开始渲染动画。</em></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LottieAnimationView animationView = ...;</span><br><span class="line">animationView.setAnimation(R.raw.hello_world);</span><br><span class="line">animationView.loop(<span class="keyword">true</span>);</span><br><span class="line">animationView.playAnimation();</span><br></pre></td></tr></table></figure><h2 id="五、其他拓展使用"><a href="#五、其他拓展使用" class="headerlink" title="五、其他拓展使用"></a>五、其他拓展使用</h2><h3 id="1-直接解析Json文本串加载动画"><a href="#1-直接解析Json文本串加载动画" class="headerlink" title="1. 直接解析Json文本串加载动画"></a>1. 直接解析Json文本串加载动画</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">JsonReader jsonReader = <span class="keyword">new</span> JsonReader(<span class="keyword">new</span> StringReader(jsonStr));</span><br><span class="line">lottieView.setAnimation(jsonReader);</span><br><span class="line">lottieView.playAnimation();</span><br><span class="line">或</span><br><span class="line">Cancellable cancellable = LottieComposition.Factory.fromJsonString(jsonStr, composition -&gt; &#123;</span><br><span class="line">            lottieView.setComposition(composition);</span><br><span class="line">            lottieView.playAnimation();</span><br><span class="line">        &#125;);</span><br><span class="line"><span class="comment">//必要时取消进行中的异步操作</span></span><br><span class="line">cancellable.cancel();</span><br></pre></td></tr></table></figure><h3 id="2-配合网络下载，实现下载Json配置并动态加载"><a href="#2-配合网络下载，实现下载Json配置并动态加载" class="headerlink" title="2. 配合网络下载，实现下载Json配置并动态加载"></a>2. 配合网络下载，实现下载Json配置并动态加载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;ResponseBody&gt; call = RetrofitComponent.fetchLottieConfig();<span class="comment">//伪代码</span></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback&lt;ResponseBody&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call&lt;ResponseBody&gt; call, Response&lt;ResponseBody&gt; response)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//String json = response.body().string();</span></span><br><span class="line">                <span class="comment">//交由Lottie处理...</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call&lt;ResponseBody&gt; call, Throwable t)</span> </span>&#123;</span><br><span class="line">                <span class="comment">//do something.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="3-动画加载监听器"><a href="#3-动画加载监听器" class="headerlink" title="3. 动画加载监听器"></a>3. 动画加载监听器</h3><p>根据业务需要进行动画过程监听:    </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">animationView.addAnimatorUpdateListener((animation) -&gt; &#123;</span><br><span class="line">    <span class="comment">// do something.</span></span><br><span class="line">&#125;);</span><br><span class="line">animationView.playAnimation();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">if</span> (animationView.isAnimating()) &#123;</span><br><span class="line"><span class="comment">// do something.</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">animationView.setProgress(<span class="number">0.5f</span>);</span><br><span class="line">...</span><br></pre></td></tr></table></figure><h3 id="4-LottieDrawable-的使用"><a href="#4-LottieDrawable-的使用" class="headerlink" title="4. LottieDrawable 的使用"></a>4. LottieDrawable 的使用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">LottieDrawable drawable = <span class="keyword">new</span> LottieDrawable();</span><br><span class="line">LottieComposition.Factory.fromAssetFileName(getApplicationContext(), <span class="string">"lottie_pin_jump.json"</span>, composition -&gt; &#123;</span><br><span class="line">            drawable.setComposition(composition);</span><br><span class="line">            <span class="comment">//目前显示为静态图</span></span><br><span class="line">            ivLottie.setImageDrawable(drawable);</span><br><span class="line">            <span class="comment">//调用start()开始播放动画</span></span><br><span class="line">            drawable.start();</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure><h3 id="5-更多使用可参考文末官方链接"><a href="#5-更多使用可参考文末官方链接" class="headerlink" title="5. 更多使用可参考文末官方链接"></a>5. 更多使用可参考文末官方链接</h3><h2 id="六、需要考虑的问题"><a href="#六、需要考虑的问题" class="headerlink" title="六、需要考虑的问题"></a>六、需要考虑的问题</h2><ol><li>由于是依赖于AE做的动画，估计以后不只是要求视觉设计师精通AE，连前端开发都需要了解AE  </li><li>Lottie 对 Json 文件的支持待完善，目前存在部分AE导出成 Json 文件无法渲染或渲染不佳</li><li>支持的功能存在限制，可参考 <a href="http://airbnb.io/lottie/supported-features.html" target="_blank" rel="noopener">功能支持列表</a>。</li></ol><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>尽管Lottie还存在诸多小问题，但它所带来的效率提升绝对是传统开发方式无法比拟的。我们要做的是正确善用它。</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://airbnb.io/lottie/android/android.html" target="_blank" rel="noopener">官网网址</a><br><a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">Github地址</a><br><a href="https://github.com/airbnb/lottie-android/tree/master/LottieSample/src/main/assets" target="_blank" rel="noopener">测试用Json文件</a><br><a href="https://github.com/bigxixi/lottie-android" target="_blank" rel="noopener">项目中文翻译版 (略有差异)</a>  </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要介绍动画开源库 Lottie 在 Android 中的使用。&lt;/p&gt;
    
    </summary>
    
      <category term="w.p" scheme="http://xgfe.github.io/categories/w-p/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="animation" scheme="http://xgfe.github.io/tags/animation/"/>
    
      <category term="lottie" scheme="http://xgfe.github.io/tags/lottie/"/>
    
  </entry>
  
  <entry>
    <title>实现React国际化</title>
    <link href="http://xgfe.github.io/2018/04/26/jiangxiang/internationalize-your-react-project/"/>
    <id>http://xgfe.github.io/2018/04/26/jiangxiang/internationalize-your-react-project/</id>
    <published>2018-04-26T07:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.242Z</updated>
    
    <content type="html"><![CDATA[<p> React 最早由 Facebook 的软件工程师 Jordan Walke 创建，它在 2011 年首次部署在 Facebook 的新闻源中，由于其性能优势明显，很快获得了广泛关注和大规模的使用，如今发展已经非常成熟。<br>基于 React 的渲染原理可以实现很多有意思的功能，例如实现一个 React 的国际化工具。(React v16.3)</p><a id="more"></a><h2 id="一、现状"><a href="#一、现状" class="headerlink" title="一、现状"></a>一、现状</h2><h3 id="1-1-目前-React-国际化常用的解决方案："><a href="#1-1-目前-React-国际化常用的解决方案：" class="headerlink" title="1.1 目前 React 国际化常用的解决方案："></a>1.1 目前 React 国际化常用的解决方案：</h3><ol><li>打包时翻译</li><li>动态翻译</li><li>生成多个版本</li></ol><p>比较流行的为 webpack 团队基于打包时翻译的 webpack-i18n-plugin 和 yahoo 团队基于动态翻译的 React-intl</p><h3 id="1-2-对比"><a href="#1-2-对比" class="headerlink" title="1.2 对比"></a>1.2 对比</h3><ol><li>打包时翻译<br>优点：方案比较成熟，已有成功案例（如很多资讯网站、博客，如 mdn ）<br>缺点：翻译表一旦更新，需要重新打包发布，本地要维护大量的翻译表文件，过于繁琐</li><li>动态翻译<br>优点：灵活，翻译表放进 cdn 一句 sql 可以更新，可操作性强<br>缺点：兼容性有待考察，对于不同的项目结构要设置特有的配置</li><li>多版本<br>优点：产生的打包文件最小，无需配置<br>缺点：修改过程复杂，应用场景不广泛</li></ol><h2 id="二、大概的设想"><a href="#二、大概的设想" class="headerlink" title="二、大概的设想"></a>二、大概的设想</h2><h3 id="3-1-翻译语法"><a href="#3-1-翻译语法" class="headerlink" title="3.1 翻译语法"></a>3.1 翻译语法</h3><p>语法分为批量翻译或指定单句不翻译<br>具体通过<code>&lt;Provider/&gt;</code>类以及属性 no-translate 实现<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 批量翻译</span><br><span class="line">&lt;Provider value=&#123;&#123;</span><br><span class="line">    languageMap, // 语言包</span><br><span class="line">    language, // 语言类型</span><br><span class="line">&#125;&#125;&gt;</span><br><span class="line">    ... (要翻译的代码块)</span><br><span class="line">&lt;/Provider&gt;</span><br><span class="line">// 指定不翻译</span><br><span class="line">&lt;div no-translate&gt;...(不翻译的字符串)&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-方便获取在线的语言包"><a href="#3-2-方便获取在线的语言包" class="headerlink" title="3.2 方便获取在线的语言包"></a>3.2 方便获取在线的语言包</h3><p>可以通过请求获得在线语言包，在下载完成后进行更新</p><h2 id="三、核心思路"><a href="#三、核心思路" class="headerlink" title="三、核心思路"></a>三、核心思路</h2><p>实现多语言通俗来说就是：</p><ol><li>先找到要翻译的文字</li><li>请求在线语言包</li><li>再对要翻译的文字进行翻译</li></ol><p>基于以上基本思路再思考，我们都知道， JSX 是 react 的语法糖，而使用高阶函数<code>React.createElement</code>可以重新定义组件的渲染，我们只需要将要翻译的文字在该方法中处理即可。</p><p>以下两种写法经 babel 转义，本质上没有区别！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Hello extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return React.createElement(&apos;div&apos;, null, `Hello $&#123;this.props.toWhat&#125;`);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  React.createElement(Hello, &#123;toWhat: &apos;World&apos;&#125;, null),</span><br><span class="line">  document.getElementById(&apos;root&apos;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>基于这个想法，通过设置 no-translate 属性，<code>&lt;Provider/&gt;</code>，并在<code>createElement</code>中判断，就知道哪里的文字需要翻译，也知道要翻译成哪种语言了（第一步）！</li><li>(第二步比较简单，暂时忽略…)</li><li>再定义一个<code>translate</code>函数，接受文字，语言包和翻译表，返回翻译后的文字（第三步）</li></ul><p>下面的流程图展示了整体的思路：</p><p><img src="http://vfile.meituan.net/xgfe/2f1f2dac01553645441f63da880b712937156.png" alt=""></p><h2 id="四、实现"><a href="#四、实现" class="headerlink" title="四、实现"></a>四、实现</h2><p>毕竟是要做一个工具库，首先新建一个工程，在 core 文件目录下创建具体文件</p><h3 id="4-1-定义一个-languageMap"><a href="#4-1-定义一个-languageMap" class="headerlink" title="4.1 定义一个 languageMap"></a>4.1 定义一个 languageMap</h3><p> languageMap 一定得是单例模式，方便全局调用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// file: ./core/languageMap.js</span><br><span class="line">const translateMap = &#123;&#125;;</span><br><span class="line">export default translateMap;</span><br></pre></td></tr></table></figure></p><h3 id="4-2-再写一个translate函数"><a href="#4-2-再写一个translate函数" class="headerlink" title="4.2 再写一个translate函数"></a>4.2 再写一个translate函数</h3><p>任何需要翻译的地方，都将会使用这个<code>translate</code>函数，它接受三个参数：</p><ul><li>content：要翻译的文字</li><li>languageMap：语言包</li><li>language：语言类型</li></ul><p>设置 middleware 作为中间件，可以操作翻译前后的字段，可以解决一些兼容性问题，或者实现一些彩蛋的效果…</p><p>代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">// file: ./core/translate.js</span><br><span class="line">const middleware = &#123;</span><br><span class="line">  merge: function(obj) &#123;</span><br><span class="line">    Object.keys(obj).forEach(function(key) &#123;</span><br><span class="line">      if (key !== &quot;merge&quot;) &#123;</span><br><span class="line">        middleware[key] = obj[key];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">const translate = (content, languageMap, language) =&gt; &#123;</span><br><span class="line">  if (!content) &#123;</span><br><span class="line">    return &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  if (!language) &#123;</span><br><span class="line">    throw new Error(&quot;you should define specific language type!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">  // beforeRender middleware</span><br><span class="line">  if (middleware.beforeRender) content = middleware.beforeRender(content);</span><br><span class="line">  // translate words</span><br><span class="line">  if (language &amp;&amp; languageMap &amp;&amp; languageMap[language]) &#123;</span><br><span class="line">    languageMap[language][content] &amp;&amp;</span><br><span class="line">      (content = languageMap[language][content]);</span><br><span class="line">  &#125;</span><br><span class="line">  // afterRender middleware</span><br><span class="line">  if (middleware.afterRender) content = middleware.afterRender(content);</span><br><span class="line">  return content;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="4-3-再创建-translateClass"><a href="#4-3-再创建-translateClass" class="headerlink" title="4.3 再创建 translateClass"></a>4.3 再创建 translateClass</h3><p>为了使用Context API，我们需要一个辅助类来接受<code>&lt;Provider/&gt;</code>传过来的 languageMap 和 language 等字段</p><p>先创建一个./core/context.js<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">export const &#123; Provider, Consumer &#125; = React.createContext();</span><br></pre></td></tr></table></figure></p><p>在创建一个./core/translateClass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// file: ./core/translateClass.jsx</span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">import &#123; translate &#125; from &quot;./translate&quot;;</span><br><span class="line">import &#123; Consumer &#125; from &quot;./context&quot;;</span><br><span class="line"></span><br><span class="line">class Translate extends React.Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    const noTranslate = this.props[&quot;no-translate&quot;];</span><br><span class="line">    return (</span><br><span class="line">      &lt;Consumer&gt;</span><br><span class="line">        &#123;context =&gt;</span><br><span class="line">          noTranslate</span><br><span class="line">            ? this.props.children</span><br><span class="line">            : translate(</span><br><span class="line">                this.props.children,</span><br><span class="line">                context.languageMap,</span><br><span class="line">                context.language</span><br><span class="line">              )</span><br><span class="line">        &#125;</span><br><span class="line">      &lt;/Consumer&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default Translate;</span><br></pre></td></tr></table></figure></p><h3 id="4-4-改写-createElement"><a href="#4-4-改写-createElement" class="headerlink" title="4.4 改写 createElement"></a>4.4 改写 createElement</h3><p>有了之前的铺垫，可以很快的实现我们自己的<code>createElement</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">// file: ./core/translateTag.jsx</span><br><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import Translate from &quot;./translateClass&quot;;</span><br><span class="line"></span><br><span class="line">const createElement = React.createElement;</span><br><span class="line"></span><br><span class="line">React.createElement = (...args) =&gt; &#123;</span><br><span class="line">  let children = args.slice(2);</span><br><span class="line"></span><br><span class="line">  // ① console.log(args)</span><br><span class="line">  children = children.map(child =&gt; &#123;</span><br><span class="line">    if (typeof args[0] === &quot;string&quot; &amp;&amp; typeof child === &quot;string&quot;) &#123;</span><br><span class="line">      if (args[1] &amp;&amp; args[1][&quot;no-translate&quot;]) &#123;</span><br><span class="line">        return &lt;Translate no-translate&gt;&#123;child&#125;&lt;/Translate&gt;;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return &lt;Translate&gt;&#123;child&#125;&lt;/Translate&gt;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return child;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  return createElement(args[0], args[1], ...children);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>在标志①处打印 args 可以看到 ReactDom 的结构，它包含了$$typeof,props,ref,children等属性， $$typeof 代表组件类型， props 是属性， children 是子节点的若干元素，将其 children 获取到，进行如下判断：</p><ol><li>如果类型是 Object 就不做任何操作</li><li>如果 child 类型是字符串就进行翻译</li><li>如带有 no-translate 属性将不对其进行翻译</li></ol><p>通过改变<code>&lt;Provider/&gt;</code>的位置，可以设置不同区块的 context ，这样可以改变不同区块的翻译表和语言类型</p><p>到这里， translate 工具类基本完成</p><h2 id="五、进行测试"><a href="#五、进行测试" class="headerlink" title="五、进行测试"></a>五、进行测试</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &quot;react&quot;;</span><br><span class="line">import ReactDom from &quot;react-dom&quot;;</span><br><span class="line">import languageMap from &quot;./core/languageMap&quot;;</span><br><span class="line">import &#123; translate, middleware &#125; from &quot;./core/translate&quot;;</span><br><span class="line">import &#123; Provider &#125; from &quot;./core/context&quot;;</span><br><span class="line">// 全局更新createElement</span><br><span class="line">import &quot;./core/translateTag.jsx&quot;;</span><br><span class="line"></span><br><span class="line">const styles = &#123;</span><br><span class="line">  fontFamily: &quot;sans-serif&quot;,</span><br><span class="line">  textAlign: &quot;center&quot;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    super(...args);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillMount() &#123;</span><br><span class="line">    this.fetchTranslateList();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fetchTranslateList() &#123;</span><br><span class="line">    languageMap[&quot;en&quot;] = &#123;</span><br><span class="line">      你好: &quot;Hello&quot;,</span><br><span class="line">      国际化: &quot;intl&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">    languageMap[&quot;france&quot;] = &#123;</span><br><span class="line">      你好: &quot;Bonjour&quot;,</span><br><span class="line">      国际化: &quot;intl&quot;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const enConfig = &#123; language: &quot;en&quot;, languageMap &#125;;</span><br><span class="line">    const franceConfig = &#123; language: &quot;france&quot;, languageMap &#125;;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div style=&#123;styles&#125;&gt;</span><br><span class="line">        &lt;Provider value=&#123;enConfig&#125;&gt;</span><br><span class="line">          &lt;div&gt;</span><br><span class="line">            &lt;h1&gt;你好&lt;/h1&gt;</span><br><span class="line">            &lt;span&gt;</span><br><span class="line">              你好</span><br><span class="line">              &lt;Provider value=&#123;franceConfig&#125;&gt;</span><br><span class="line">                &lt;h1 no-translate&gt;</span><br><span class="line">                  你好</span><br><span class="line">                  &lt;div&gt;国际化&lt;/div&gt;</span><br><span class="line">                &lt;/h1&gt;</span><br><span class="line">                &lt;span&gt;国际化&lt;/span&gt;</span><br><span class="line">              &lt;/Provider&gt;</span><br><span class="line">            &lt;/span&gt;</span><br><span class="line">          &lt;/div&gt;</span><br><span class="line">        &lt;/Provider&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDom.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  document.body.appendChild(document.createElement(&quot;div&quot;))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>以上代码，我们创建了一个入口文件，分别将中文翻译成了英文和法文，最终运行正常！</p><h2 id="六、兼容性"><a href="#六、兼容性" class="headerlink" title="六、兼容性"></a>六、兼容性</h2><p>写这个工具的初衷当然是无缝兼容各种 react 项目，但事实上并不简单<br>举例来说，目前出现的很多的前端组件库与这个工具有很多兼容性冲突，这些库主要有：</p><ol><li>ant-design/ant-mobile（蚂蚁金服团队的前端UI组件库，链接：<a href="https://ant.design/index-cn）" target="_blank" rel="noopener">https://ant.design/index-cn）</a></li><li>element-react（饿了么团队的前端UI组件库react版本，链接：<a href="https://eleme.github.io/element-react/）" target="_blank" rel="noopener">https://eleme.github.io/element-react/）</a></li></ol><p>实际操作中发现了不兼容的问题很多，想必要做到开箱即用是不可能了~~~<br>寄希望于无缝兼容，不如提供中间件接口来让使用者自行配置 o(╥﹏╥)o</p><h3 id="6-1-ant-design"><a href="#6-1-ant-design" class="headerlink" title="6.1 ant-design"></a>6.1 ant-design</h3><p>例如，在 ant-design 组件库中，<code>&lt;input/&gt;</code>的 placeholder 属性，如不进行检测，将不会被翻译</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import &#123;filter&#125; from &apos;./core/translate.js&apos;;</span><br><span class="line"></span><br><span class="line">filter.forAntDesign = (props,language) =&gt; &#123;</span><br><span class="line">    let props = Object.assign(&#123;&#125;, props);</span><br><span class="line">            if (language &amp;&amp; props.placeholder) &#123;</span><br><span class="line">                if (languageMap[language]) &#123;</span><br><span class="line">                    if (/[^\u4e00-\u9fa5]/g.test(props.placeholder)) &#123;</span><br><span class="line">                        props.placeholder = props.placeholder.replace(/([\u4e00-\u9fa5]+)/g, (match) =&gt; &#123;</span><br><span class="line">                            return languageMap[language][match] ? languageMap[language][match] : match</span><br><span class="line">                        &#125;)</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        languageMap[language][props.placeholder] &amp;&amp; (props.placeholder = languageMap[language][props.placeholder]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            return &lt;input</span><br><span class="line">                &#123;...props&#125;</span><br><span class="line">                ref=&quot;input&quot;</span><br><span class="line">                onInput=&#123;e =&gt; &#123;this.value = e.target.value; this.props.onInput &amp;&amp; this.props.onInput(e);&#125;&#125;&gt;</span><br><span class="line">                &#123;this.props.children&#125;</span><br><span class="line">            &lt;/input&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过如上对 placeholder 的过滤操作，可以实现 ant-design 输入框的多语言翻译。<br>再如，<code>&lt;Select/&gt;</code>组件，它约定元素 option 的属性 value 强等于内容 children 时才认为当前选项是被选中，解决办法这里不再赘述，它们都可以通过增加中间件，修改<code>props.children</code>的过滤机制进而解决！</p><h3 id="6-2-其他react组件库"><a href="#6-2-其他react组件库" class="headerlink" title="6.2 其他react组件库"></a>6.2 其他react组件库</h3><p>也有一些框架或者自行编写的组件，如 element-react ，一些 dom 文字并不会放在 text 中，更确切地说其组件内部进行了重构，并不会将文字简单的向外展示，这就需要额外的编写特殊的 filter 了</p><h2 id="七、总结"><a href="#七、总结" class="headerlink" title="七、总结"></a>七、总结</h2><p>到这里，我们的 React 国际化工具已经实现了，这里是一个简单的在线 demo</p><iframe src="https://codesandbox.io/embed/64zx97v9qr" style="width:100%; height:500px; border:0; border-radius: 4px; overflow:hidden;" sandbox="allow-modals allow-forms allow-popups allow-scripts allow-same-origin"></iframe><ul><li>完整代码参考 github: <a href="https://github.com/ranrantu/react-i18" target="_blank" rel="noopener">https://github.com/ranrantu/react-i18</a></li></ul><p>总之，这可以说是 React 动态翻译的一种思路，这种实现至今还是有不足的地方，还请各位拍砖指正，感谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt; React 最早由 Facebook 的软件工程师 Jordan Walke 创建，它在 2011 年首次部署在 Facebook 的新闻源中，由于其性能优势明显，很快获得了广泛关注和大规模的使用，如今发展已经非常成熟。&lt;br&gt;基于 React 的渲染原理可以实现很多有意思的功能，例如实现一个 React 的国际化工具。(React v16.3)&lt;/p&gt;
    
    </summary>
    
      <category term="jiangxiang" scheme="http://xgfe.github.io/categories/jiangxiang/"/>
    
    
      <category term="React" scheme="http://xgfe.github.io/tags/React/"/>
    
      <category term="国际化" scheme="http://xgfe.github.io/tags/%E5%9B%BD%E9%99%85%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>web前端性能优化</title>
    <link href="http://xgfe.github.io/2018/04/15/zhangjianfeng/web%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>http://xgfe.github.io/2018/04/15/zhangjianfeng/web前端性能优化/</id>
    <published>2018-04-15T07:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.264Z</updated>
    
    <content type="html"><![CDATA[<p>在构建web站点的过程中，任何一个细节都有可能影响网站的访问速度，如果不了解性能优化知识，很多不利网站访问速度的因素会形成累加，从而严重影响网站的性能，导致网站访问速度变慢，用户体验低下，最终导致用户流失。本文主要围绕以下几点讲解：</p><ol><li>客户端请求</li><li>客户端渲染</li><li>服务端响应</li><li>网络<a id="more"></a></li></ol><h2 id="客户端请求"><a href="#客户端请求" class="headerlink" title="客户端请求"></a>客户端请求</h2><p>每个请求都是有成本的，既包含时间成本也包含资源成本。一个完整的请求都需要经过 DNS寻址、与服务器建立连接、发送数据、等待服务器响应、接收数据这样一个 “漫长” 而复杂的过程。时间成本就是用户需要看到或者 “感受” 到这个资源是必须要等待这个过程结束的，资源上由于每个请求都需要携带数据，因此每个请求都需要占用带宽。另外，由于浏览器进行并发请求的请求数是有上限的，因此请求数多了以后，浏览器需要分批进行请求，因此会增加用户的等待时间，会给用户造成站点速度慢这样一个印象。</p><h3 id="资源压缩与合并"><a href="#资源压缩与合并" class="headerlink" title="资源压缩与合并"></a>资源压缩与合并</h3><p>压缩可以减少资源的体积，从而增加加载速度。将资源文件合并，减少资源的请求数。但并不意味着，一个资源越大越好，资源太大，会影响资源加载速度。针对这一问题，利用webpack模块化打包工具分块打包、按需加载以及提取公共部分代码，利用缓存可以得到解决。具体可参考<a href="http://mp.weixin.qq.com/s/BVYgLeOEIJp5xY55Rcrszg" target="_blank" rel="noopener">webpack的使用</a>。</p><h3 id="DNS预解析"><a href="#DNS预解析" class="headerlink" title="DNS预解析"></a>DNS预解析</h3><p>从用户输入一个网址到网页最终展现到用户面前，中间的大致发生以下几个流程：</p><ol><li>发送到DNS（域名服务器）获得域名对应的WEB服务器的IP地址。</li><li>客户端浏览器与WEB服务器建立TCP（传输控制协议）连接。</li><li>客户端浏览器向对应IP地址的WEB服务器发送相应的HTTP或HTTPS请求。</li><li>WEB服务器响应请求，返回指定的URL数据或错误信息；如果设定重定向，则重定向到新的URL地址。</li><li>客户端浏览器下载数据，解析HTML源文件，解析的过程中实现对页面的排版，解析完成后，在浏览器中显示基础的页面。</li><li>分析页面中的超链接，显示在当前页面，重复以上过程直至没有超链接需要发送，完成页面的全部显示。<br>DNS解析时间可能导致大量用户感知延迟，DNS解析所需的时间差异非常大，延迟范围可以从1ms（本地缓存结果）到普遍的几秒钟时间。所以利用DNS预解析是有意义的。<br>具体实现方式：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"dns-prefetch"</span> href=<span class="string">"hostname"</span> /&gt;</span><br></pre></td></tr></table></figure></li></ol><h3 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h3><p>预加载是一种浏览器机制，使用浏览器空闲时间来预先下载/加载用户接下来很可能会浏览的页面/资源。页面提供给浏览器需要预加载的集合。浏览器载入当前页面完成后，将会在后台下载需要预加载的页面并添加到缓存中。当用户访问某个预加载的链接时，如果从缓存命中，页面就得以快速呈现。 实现方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 页面，可以使用绝对或者相对路径</span></span><br><span class="line">&lt;link rel=<span class="string">"prefetch"</span> href=<span class="string">"page2.html"</span> /&gt; </span><br><span class="line"><span class="comment">// 图片，也可以是其他类型的文件</span></span><br><span class="line">&lt;link rel=<span class="string">"prefetch"</span> href=<span class="string">"sprite.png"</span> /&gt;</span><br></pre></td></tr></table></figure></p><p>从上面的HTML代码可以看出，预加载使用 <link> 标签，并指定 rel=”prefetch” 属性，而href属性就是需要预加载的文件路径。</p><h3 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h3><p>一个页面有很多图片，而首屏出现的图片大概就一两张，如果一次性把所有图片都加载出来，不仅影响页面渲染速度，还浪费带宽。这也就是们通常所说的首屏加载，其中要用的技术就是图片懒加载–到可视区域再加载。简单实现如下：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">lazyload</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 获取所有要进行懒加载的图片</span></span><br><span class="line">    <span class="keyword">var</span> eles = <span class="built_in">document</span>.querySelectorAll(<span class="string">'img[data-original][lazyload]'</span>);</span><br><span class="line">    <span class="keyword">var</span> viewHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line">    eles.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">item, index</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> rect;</span><br><span class="line">        <span class="keyword">if</span> (item.dataset.original === <span class="string">''</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rect = item.getBoundingClientRect();</span><br><span class="line">        <span class="comment">// 图片一进入可视区，动态加载</span></span><br><span class="line">        <span class="keyword">if</span> (rect.bottom &gt;= <span class="number">0</span> &amp;&amp; rect.top &lt; viewHeight) &#123;</span><br><span class="line">            item.src = item.dataset.original;</span><br><span class="line">            item.removeAttribute(<span class="string">'data-original'</span>);</span><br><span class="line">            item.removeAttribute(<span class="string">'lazyload'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="CSS-Sprites"><a href="#CSS-Sprites" class="headerlink" title="CSS Sprites"></a>CSS Sprites</h3><p>合并 CSS图片，也就是通过将多个图片或者icon放在一张图片中，利用css的background-position属性控制每个图片或icon的位置。</p><h2 id="客户端渲染"><a href="#客户端渲染" class="headerlink" title="客户端渲染"></a>客户端渲染</h2><p>客户端优化 dom、css 和 js 的代码和加载顺序</p><h3 id="什么是DOM"><a href="#什么是DOM" class="headerlink" title="什么是DOM"></a>什么是DOM</h3><blockquote><p>Document Object Model 文档对象模型</p></blockquote><p>DOM是Model，是Object Model，对象模型，是为HTML（and XML）提供的API。HTML（Hyper Text Markup Language）是一种标记语言，HTML在DOM的模型标准中被视为对象，DOM只提供编程接口，却无法实际操作HTML里面的内容。但在浏览器端，我们可以用脚本语言（JavaScript）通过DOM去操作HTML内容。</p><h3 id="为什么DOM很慢"><a href="#为什么DOM很慢" class="headerlink" title="为什么DOM很慢"></a>为什么DOM很慢</h3><p>首先，我们来了解一下网页的生成过程。浏览器在收到 HTML 文档之后会对文档进行解析开始构建 DOM （Document Object Model） 树，进而在文档中发现样式表，开始解析 CSS 来构建 CSSOM（CSS Object Model）树，这两者都构建完成后，开始构建渲染树。大致可分为以下几个过程：</p><ol><li>构建DOM树</li><li>构建CSSOM树</li><li>生成render树</li><li>Layout 布局</li><li>Paint 绘制</li></ol><p>在每次修改了 DOM 或者其样式之后都要进行 DOM树的构建，CSSOM 的重新计算，进而得到新的渲染树。浏览器会利用新的渲染树对页面进行重排和重绘，以及图层的合并。通常浏览器会批量进行重排和重绘，以提高性能。但当我们试图通过 JavaScript 获取某个节点的尺寸信息的时候，为了获得当前真实的信息，浏览器会立刻进行一次重排。</p><p>通过js操作DOM，影响页面性能的主要原因有如下几点：</p><ul><li>访问和修改DOM元素</li><li>修改DOM元素的样式，导致重绘和重排</li><li>通过对DOM元素的事件处理，完成与用户的交互功能</li></ul><h3 id="重绘（也称为回流reflow）和重排"><a href="#重绘（也称为回流reflow）和重排" class="headerlink" title="重绘（也称为回流reflow）和重排"></a>重绘（也称为回流reflow）和重排</h3><p>重排和重绘是DOM编程中耗能的主要原因之一。</p><blockquote><p>重绘</p></blockquote><p>重绘意味着元素发生的改变只影响了节点的一些样式（背景色，边框颜色，文字颜色等），只需要应用新样式绘制这个元素就可以了。</p><blockquote><p>引起重绘的操作</p></blockquote><ul><li>重排必定引起repaint重绘，重绘可以单独触发</li><li>背景色、颜色、字体改变（注意：字体大小发生变化时，会触发回流）</li></ul><blockquote><p>重排</p></blockquote><p>根据Render Tree布局（几何属性），意味着元素的内容、结构、位置或尺寸发生了变化，需要重新计算样式和渲染树。</p><blockquote><p>引起重排的操作</p></blockquote><ul><li>内容改变<br>  文本改变或图片尺寸改变</li><li>DOM元素的几何属性的变化<br>  例如改变DOM元素的宽高值时，原渲染树中的相关节点会失效，浏览器会根据变化后的DOM重新排建渲染树中的相关节点。如果父节点的几何属性变化时，还会使其子节点及后续兄弟节点重新计算位置等，造成一系列的重排。</li><li>DOM树的结构变化<br>  添加DOM节点、修改DOM节点位置及删除某个节点都是对DOM树的更改，会造成页面的重排。浏览器布局是从上到下的过程，修改当前元素不会对其前边已经遍历过的元素造成影响，但是如果在所有的节点前添加一个新的元素，则后续的所有元素都要进行重排。</li><li>浏览器窗口尺寸改变<br>  窗口尺寸的改变会影响整个网页内元素的尺寸的改变，即DOM元素的集合属性变化，因此会造成重排。</li><li>获取某些属性<br>  除了渲染树的直接变化，当获取一些属性值时，浏览器为取得正确的值也会发生重排，这些属性包括：offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、 clientTop、clientLeft、clientWidth、clientHeight、getComputedStyle()。</li></ul><h3 id="对性能的影响"><a href="#对性能的影响" class="headerlink" title="对性能的影响"></a>对性能的影响</h3><p>重排和重绘会不断触发，这是不可避免的。但是，它们非常耗费资源，是导致网页性能低下的根本原因。<br>提高网页性能，就是要降低“重排”和“重绘”的频率和成本，尽量少触发重新渲染。<br>前面提到，DOM变动和样式变动，都会触发重新渲染。但是，浏览器已经很智能了，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">div.style.color = <span class="string">'blue'</span>;</span><br><span class="line">div.style.marginTop = <span class="string">'30px'</span>;</span><br></pre></td></tr></table></figure></p><p>上面代码中，div元素有两个样式变动，但是浏览器只会触发一次重排和重绘。</p><p>如果写得不好，就会触发两次重排和重绘。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">div.style.color = <span class="string">'blue'</span>;</span><br><span class="line"><span class="keyword">var</span> margin = <span class="built_in">parseInt</span>(div.style.marginTop);</span><br><span class="line">div.style.marginTop = (margin + <span class="number">10</span>) + <span class="string">'px'</span>;</span><br></pre></td></tr></table></figure></p><p>上面代码对div元素设置颜色以后，第二行要求浏览器给出该元素的位置，所以浏览器不得不立即重排。</p><p>一般来说，样式的写操作之后，如果有下面这些属性的读操作，都会引发浏览器立即重新渲染。</p><pre><code>* offsetTop/offsetLeft/offsetWidth/offsetHeight* scrollTop/scrollLeft/scrollWidth/scrollHeight* clientTop/clientLeft/clientWidth/clientHeight* getComputedStyle()</code></pre><p>所以，从性能角度考虑，尽量不要把读操作和写操作，放在一个语句里面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bad</span></span><br><span class="line">div.style.left = div.offsetLeft + <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line">div.style.top = div.offsetTop + <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line"><span class="comment">//good</span></span><br><span class="line"><span class="keyword">var</span> left = div.offsetLeft;</span><br><span class="line"><span class="keyword">var</span> top  = div.offsetTop;</span><br><span class="line">div.style.left = left + <span class="number">10</span> + <span class="string">"px"</span>;</span><br><span class="line">div.style.top = top + <span class="number">10</span> + <span class="string">"px"</span>;</span><br></pre></td></tr></table></figure></p><h3 id="关于DOM操作的几个技巧"><a href="#关于DOM操作的几个技巧" class="headerlink" title="关于DOM操作的几个技巧"></a>关于DOM操作的几个技巧</h3><ul><li>DOM 的多个读操作（或多个写操作），应该放在一起。不要两个读操作之间，加入一个写操作。</li><li>如果某个样式是通过重排得到的，那么最好缓存结果。避免下一次用到的时候，浏览器又要重排。</li><li><p>不要一条条地改变样式，而要通过改变class，或者csstext属性，一次性地改变样式。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> left = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">var</span> top = <span class="number">10</span>;</span><br><span class="line">el.style.left = left + <span class="string">"px"</span>;</span><br><span class="line">el.style.top  = top  + <span class="string">"px"</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.className += <span class="string">" theclassname"</span>;</span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">el.style.cssText += <span class="string">"; left: "</span> + left + <span class="string">"px; top: "</span> + top + <span class="string">"px;"</span>;</span><br></pre></td></tr></table></figure></li><li><p>先将元素设为display: none（需要1次重排和重绘），然后对这个节点进行100次操作，最后再恢复显示（需要1次重排和重绘）。这样一来，你就用两次重新渲染，取代了可能高达100次的重新渲染。</p></li><li>position属性为absolute或fixed的元素，重排的开销会比较小，因为不用考虑它对其他元素的影响。</li><li>只在必要的时候，才将元素的display属性为可见，因为不可见的元素不影响重排和重绘。另外，visibility : hidden的元素只对重绘有影响，不影响重排。</li><li><p>在涉及到吸顶相关及scroll滚动优化</p><ol><li>尽量控制DOM的显示或隐藏，而不是删除或添加</li><li>一次性操作DOM</li><li>多做缓存</li><li><p>注意节流，避免频繁触发滚动事件</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> throttle = <span class="function"><span class="keyword">function</span> (<span class="params">fn, threshhold = <span class="number">200</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> last;</span><br><span class="line">    <span class="keyword">var</span> timer;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> context = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</span><br><span class="line">        <span class="keyword">var</span> now = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">        <span class="keyword">if</span> (last &amp;&amp; now &lt; last + threshhold) &#123;</span><br><span class="line">            clearTimeout(timer);</span><br><span class="line">            timer = setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                last = now;</span><br><span class="line">                fn.apply(context, args);</span><br><span class="line">            &#125;, threshhold);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = now;</span><br><span class="line">            fn.apply(context, args);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="代码优化和加载顺序"><a href="#代码优化和加载顺序" class="headerlink" title="代码优化和加载顺序"></a>代码优化和加载顺序</h3><p>尽量较少不必要的代码，比如html和css的多层嵌套，代码结构尽量精简。了解js内存泄漏，避免导致内存泄漏的写法。HTML和CSS都会阻塞渲染。所以需要让CSS尽早加载（如：放在头部），以缩短首次渲染的时间。js脚本会阻塞浏览器解析，将脚本放在页面底部加载。</p><h2 id="服务端响应"><a href="#服务端响应" class="headerlink" title="服务端响应"></a>服务端响应</h2><p>尽量减少响应的体积，比如用 gzip 压缩，优化图片字节数，加快文件读取速度，优化服务端的缓存策略。</p><h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>优化网络路由，比如增加 CDN 缓存；或增加并发处理能力，比如服务端设置多个域名，客户端使用多个域名同时请求资源，增加并发量。</p><h3 id="浏览器并发请求限制"><a href="#浏览器并发请求限制" class="headerlink" title="浏览器并发请求限制"></a>浏览器并发请求限制</h3><p>基于端口数量和线程切换开销的考虑，浏览器不可能无限量的并发请求，因此衍生出来了并发限制。浏览器的并发请求数目限制是针对同一域名的。因此静态资源可以引用不同域名下的资源文件，间接增加浏览器请求资源的并发数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上介绍了性能优化的几个方面，因个人能力有限，有总结不到或者错误的地方，还请各位大神不吝指教。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在构建web站点的过程中，任何一个细节都有可能影响网站的访问速度，如果不了解性能优化知识，很多不利网站访问速度的因素会形成累加，从而严重影响网站的性能，导致网站访问速度变慢，用户体验低下，最终导致用户流失。本文主要围绕以下几点讲解：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端请求&lt;/li&gt;
&lt;li&gt;客户端渲染&lt;/li&gt;
&lt;li&gt;服务端响应&lt;/li&gt;
&lt;li&gt;网络
    
    </summary>
    
      <category term="zhangjianfeng" scheme="http://xgfe.github.io/categories/zhangjianfeng/"/>
    
    
      <category term="性能优化" scheme="http://xgfe.github.io/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    
      <category term="web性能" scheme="http://xgfe.github.io/tags/web%E6%80%A7%E8%83%BD/"/>
    
      <category term="前端优化实践" scheme="http://xgfe.github.io/tags/%E5%89%8D%E7%AB%AF%E4%BC%98%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    
  </entry>
  
  <entry>
    <title>routable-ios 源码解析</title>
    <link href="http://xgfe.github.io/2018/04/07/chenyu/routable-ios_sourceAnalysis/"/>
    <id>http://xgfe.github.io/2018/04/07/chenyu/routable-ios_sourceAnalysis/</id>
    <published>2018-04-07T05:12:00.000Z</published>
    <updated>2018-08-24T03:48:57.235Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分析 <a href="https://github.com/clayallsopp/routable-ios" target="_blank" rel="noopener">routable-ios</a> 源码，通过本文可以了解路由的原理及使用。本文分为六个部分，从代码结构到具体的类依次介绍，文章最后会给出在项目中注册路由常用的方式。</p><a id="more"></a><h2 id="一、routable-ios-是什么？可以用来做什么？与之类似的框架还有哪些？"><a href="#一、routable-ios-是什么？可以用来做什么？与之类似的框架还有哪些？" class="headerlink" title="一、routable-ios 是什么？可以用来做什么？与之类似的框架还有哪些？"></a>一、routable-ios 是什么？可以用来做什么？与之类似的框架还有哪些？</h2><ul><li>routable-ios 是一个路由框架，由两个文件四个类组成，其中核心的类就一个。</li><li>可以很方便的实现 iOS 中<code>UIViewController</code>之间的跳转。跳转方式也可以灵活的设置，后面具体会讲到。</li><li>类似的框架还有 <a href="https://github.com/aaronbrethorst/ABRouter" target="_blank" rel="noopener">ABRouter</a> &amp; <a href="https://github.com/lightory/HHRouter" target="_blank" rel="noopener">HHRouter</a>。后期的文章也会对 HHRouter 做介绍。</li></ul><h2 id="二、routable-ios-中类的关系"><a href="#二、routable-ios-中类的关系" class="headerlink" title="二、routable-ios 中类的关系"></a>二、routable-ios 中类的关系</h2><p>&nbsp;&nbsp;了解类与类之间的关系，有助于理解整个框架。<code>Routable</code>继承自<code>UPRouter</code>，主要的功能都在<code>UPRouter</code>类中，路由主要的功能其实就两个：</p><ul><li>注册希望路由跳转的类及<code>URL</code></li><li>进行跳转</li></ul><p><img src="http://upload-images.jianshu.io/upload_images/142772-7f18a54a0a327233.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="routable-ios 类组织结构.png"></p><h2 id="三、routable-ios-如何使用"><a href="#三、routable-ios-如何使用" class="headerlink" title="三、routable-ios 如何使用"></a>三、routable-ios 如何使用</h2><ul><li>将<code>routable-ios</code>导入项目</li><li><p>注册路由：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[Routable sharedRouter] map:@&quot;user/:name/:age&quot; toController:[UserController class]];</span><br></pre></td></tr></table></figure></li><li><p>调用路由进行跳转：</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[Routable sharedRouter] open:@&quot;user/chenyu/28&quot;];</span><br></pre></td></tr></table></figure></li><li><p>在 VC 中获取传递的参数</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@implementation UserController</span><br><span class="line"></span><br><span class="line">- (id)initWithRouterParams:(NSDictionary *)params &#123;</span><br><span class="line">  if ((self = [self initWithNibName:nil bundle:nil])) &#123;</span><br><span class="line">    self.title = @&quot;User&quot;;</span><br><span class="line">      NSLog(@&quot;name: %@&quot;,[params objectForKey:@&quot;name&quot;]); //chenyu</span><br><span class="line">      NSLog(@&quot;age: %@&quot;,[params objectForKey:@&quot;age&quot;]);   //28</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure></li></ul><h2 id="四、routable-ios-中的核心类"><a href="#四、routable-ios-中的核心类" class="headerlink" title="四、routable-ios 中的核心类"></a>四、routable-ios 中的核心类</h2><p>&nbsp;&nbsp;核心类分别有：<code>Routable</code>，<code>UPRouterOptions</code>，<code>RouterParams</code>，<code>UPRouter</code></p><h3 id="1-Routable"><a href="#1-Routable" class="headerlink" title="1.Routable"></a>1.<code>Routable</code></h3><p>&nbsp;&nbsp;<code>Routable</code>继承自<code>UPRouter</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (instancetype)sharedRouter; //提供单例方法，用来创建路由类</span><br><span class="line">+ (instancetype)newRouter;     //另一种创建路由的方式，一般不推荐，不是单例。</span><br></pre></td></tr></table></figure><h3 id="2-UPRouterOptions"><a href="#2-UPRouterOptions" class="headerlink" title="2.UPRouterOptions"></a>2.<code>UPRouterOptions</code></h3><p>&nbsp;&nbsp;<code>UPRouterOptions</code>继承自<code>NSObject</code>。首先看一下这个类提供的一些属性，我们就知道这个类是做什么的了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@property (readwrite, nonatomic, getter=isModal) BOOL modal;  //是否是模态视图</span><br><span class="line">@property (readwrite, nonatomic) UIModalPresentationStyle presentationStyle;  //VC 显示的样式</span><br><span class="line">@property (readwrite, nonatomic) UIModalTransitionStyle transitionStyle;  //VC 出现时的动画</span><br><span class="line">@property (readwrite, nonatomic, strong) NSDictionary *defaultParams;  //默认的数据</span><br><span class="line">@property (readwrite, nonatomic, assign) BOOL shouldOpenAsRootViewController; //是否是根视图</span><br><span class="line"></span><br><span class="line">//.m 文件中的两个属性</span><br><span class="line">@property (readwrite, nonatomic, strong) Class openClass;  //注册的类</span><br><span class="line">@property (readwrite, nonatomic, copy) RouterOpenCallback callback;  //block 回调</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;通过以上内容，可以看到<code>UPRouterOptions</code>其实就是一个配置类，里面存储路由跳转时需要的一些数据，可以理解成一个辅助的类。这个类中提供了一系列的工厂方法，用来创建不同类型的对象，比如（只列举部分函数，其他同类型的函数还有很多，功能大体一致，只是某个配置项不同而已。）：</p><ul><li><p>全部使用默认配置</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Default construction; like [NSArray array]</span><br><span class="line">+ (instancetype)routerOptions &#123;</span><br><span class="line">  return [self routerOptionsWithPresentationStyle:UIModalPresentationNone</span><br><span class="line">                                  transitionStyle:UIModalTransitionStyleCoverVertical</span><br><span class="line">                                    defaultParams:nil</span><br><span class="line">                                           isRoot:NO</span><br><span class="line">                                          isModal:NO];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>传入所有参数创建对象</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//Explicit construction</span><br><span class="line">+ (instancetype)routerOptionsWithPresentationStyle: (UIModalPresentationStyle)presentationStyle</span><br><span class="line">                                   transitionStyle: (UIModalTransitionStyle)transitionStyle</span><br><span class="line">                                     defaultParams: (NSDictionary *)defaultParams</span><br><span class="line">                                            isRoot: (BOOL)isRoot</span><br><span class="line">                                           isModal: (BOOL)isModal &#123;</span><br><span class="line">  UPRouterOptions *options = [[UPRouterOptions alloc] init];</span><br><span class="line">  options.presentationStyle = presentationStyle;</span><br><span class="line">  options.transitionStyle = transitionStyle;</span><br><span class="line">  options.defaultParams = defaultParams;</span><br><span class="line">  options.shouldOpenAsRootViewController = isRoot;</span><br><span class="line">  options.modal = isModal;</span><br><span class="line">  return options;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义部分参数创建对象</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//Custom class constructors, with heavier Objective-C accent</span><br><span class="line">+ (instancetype)routerOptionsAsModal &#123;</span><br><span class="line">  return [self routerOptionsWithPresentationStyle:UIModalPresentationNone</span><br><span class="line">                                  transitionStyle:UIModalTransitionStyleCoverVertical</span><br><span class="line">                                    defaultParams:nil</span><br><span class="line">                                           isRoot:NO</span><br><span class="line">                                          isModal:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>剩余的基本就是一些快捷的方法及一些<code>setters</code>方法，可以查看源码。</p></li></ul><h3 id="3-RouterParams"><a href="#3-RouterParams" class="headerlink" title="3.RouterParams"></a>3.<code>RouterParams</code></h3><p>&nbsp;&nbsp;<code>RouterParams</code>继承自<code>NSObject</code>。<code>RouterParams</code>并没有在.h 文件中做声明，这个类只在<code>Routable</code>和<code>UPRouter</code>中的实现中才用到，而这三个类都在一个文件中，所以也没有必要出现在 .h 文件中。<br>首先看一下<code>RouterParams</code>的声明：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface RouterParams : NSObject</span><br><span class="line"></span><br><span class="line">@property (readwrite, nonatomic, strong) UPRouterOptions *routerOptions;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSDictionary *openParams; </span><br><span class="line">@property (readwrite, nonatomic, strong) NSDictionary *extraParams;</span><br><span class="line">@property (readwrite, nonatomic, strong) NSDictionary *controllerParams;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;这个类的出现，主要作用是将跳转时匹配好的所有内容存起来，缓存到另一个字典中，未来再次跳转的时候，直接可以拿出来用，你也许会问，我们的路由不是在一个字典里吗，也可以直接拿出来用，为什么还要缓存，后续到源代码的地方会细说，为什么要缓存，为什么跳转的时候不是直接去 map 中寻找。</p><h3 id="4-UPRouter"><a href="#4-UPRouter" class="headerlink" title="4.UPRouter"></a>4.<code>UPRouter</code></h3><p>&nbsp;&nbsp;<code>UPRouter</code>继承自<code>NSObject</code>，首先看一下类的声明，删除了很多注释。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">@interface UPRouter : NSObject</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> The UINavigationController instance which mapped UIViewControllers will be pushed onto.</span><br><span class="line"> */</span><br><span class="line">@property (readwrite, nonatomic, strong) UINavigationController *navigationController;</span><br><span class="line"></span><br><span class="line">- (void)pop;</span><br><span class="line">- (void)popViewControllerFromRouterAnimated:(BOOL)animated;</span><br><span class="line">- (void)pop:(BOOL)animated;</span><br><span class="line"></span><br><span class="line">@property (readwrite, nonatomic, assign) BOOL ignoresExceptions;</span><br><span class="line"></span><br><span class="line">- (void)map:(NSString *)format toCallback:(RouterOpenCallback)callback;</span><br><span class="line">- (void)map:(NSString *)format toCallback:(RouterOpenCallback)callback withOptions:(UPRouterOptions *)options;</span><br><span class="line">- (void)map:(NSString *)format toController:(Class)controllerClass;</span><br><span class="line">//注册路由，本篇主要分析的方法。上面的方法最终会调用这个方法，options 传入的是 nil</span><br><span class="line">- (void)map:(NSString *)format toController:(Class)controllerClass withOptions:(UPRouterOptions *)options;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- (void)openExternal:(NSString *)url;</span><br><span class="line">- (void)open:(NSString *)url;</span><br><span class="line">- (void)open:(NSString *)url animated:(BOOL)animated;</span><br><span class="line">//路由跳转，本篇主要分析的方法。上面两个方法最终都会调用这个方法。</span><br><span class="line">- (void)open:(NSString *)url animated:(BOOL)animated extraParams:(NSDictionary *)extraParams;</span><br><span class="line"></span><br><span class="line">- (NSDictionary*)paramsOfUrl:(NSString*)url;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@interface UPRouter ()</span><br><span class="line"></span><br><span class="line">// 存储注册的路由</span><br><span class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *routes;</span><br><span class="line">// 缓存已跳转过的路由</span><br><span class="line">@property (readwrite, nonatomic, strong) NSMutableDictionary *cachedRoutes;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;注册路由比较简单，就是将传入的<code>URL</code>作为 key，将<code>Class</code>作为值存入已初始化的<code>routes</code>中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">- (void)map:(NSString *)format toController:(Class)controllerClass &#123;</span><br><span class="line">  [self map:format toController:controllerClass withOptions:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)map:(NSString *)format toController:(Class)controllerClass withOptions:(UPRouterOptions *)options &#123;</span><br><span class="line">  if (!format) &#123;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;RouteNotProvided&quot;</span><br><span class="line">                                   reason:@&quot;Route #format is not initialized&quot;</span><br><span class="line">                                 userInfo:nil];</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  //如果没有传入 options，则会创建一个默认的配置对象</span><br><span class="line">  if (!options) &#123;</span><br><span class="line">    options = [UPRouterOptions routerOptions];</span><br><span class="line">  &#125;</span><br><span class="line">  options.openClass = controllerClass;</span><br><span class="line">  [self.routes setObject:options forKey:format];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;路由跳转一共有三个比较重要的方法，首先看<code>open:animated:extraParams:</code>方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">- (void)open:(NSString *)url</span><br><span class="line">    animated:(BOOL)animated</span><br><span class="line"> extraParams:(NSDictionary *)extraParams</span><br><span class="line">&#123;</span><br><span class="line">  //获取路由跳转相关的参数，往下滑动，先看怎么获取的数据，看完下面的方法再回来看这个方法</span><br><span class="line">  RouterParams *params = [self routerParamsForUrl:url extraParams: extraParams];</span><br><span class="line">  UPRouterOptions *options = params.routerOptions;</span><br><span class="line">  </span><br><span class="line">  //好了，拿到数据了，开始跳转。先判断是否有回调，如果有的话，则去执行 block</span><br><span class="line">  if (options.callback) &#123;</span><br><span class="line">    RouterOpenCallback callback = options.callback;</span><br><span class="line">    callback([params controllerParams]);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  //此处删除了判断 self.navigationController 是否存在的容错代码，无关紧要。</span><br><span class="line">  </span><br><span class="line">  //获取将要跳转的 VC，并且将我们传递的数据以字典的形式，传递给这个 VC</span><br><span class="line">  //controllerForRouterParams 这个方法比较简单，打断点进去看看就 OK 了。</span><br><span class="line">  UIViewController *controller = [self controllerForRouterParams:params];</span><br><span class="line">  </span><br><span class="line">  //判断当前是否有 presented 的 UIViewController，有的话要 dismiss，因为接下来要跳转或者 presentViewController</span><br><span class="line">  if (self.navigationController.presentedViewController) &#123;</span><br><span class="line">    [self.navigationController dismissViewControllerAnimated:animated completion:nil];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //是否是以模态的方式弹出 UIViewController</span><br><span class="line">  if ([options isModal]) &#123;</span><br><span class="line">    if ([controller.class isSubclassOfClass:UINavigationController.class]) &#123;</span><br><span class="line">      [self.navigationController presentViewController:controller</span><br><span class="line">                                              animated:animated</span><br><span class="line">                                            completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">      UINavigationController *navigationController = [[UINavigationController alloc] initWithRootViewController:controller];</span><br><span class="line">      navigationController.modalPresentationStyle = controller.modalPresentationStyle;</span><br><span class="line">      navigationController.modalTransitionStyle = controller.modalTransitionStyle;</span><br><span class="line">      [self.navigationController presentViewController:navigationController</span><br><span class="line">                                              animated:animated</span><br><span class="line">                                            completion:nil];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  else if (options.shouldOpenAsRootViewController) &#123;</span><br><span class="line">    //设置根视图</span><br><span class="line">    [self.navigationController setViewControllers:@[controller] animated:animated];</span><br><span class="line">  &#125;</span><br><span class="line">  else &#123;</span><br><span class="line">    //直接 push 一个 UIViewController</span><br><span class="line">    [self.navigationController pushViewController:controller animated:animated];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;获取路由跳转相关的参数方法（删除了一些容错处理的代码）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">- (RouterParams *)routerParamsForUrl:(NSString *)url extraParams: (NSDictionary *)extraParams &#123;</span><br><span class="line">  //如果缓存中已经有了（证明之前已经跳转过这个 VC），并且传递的参数没有变化。</span><br><span class="line">  //这里需要注意了，如果传递的参数你也不确定是不是没变化，最好给 extraParams 给个值，这样就不会走缓存了</span><br><span class="line">  //否则可能传递的数据变了，但是走的还是之前的缓存。</span><br><span class="line">  //如果 VC 之间不要传递数据，不用考虑这个问题</span><br><span class="line">  if ([self.cachedRoutes objectForKey:url] &amp;&amp; !extraParams) &#123;</span><br><span class="line">    return [self.cachedRoutes objectForKey:url];</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  NSArray *givenParts = url.pathComponents;</span><br><span class="line">  NSArray *legacyParts = [url componentsSeparatedByString:@&quot;/&quot;];</span><br><span class="line">  //这里判断传入的路由路径是否正确，如果传入这样的 &quot;iOS/app//first&quot; 路径，则会警告。</span><br><span class="line">  //也许你的路由路径是&quot;iOS/app&quot;，这样写你就少传了一个实参</span><br><span class="line">  if ([legacyParts count] != [givenParts count]) &#123;</span><br><span class="line">    NSLog(@&quot;Routable Warning - your URL %@ has empty path components - this will throw an error in an upcoming release&quot;, url);</span><br><span class="line">    givenParts = legacyParts;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  //使用枚举的方式去匹配，这里不能从 self.routes 中通过 [self.routes objectForKey:@&quot;key&quot;] 的方式获取，</span><br><span class="line">  //因为注册的时候，你后面添加的是参数（形参），在跳转的时候传递的是数据（实参）。</span><br><span class="line">  //这里也就是为什么需要缓存的原因了，每次跳转都要枚举这个字典，缓存了以后时间复杂度直接降到了 O(1)。</span><br><span class="line">  __block RouterParams *openParams = nil;</span><br><span class="line">  [self.routes enumerateKeysAndObjectsUsingBlock:</span><br><span class="line">   ^(NSString *routerUrl, UPRouterOptions *routerOptions, BOOL *stop) &#123;</span><br><span class="line">     //routerUrl 是枚举到的 key，也是当时注册路由时添加进去的 url，routerOptions 是枚举到的 value</span><br><span class="line"></span><br><span class="line">     NSArray *routerParts = [routerUrl pathComponents];</span><br><span class="line">     //判断注册的路由地址和跳转的带参数的地址是否一致，最简单的办法就是判断他们包含的元素个数是否一致，如果一致，再做更详细的判断</span><br><span class="line">     if ([routerParts count] == [givenParts count]) &#123;</span><br><span class="line">       //如果个数一致，再判断是否匹配</span><br><span class="line">       NSDictionary *givenParams = [self paramsForUrlComponents:givenParts routerUrlComponents:routerParts];</span><br><span class="line">       if (givenParams) &#123;</span><br><span class="line">         //givenParams 存储的是路由地址中给的数据，再将 extraParams 一起传入 RouterParams，创建 RouterParams 的对象。</span><br><span class="line">         openParams = [[RouterParams alloc] initWithRouterOptions:routerOptions openParams:givenParams extraParams: extraParams];</span><br><span class="line">         *stop = YES;//结束遍历</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;];</span><br><span class="line">  </span><br><span class="line">  //如果没有匹配到路由</span><br><span class="line">  if (!openParams) &#123;</span><br><span class="line">    //用户设置了忽略异常，直接返回 nil，否则会走 @throw</span><br><span class="line">    if (_ignoresExceptions) &#123;</span><br><span class="line">      return nil;</span><br><span class="line">    &#125;</span><br><span class="line">    @throw [NSException exceptionWithName:@&quot;RouteNotFoundException&quot;</span><br><span class="line">                                   reason:[NSString stringWithFormat:ROUTE_NOT_FOUND_FORMAT, url]</span><br><span class="line">                                 userInfo:nil];</span><br><span class="line">  &#125;</span><br><span class="line">  //将我们辛辛苦苦封装好的路由相关的所有数据缓存起来，下次在走这个 url 的时候，直接取缓存中的数据，这就是为什么要缓存了。</span><br><span class="line">  //除非你传递的参数变了，那么一定传给 extraParams，相关方法检测到 extraParams 不为空，会重新组装数据。</span><br><span class="line">  [self.cachedRoutes setObject:openParams forKey:url];</span><br><span class="line">  return openParams;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//判断注册的路由和跳转的路由是否一致</span><br><span class="line">- (NSDictionary *)paramsForUrlComponents:(NSArray *)givenUrlComponents</span><br><span class="line">                     routerUrlComponents:(NSArray *)routerUrlComponents &#123;</span><br><span class="line">  </span><br><span class="line">  __block NSMutableDictionary *params = [NSMutableDictionary dictionary];</span><br><span class="line">  [routerUrlComponents enumerateObjectsUsingBlock:</span><br><span class="line">   ^(NSString *routerComponent, NSUInteger idx, BOOL *stop) &#123;</span><br><span class="line">     </span><br><span class="line">     NSString *givenComponent = givenUrlComponents[idx];</span><br><span class="line">     //判断是否是形参，所以在注册路由时，一定要注意，参数以:开始，否则会当成路径字符串</span><br><span class="line">     if ([routerComponent hasPrefix:@&quot;:&quot;]) &#123;</span><br><span class="line">       //去除参数的:，然后将参数名作为 key，将对应的 givenComponent 作为值存入字典中，所以在调用路由的时候，传递参数（实参）顺序要一致，否则参数就错乱了</span><br><span class="line">       NSString *key = [routerComponent substringFromIndex:1];</span><br><span class="line">       [params setObject:givenComponent forKey:key];</span><br><span class="line">     &#125;</span><br><span class="line">     else if (![routerComponent isEqualToString:givenComponent]) &#123;</span><br><span class="line">       //在非传参数的情况下，如果路径不一致，则结束。结束后会去路由表中拿下一个路由来判断。</span><br><span class="line">       params = nil;</span><br><span class="line">       *stop = YES;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;];</span><br><span class="line">  return params;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;将路由跳转最重要的三个方法分析了一下，在重要的代码前都加上了注释。接下来总结一下整体的思路。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>&nbsp;&nbsp;注册的时候，比较简单，将我们的路径和 VC 传递进去，保存在字典中就可以了。跳转的时候，做的判断就比较多。首先判断缓存中是否有这个路径，如果有的话，直接跳转，在注释中也详细说明了为什么要缓存。如果没有的话，则去枚举这个路由字典，并组装数据，存入缓存中。</p><p>&nbsp;&nbsp;任何框架，都会有不完美的地方，没错，这里要说说了。如果需要给你跳转的 VC 传递数据，那么需要你的 VC 实现这个方法：<code>initWithRouterParams:params</code>，通过<code>params</code>去获取你的值。其实在这里也可以通过获取这个 VC 的所有属性，在创建这个 VC 的时候，通过 KVC 的方式把值赋给这个 VC 的属性。</p><p>&nbsp;&nbsp;另一种实现办法是扩展<code>UIViewController</code>，在这里可以这样做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@interface UIViewController (Routable)</span><br><span class="line"></span><br><span class="line">@property (nonatomic, strong) NSDictionary *params;</span><br><span class="line">@end</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@implementation UIViewController (Routable)</span><br><span class="line"></span><br><span class="line">static char kAssociatedParamsObjectKey;</span><br><span class="line"></span><br><span class="line">- (void)setParams:(NSDictionary *)params&#123;</span><br><span class="line">    objc_setAssociatedObject(self, &amp;kAssociatedParamsObjectKey, params, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSDictionary *)params</span><br><span class="line">&#123;</span><br><span class="line">    return objc_getAssociatedObject(self, &amp;kAssociatedParamsObjectKey);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure><p>&nbsp;&nbsp;这样每个<code>UIViewController</code>中就不用实现固定的方法了，在使用的时候，直接调用<code>self.params</code>就可以拿到这个字典了。</p><h2 id="六、建议"><a href="#六、建议" class="headerlink" title="六、建议"></a>六、建议</h2><p>&nbsp;&nbsp;在<code>routable-ios</code>中给出的注册路由的方式是，一个 VC 一个 VC 的注册。可以将需要路由跳转的 VC 配置到 plist 文件中，写一个方法，读取 plist 文件，循环注册即可，在<code>application:didFinishLaunchingWithOptions:</code>方法中，调用注册路由的方法即可。</p><p>&nbsp;&nbsp;我 fork 了一份代码，并在里面添加了注释，想通过 Xcode 看的，可以下载下来看。 <a href="https://github.com/chenyu1520/routable-ios" target="_blank" rel="noopener">传送门</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要分析 &lt;a href=&quot;https://github.com/clayallsopp/routable-ios&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;routable-ios&lt;/a&gt; 源码，通过本文可以了解路由的原理及使用。本文分为六个部分，从代码结构到具体的类依次介绍，文章最后会给出在项目中注册路由常用的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="chenyu" scheme="http://xgfe.github.io/categories/chenyu/"/>
    
    
      <category term="iOS" scheme="http://xgfe.github.io/tags/iOS/"/>
    
      <category term="源码" scheme="http://xgfe.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="路由" scheme="http://xgfe.github.io/tags/%E8%B7%AF%E7%94%B1/"/>
    
  </entry>
  
  <entry>
    <title>iOS源码解读-对象关联实现分析</title>
    <link href="http://xgfe.github.io/2018/03/24/lixiaoqiang/ios%E4%B8%AD%E5%AF%B9%E8%B1%A1%E5%85%B3%E8%81%94%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://xgfe.github.io/2018/03/24/lixiaoqiang/ios中对象关联的底层实现/</id>
    <published>2018-03-24T12:31:49.000Z</published>
    <updated>2018-08-24T03:48:57.244Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要分析iOS对象关联的实现。<br><a id="more"></a></p><h3 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h3><p>在iOS开发中，经常为了将代码解耦或者在原有的类的基础上扩展功能，经常会使用类目(Catogery)。但是大家都知道分类添加的属性Xcode不会自动的为其生成一个下划线开头的成员变量及set和get方法，如果你没有手动实现这两个方法，直接在外面通过点语法调用这个属性，肯定就挂了，会报“unrecognized selector sent to instance”的错误。假设我们在类目.h中放置一个属性（但是并不声明set方法和get方法），我们在类目中.m中尝试添加自定义set方法和get方法，我们发现已经可以像正常类一样调用这个类目的属性，这里就说明了@property已经帮我们申明了set和get方法，只是并没有实现。这样我们自己实现了set和get方法，但是没有成员变量来存放我们set的值，这样get的时候也就无法取到set的值，这样肯定是不行的。那我们猜想一下苹果会怎么设计这个set的值存储的方式。</p><h3 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h3><p>在没有看到苹果的实现之前，我想的是将set的值存放在一个单例下的变量中，这样在get的时候去取这个单例中被set的变量。但是这会产生一个问题，那就是如果我们在一个工程中创建了很多类目，事实上，在开发的过程中类目文件很多也是很正常的。那么我们可能需要创建单例来保存这些类目下的属性，也许会用一个全局的单例，或者是每个类目创建一个单例来存储。这是我的想法，那我们看看苹果的做法究竟是什么。</p><h3 id="苹果的做法"><a href="#苹果的做法" class="headerlink" title="苹果的做法"></a>苹果的做法</h3><p>通过查阅资料，我们看到给category的做法是利用了“_object_set_associative_reference(id object, void *key, id value, uintptr_t policy)”这个方法，这个方法是将要添加的属性和类目扩展的对象关联起来，方法的第一个参数Object是需要关联的对象，key是一个常量，value是需要添加的属性。<br>policy对应的是枚举表示关联引用的存储策略。<br><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</span><br><span class="line">    OBJC_ASSOCIATION_ASSIGN = <span class="number">0</span>,           <span class="comment">/**&lt; Specifies a weak reference to the associated object. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = <span class="number">1</span>, <span class="comment">/**&lt; Specifies a strong reference to the associated object. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = <span class="number">3</span>,   <span class="comment">/**&lt; Specifies that the associated object is copied. </span></span><br><span class="line"><span class="comment">                                            *   The association is not made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_RETAIN = <span class="number">01401</span>,       <span class="comment">/**&lt; Specifies a strong reference to the associated object.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">    OBJC_ASSOCIATION_COPY = <span class="number">01403</span>          <span class="comment">/**&lt; Specifies that the associated object is copied.</span></span><br><span class="line"><span class="comment">                                            *   The association is made atomically. */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>接下来我们来看这个“_object_set_associative_reference”的方法的具体实现，虽然是c++的代码，我们只要认真的沉下心来分析，还是能分析出苹果这个方法的实现思路。方法所做的事情我在代码中用中文注释出来。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> _object_set_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key, <span class="keyword">id</span> value, uintptr_t policy) &#123;</span><br><span class="line">    <span class="comment">// retain the new value (if any) outside the lock.</span></span><br><span class="line">    ObjcAssociation old_association(<span class="number">0</span>, <span class="literal">nil</span>); <span class="comment">//构造了一个表示旧值的对象</span></span><br><span class="line">    <span class="keyword">id</span> new_value = value ? acquireValue(value, policy) : <span class="literal">nil</span>;<span class="comment">//根据传进来的值和策略产生一个新值</span></span><br><span class="line">    &#123;</span><br><span class="line">        AssociationsManager manager;<span class="comment">//这是管理关联的单例</span></span><br><span class="line">        AssociationsHashMap &amp;associations(manager.associations());<span class="comment">//这个单例里面有一个hashmap</span></span><br><span class="line">        disguised_ptr_t disguised_object = DISGUISE(object);<span class="comment">//DISGUISE是一个将对象指针转变的宏，这里暂且将disguised_object看做是传进来的对象经过转换产生的一个新对象</span></span><br><span class="line">        <span class="keyword">if</span> (new_value) &#123;<span class="comment">//如果这个传进来的值存在</span></span><br><span class="line">            <span class="comment">// break any existing association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);<span class="comment">//遍历单例中hashmap根据disguised_object 去找AssociationsHashMap类型的hashmap。由此可见，associations中存储着以disguised_object为key的多个hashmap</span></span><br><span class="line">            <span class="keyword">if</span> (i != associations.end()) &#123;<span class="comment">//表示找到了以传进来的以disguised_object为key的hashmap，下面就是在找到的hashmap中找以传进来的key为key的键值对.</span></span><br><span class="line">                <span class="comment">// secondary table exists</span></span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;<span class="comment">//找到了跟传进来的key相同的键值对，将原来的键值得值赋值给刚开始初始化的old_association，然后将新值赋值给原来的键值对。</span></span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    j-&gt;second = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果没有找到相同的key，则直接关联到遍历得到的hashmap上</span></span><br><span class="line">                    (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果找不到以disguised_object为key的hashmap，则创建新的hashmap给大的associations</span></span><br><span class="line">                <span class="comment">// create the new association (first time).</span></span><br><span class="line">                ObjectAssociationMap *refs = new ObjectAssociationMap;</span><br><span class="line">                associations[disguised_object] = refs;</span><br><span class="line">                (*refs)[key] = ObjcAssociation(policy, new_value);</span><br><span class="line">                object-&gt;setHasAssociatedObjects();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;<span class="comment">//如果新值不存在，则会根据传进来的key抹去原来的在hashmap中的以key对应的键值对</span></span><br><span class="line">            <span class="comment">// setting the association to nil breaks the association.</span></span><br><span class="line">            AssociationsHashMap::iterator i = associations.find(disguised_object);</span><br><span class="line">            <span class="keyword">if</span> (i !=  associations.end()) &#123;</span><br><span class="line">                ObjectAssociationMap *refs = i-&gt;second;</span><br><span class="line">                ObjectAssociationMap::iterator j = refs-&gt;find(key);</span><br><span class="line">                <span class="keyword">if</span> (j != refs-&gt;end()) &#123;</span><br><span class="line">                    old_association = j-&gt;second;</span><br><span class="line">                    refs-&gt;erase(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// release the old value (outside of the lock).</span></span><br><span class="line">    <span class="keyword">if</span> (old_association.hasValue()) ReleaseValue()(old_association)<span class="comment">//根据其原本绑定的策略，对删掉的值做一些善后处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过源码分析我们知道了苹果是怎么关联的属性的底层的实现，那么要取出来存进去的属性那就简单了，就是根据key和object对象进行遍历，我们看看objc_getAssociatedObject(id _Nonnull object, const void * _Nonnull key)的底层实现:  </p><pre><code class="objc"><span class="keyword">id</span> _object_get_associative_reference(<span class="keyword">id</span> object, <span class="keyword">void</span> *key) {    <span class="keyword">id</span> value = <span class="literal">nil</span>;    uintptr_t policy = OBJC_ASSOCIATION_ASSIGN;    {        AssociationsManager manager;        AssociationsHashMap &amp;associations(manager.associations());        disguised_ptr_t disguised_object = DISGUISE(object);        AssociationsHashMap::iterator i = associations.find(disguised_object);        <span class="keyword">if</span> (i != associations.end()) {            ObjectAssociationMap *refs = i-&gt;second;            ObjectAssociationMap::iterator j = refs-&gt;find(key);            <span class="keyword">if</span> (j != refs-&gt;end()) {                ObjcAssociation &amp;entry = j-&gt;second;                value = entry.value();                policy = entry.policy();                <span class="keyword">if</span> (policy &amp; OBJC_ASSOCIATION_GETTER_RETAIN) {                    objc_retain(value);                }            }        }    }    <span class="keyword">if</span> (value &amp;&amp; (policy &amp; OBJC_ASSOCIATION_GETTER_AUTORELEASE)) {        objc_autorelease(value);    }    <span class="keyword">return</span> value;}</code></pre><p>果不其然，苹果也是按照我们的猜想去做的这件事。  </p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>根据我们的猜想然后去分析苹果的源码，发现苹果为分类的属性建造了一个大的hashmap，这个大的hashmap的里面又根据对象划分了多个子hashmap，划分的依照object来划分。每个子hashmap中存放了各个分类添加的属性。注意：每个分类的属性使用对象关联去关联属性的时候千万要保证key值得唯一性，否则会出现后面的存储覆盖掉前面的存储的情况。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要分析iOS对象关联的实现。&lt;br&gt;
    
    </summary>
    
      <category term="lixiaoqiang" scheme="http://xgfe.github.io/categories/lixiaoqiang/"/>
    
    
      <category term="iOS" scheme="http://xgfe.github.io/tags/iOS/"/>
    
      <category term="Catogery" scheme="http://xgfe.github.io/tags/Catogery/"/>
    
  </entry>
  
  <entry>
    <title>Android Zxing 扫码封装</title>
    <link href="http://xgfe.github.io/2018/03/20/Catherine/AndroidZxing%E6%89%AB%E7%A0%81%E5%B0%81%E8%A3%85/"/>
    <id>http://xgfe.github.io/2018/03/20/Catherine/AndroidZxing扫码封装/</id>
    <published>2018-03-20T02:49:30.000Z</published>
    <updated>2018-08-24T03:48:57.226Z</updated>
    
    <content type="html"><![CDATA[<p>Zxing 是一个开放源码的，用 Java 实现的多种格式的 1D/2D 条码图像处理库，它包含了联系到其他语言的端口。Zxing 可以实现使用手机的内置的摄像头完成条形码的扫描及解码。</p><a id="more"></a><h2 id="一、条码码型"><a href="#一、条码码型" class="headerlink" title="一、条码码型"></a>一、条码码型</h2><p>Zxing 目前支持扫描和解析以下码型：</p><table><thead><tr><th>码型</th><th>中文名</th><th>维度</th><th>字符类型</th></tr></thead><tbody><tr><td>AZTEC</td><td>阿兹特克码</td><td>2D</td><td>ASCII</td></tr><tr><td>CODABAR</td><td>库德巴码</td><td>1D</td><td>数字、字母</td></tr><tr><td>CODE_39</td><td>39码</td><td>1D</td><td>(0-9)10个数字、“ABCD”四个字母和“$-:/.+”六个特殊字符</td></tr><tr><td>CODE_93</td><td>93码</td><td>1D</td><td>(0-9)10个数字、“ABCD”四个字母和“$-:/.+”六个特殊字符</td></tr><tr><td>CODE_128</td><td>128码</td><td>1D</td><td>ASCII</td></tr><tr><td>DATA_MATRIX</td><td>Matrix 25码</td><td>2D</td><td>任意字符</td></tr><tr><td>EAN_8</td><td>EAN商品码</td><td>1D</td><td>数字</td></tr><tr><td>EAN_13</td><td>EAN商品码</td><td>1D</td><td>数字</td></tr><tr><td>ITF</td><td>交插25码</td><td>1D</td><td>数字</td></tr><tr><td>MAXICODE</td><td>UPC快递码</td><td>2D</td><td>ASCII</td></tr><tr><td>PDF_417</td><td>PDF417</td><td>2D</td><td>扩展的字母数字压缩格式、二进制 、ASCII、数字压缩格式</td></tr><tr><td>QR_CODE</td><td>二维条码</td><td>2D</td><td>任意字符</td></tr><tr><td>RSS_14</td><td>RSS码</td><td>1D+2D</td><td>数字</td></tr><tr><td>RSS_EXPANDED</td><td>RSS码</td><td>1D+2D</td><td>数字</td></tr><tr><td>UPC_A</td><td>UPC美国码</td><td>1D</td><td>数字</td></tr><tr><td>UPC_E</td><td>UPC美国码</td><td>1D</td><td>数字</td></tr><tr><td>UPC_EAN_EXTENSION</td><td>EAN/UPC混合码</td><td>1D</td><td>数字</td></tr></tbody></table><p>在 <code>build.gradle</code> 中引入依赖：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">implementation &quot;com.google.zxing:core:$&#123;zxingCoreVer&#125;&quot;</span><br><span class="line">implementation &quot;com.google.zxing:android-core:$&#123;zxingAndroidVer&#125;&quot;</span><br><span class="line">implementation &quot;com.google.zxing:android-integration:$&#123;zxingAndroidVer&#125;&quot;</span><br></pre></td></tr></table></figure><p>引入依赖后即可使用 Zxing 的解码库，对条形码或二维码进行解析，但是需要封装扫码界面、取图流程和解析后的数据返回，才能方便 Android 应用中使用。为此，我们封装了整个扫码和解析的组件库，使得 Android 应用中仅需关注布局的构建。</p><h2 id="二、CaptureActivity-界面部分封装"><a href="#二、CaptureActivity-界面部分封装" class="headerlink" title="二、CaptureActivity 界面部分封装"></a>二、CaptureActivity 界面部分封装</h2><p><code>CaptureActivity</code> 是一个抽象类，继承于 <code>AppCompatActivity</code> ，这个Activity不包含界面，所以其子类需要在 <code>onCreate()</code> 中设置布局。</p><p><code>CaptureActivity</code> 中有多个抽象方法：</p><ul><li>boolean getResult(Result, byte[]) : 每次扫码结束后会调用此方法，实现类可以从参数中获取扫码结果；</li><li>SurfaceView getScanPreview() : 子类 Activity 需要自定义布局，可实现此方法，返回自定义布局中的 <code>SurfaceView</code> 对象；</li><li>View getCropView() : 返回子类自定义布局中的扫码框 View，用于裁剪取图图片。</li></ul><p><code>CaptureActivity</code> 中封装了扫码的流程，包括：</p><ol><li>摄像头预览：通过 <code>SurfaceView</code> 和 <code>Camera</code> 的初始化，在界面中显示摄像头的预览画面；</li><li>自动取图：通过定时获取 <code>SurfaceView</code> 预览图片的方式，得到预览图的二进制数据，然后裁剪出扫码框中部分；</li><li>解析：通过 Zxing Core 解析图片的二进制数据，获取解析结果；</li><li>封装解析结果：结果包含一个字符串、一个图片二进制数组、条码位置数组，封装为 <code>Result</code> 对象；</li><li>界面接收结果：通过抽象方法 <code>boolean getResult(Result, byte[])</code> ，将结果返回给子类 Activity 。</li></ol><p>另外，此抽象类中还封装了扫码界面中常用闪光灯开关方法，并且封装了适配 Android 6.0 的动态权限申请。</p><h3 id="2-1-摄像头预览"><a href="#2-1-摄像头预览" class="headerlink" title="2.1 摄像头预览"></a>2.1 摄像头预览</h3><p>为了在界面中显示摄像头预览画面，需要子类 Activity 提供布局中的 <code>SurfaceView</code> 对象，即可在 Activity 生命周期中处理其初始化和销毁：</p><ul><li>完成 <code>SurfaceView</code> 的初始化后，打开 <code>Camera</code> 获取摄像头数据显示预览画面；</li><li>在 Activity 暂停时，停止预览，释放 <code>Camera</code> 资源；</li><li>在 Activity 重新显示时，重新初始化。</li></ul><h3 id="2-2-自动取图"><a href="#2-2-自动取图" class="headerlink" title="2.2 自动取图"></a>2.2 自动取图</h3><p>取图，即获取 <code>SurfaceView</code> 预览画面的一帧图片。为 <code>SurfaceView</code> 设置取图回调，即可在请求取图后，获取到此刻一帧图像的二进制数据。</p><p>自动取图的实现方式有很多种：</p><ol><li>自动对焦方式，启动摄像头的自动对焦功能，在每次对焦成功的回调中执行取图。这种取图方式依赖自动对焦，在极端情况下可能无法对焦，或者对焦时间较长，造成扫码速度降低。</li><li>定时取图方式，需要开启定时任务，每隔一定时间请求取图方法。这种取图方法的取图间隔是固定的，可以提高取图速度，但是在解析速度较慢的手机上可能出现解析未完成而再次取图的情况，造成混乱。</li><li>线性取图方式，即完成“取图——解析——取图”的线性操作，取图和解析都是由我们自己的代码请求的，这样可以完全控制整个操作流程，避免了定时取图的弊端；因为不需要在完成对焦后再取图，我们可以通过控制延迟时间控制取图速度。</li></ol><p>建议使用线性取图方式，以完全控制取图速度和取图过程，也可以在子类 Activity 获取到结果后，自由控制继续取图或暂停取图。</p><h3 id="2-3-解析图片"><a href="#2-3-解析图片" class="headerlink" title="2.3 解析图片"></a>2.3 解析图片</h3><p>解析取图数据的过程由 zxing:core 库完成。</p><p>具体解析原理代码较多，此处不详述，代码在 <code>com.google.zxing.MultiFormatReader</code> 中。</p><h3 id="2-4-结果封装"><a href="#2-4-结果封装" class="headerlink" title="2.4 结果封装"></a>2.4 结果封装</h3><p><code>com.google.zxing.Result</code> 类中定义了扫码结果。</p><ul><li>String text: 即上一步解析出来的字符串；</li><li>byte[] rawBytes: 图片的二进制数据；</li><li>ResultPoint[] resultPoints: 一个或多个关键点，可以用于在界面中标出条码位置；</li><li>BarcodeFormat format: 条码的码型；</li><li>long timestamp: 时间戳。</li></ul><p>以上数据，可以帮助我们获取扫码结果和展示友好的界面。</p><h2 id="三、预览和摄像头"><a href="#三、预览和摄像头" class="headerlink" title="三、预览和摄像头"></a>三、预览和摄像头</h2><p>我们将摄像头预览相关的操作，封装在 <code>camera</code> 包中，关键类有：</p><ul><li>CameraManager：控制摄像头的开启和关闭；</li><li>CameraConfigurationManager：设置摄像头和预览的参数；</li><li>AutoFocusManager：控制摄像头的自动对焦。</li></ul><h2 id="四、图片解析"><a href="#四、图片解析" class="headerlink" title="四、图片解析"></a>四、图片解析</h2><p>我们将图片解析相关的操作，封装在 <code>decode</code> 包中，关键类有：</p><ul><li>DecodeHandler: 从摄像头获取的原始二进制数据是 YUV 格式，我们在此类中将其转换为 <code>Bitmap</code> ，然后发送到 zxing:core 库解析；</li><li>DecodeThread: 解析图片是耗时操作，所以需要在非 UI 线程中进行。</li></ul><p>在 <code>DecodeThread</code> 类中，我们定义了多种码型组合，例如所有条形码、条形码与二维码、CODE128与二维码等，以满足不同业务场景。在 <code>CaptureActivity</code> 中定义了方法 <code>int getBarcodeMode()</code>，可以在子类中重写，即可定义应用需要的码型。</p><blockquote><p>注意：支持的码型数量越多，解析速度越慢；二维码的解析速度大大慢于一维码的解析速度。</p></blockquote><h2 id="五、App-中实现扫码界面"><a href="#五、App-中实现扫码界面" class="headerlink" title="五、App 中实现扫码界面"></a>五、App 中实现扫码界面</h2><p>在依赖以上组件库后，即可快速实现扫码功能，在 App 开发中仅需自定义界面即可。</p><p>我们首先继承 <code>CaptureActivity</code> ，创建 <code>MyScanActivity</code> 和布局文件 <code>activity_my_scan.xml</code></p><p>MyScanActivity.java:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyScanActivity</span> <span class="keyword">extends</span> <span class="title">CaptureActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> SurfaceView mPreviewSv;</span><br><span class="line">    <span class="keyword">private</span> View mCropView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_my_scan);</span><br><span class="line">        mPreviewSv = findViewById(R.id.scan_preview);</span><br><span class="line">        mCropView = findViewById(R.id.scan_crop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取扫码结果</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> result 扫码结果</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes  图片二进制数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> true - 继续扫描；false - 暂停扫描</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">getResult</span><span class="params">(Result result, <span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span> || TextUtils.isEmpty(result.getText()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> SurfaceView <span class="title">getScanPreview</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mPreviewSv;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@NonNull</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> View <span class="title">getCropView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mCropView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>activity_my_scan.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">FrameLayout</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">SurfaceView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/scan_preview"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">View</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/scan_crop"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"300dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"200dp"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_gravity</span>=<span class="string">"center"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:background</span>=<span class="string">"#33ffffff"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">FrameLayout</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>以上仅仅是实现扫码界面的最简单代码，如果需要更好的界面效果，还需要修改布局和获取结果后的逻辑。</p></blockquote><p>至此，我们就快速实现了扫码页面的功能。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Zxing 是一个开放源码的，用 Java 实现的多种格式的 1D/2D 条码图像处理库，它包含了联系到其他语言的端口。Zxing 可以实现使用手机的内置的摄像头完成条形码的扫描及解码。&lt;/p&gt;
    
    </summary>
    
      <category term="Catherine" scheme="http://xgfe.github.io/categories/Catherine/"/>
    
    
      <category term="Android" scheme="http://xgfe.github.io/tags/Android/"/>
    
      <category term="Zxing" scheme="http://xgfe.github.io/tags/Zxing/"/>
    
  </entry>
  
  <entry>
    <title>实现一个React 组件</title>
    <link href="http://xgfe.github.io/2018/03/04/zhouyinian/React-component/"/>
    <id>http://xgfe.github.io/2018/03/04/zhouyinian/React-component/</id>
    <published>2018-03-04T06:00:00.000Z</published>
    <updated>2018-08-24T03:48:57.270Z</updated>
    
    <content type="html"><![CDATA[<p>本文简单介绍了如何在React中编写组件。<br><a id="more"></a></p><h3 id="项目的搭建"><a href="#项目的搭建" class="headerlink" title="项目的搭建"></a>项目的搭建</h3><p>为了加快演示，用react-create-app快速搭建项目</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">create-react-app react-learn-component</span><br><span class="line">cd react-learn-component</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm run start</span><br></pre></td></tr></table></figure><p>浏览器会自动打开如下页面</p><p><img src="//ww1.sinaimg.cn/large/933205a1ly1fp01hatymlj20y60hg75l.jpg"></p><p>更多关于react-create-app介绍：<a href="//github.com/facebook/create-react-app">传送门</a></p><h3 id="组件的介绍"><a href="#组件的介绍" class="headerlink" title="组件的介绍"></a>组件的介绍</h3><blockquote><p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</p></blockquote><p>组件可以让你把UI切分成独立的、可复用的块去单独的考虑和开发。</p><h3 id="React中组件的分类"><a href="#React中组件的分类" class="headerlink" title="React中组件的分类"></a>React中组件的分类</h3><h4 id="展示型组件（presentational）"><a href="#展示型组件（presentational）" class="headerlink" title="展示型组件（presentational）"></a>展示型组件（presentational）</h4><p>展示型组件是用来展示样式的，他们对应用的其余部分没有依赖性，会通过props明确地接收数据，可以写成函数的形式。如下的BlogList组件只是接收一个<code>bolglist</code>数组，便能展示博客列表，相同的输入会有相同的输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import React from &quot;react&quot;;</span><br><span class="line">export const BlogList = bloglist =&gt; (  </span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            bloglist.map((&#123; body,author,id &#125;) =&gt;      </span><br><span class="line">                &lt;li key=&#123;id&#125;&gt;&#123;body&#125;-&#123;author&#125;&lt;/li&gt; </span><br><span class="line">            )</span><br><span class="line">        &#125;     </span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h4 id="容器型组件-container"><a href="#容器型组件-container" class="headerlink" title="容器型组件(container)"></a>容器型组件(container)</h4><p>容器型组件关心组件如何工作，可以为展示组件或其他容器组件提供数据，通常是有状态的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">import React,&#123;Component&#125; from &quot;react&quot;;</span><br><span class="line">import &#123;BlogList&#125; from &apos;../BlogList/BlogList&apos;</span><br><span class="line">class Blog extends Component &#123;</span><br><span class="line">    constructor(props)&#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            blogList:[]</span><br><span class="line">        &#125;</span><br><span class="line">        this.showBlodList = this.showBlodList.bind(this)</span><br><span class="line">    &#125;</span><br><span class="line">    componentDidMount()&#123;</span><br><span class="line">        const blogList = [</span><br><span class="line">            &#123;</span><br><span class="line">                id:1,</span><br><span class="line">                author:&apos;zyn&apos;,</span><br><span class="line">                body:&apos;这是blog内容111&apos;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">                id:2,</span><br><span class="line">                author:&apos;zyn&apos;,</span><br><span class="line">                body:&apos;这是blog内容222&apos;</span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">        this.setState(&#123;</span><br><span class="line">            blogList</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">    showBlodList()&#123;</span><br><span class="line">        console.log(this.state.blogList)</span><br><span class="line">    &#125;</span><br><span class="line">    render()&#123;</span><br><span class="line">        const &#123;blogList&#125; = this.state</span><br><span class="line">        return(</span><br><span class="line">            &lt;div&gt;</span><br><span class="line">                &#123;BlogList(blogList)&#125;</span><br><span class="line">                &lt;button type=&quot;button&quot; onClick=&#123;this.showBlodList&#125;&gt;点击我&lt;/button&gt;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default Blog</span><br></pre></td></tr></table></figure><p>显示效果如图</p><p><img src="//ww1.sinaimg.cn/large/933205a1ly1fp020d7trzj21vi0okdl3.jpg"></p><h3 id="编写一个复选框组件"><a href="#编写一个复选框组件" class="headerlink" title="编写一个复选框组件"></a>编写一个复选框组件</h3><p>最近用了AngularJS 和 Vue, 在写表单的时候基于双向数据绑定，写起来是相当的happy，当然React的单向数据流也有着自己的优点。基于此我们可以对项目中常用的表单控件进行组件的封装，下面以复选框为例。</p><h4 id="第一步，创建文件"><a href="#第一步，创建文件" class="headerlink" title="第一步，创建文件"></a>第一步，创建文件</h4><p>首先我们在 components 文件夹下面创建Checkbox文件夹以及Checkbox.js 文件,先写一个无状态组件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// CheckBox.js</span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">class CheckBox extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;label&gt;&lt;input type=&quot;checkbox&quot; /&gt;点击我&lt;/label&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default CheckBox</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">// App.js</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import logo from &apos;./logo.svg&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import Blog from &apos;./components/Blog/Blog&apos;</span><br><span class="line">import CheckBox from &apos;./components/CheckBox/CheckBox&apos;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;header className=&quot;App-header&quot;&gt;</span><br><span class="line">          &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">        &lt;p className=&quot;App-intro&quot;&gt;</span><br><span class="line">          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;Blog/&gt;</span><br><span class="line">        &lt;CheckBox/&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>如图，会出现一个<code>点击我</code>的复选框</p><p><img src="//ww1.sinaimg.cn/large/933205a1ly1fp02g9zniej21aq0pedi9.jpg"></p><h4 id="第二步，实现label的可配置"><a href="#第二步，实现label的可配置" class="headerlink" title="第二步，实现label的可配置"></a>第二步，实现label的可配置</h4><p>我们会发现复选框的 <code>label</code> 的文字 <code>点击我</code> 是写死的，那么怎么让 <code>label</code> 的动态传入呢？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//Checkbox.js</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">class CheckBox extends Component &#123;</span><br><span class="line">    render() &#123;</span><br><span class="line">        return (</span><br><span class="line">            &lt;label&gt;</span><br><span class="line">                &lt;input type=&quot;checkbox&quot; /&gt;</span><br><span class="line"></span><br><span class="line">                //这里由‘点击我’换成了如下代码</span><br><span class="line">                &#123;this.props.children !== undefined ? this.props.children : null&#125;</span><br><span class="line">            &lt;/label&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default CheckBox</span><br></pre></td></tr></table></figure><p>这里要注意<code>this.props.children</code> 表示当前组件的所有子节点。<code>this.props.children</code> 的值有三种可能：如果当前组件没有子节点，它就是 <code>undefined</code> ;如果有一个子节点，数据类型是 <code>object</code> ；如果有多个子节点，数据类型就是 <code>array</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">//App.js</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import logo from &apos;./logo.svg&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import Blog from &apos;./components/Blog/Blog&apos;</span><br><span class="line">import CheckBox from &apos;./components/CheckBox/CheckBox&apos;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;header className=&quot;App-header&quot;&gt;</span><br><span class="line">          &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">        &lt;p className=&quot;App-intro&quot;&gt;</span><br><span class="line">          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;Blog/&gt;</span><br><span class="line">        &lt;CheckBox&gt;按钮1&lt;/CheckBox&gt;</span><br><span class="line">        &lt;CheckBox&gt;按钮2&lt;/CheckBox&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p>查看浏览器，可以看到按钮的label已经变成可以配置的了。</p><p><img src="//ww1.sinaimg.cn/large/933205a1ly1fp02tjojipj21ai0mo0vb.jpg"></p><h4 id="第三步，实现可控组件及获值"><a href="#第三步，实现可控组件及获值" class="headerlink" title="第三步，实现可控组件及获值"></a>第三步，实现可控组件及获值</h4><p>现在的复选框的选中状态是由自身去控制的，也就是说现在还无法去动态控制复选框的选中状态。同时，在业务需求中，如果有多个复选框，我们希望可以获得选中的复选框的数据。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">// Checkbox.js</span><br><span class="line"></span><br><span class="line">import React from &quot;react&quot;;</span><br><span class="line">class CheckBox extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.checkCheckBox = this.checkCheckBox.bind(this);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            is_checked: props.checked || false,</span><br><span class="line">            value: props.value || &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps(nextProps)&#123;</span><br><span class="line">        if(&apos;checked&apos; in nextProps)&#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                is_checked:nextProps.checked || false</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    checkCheckBox() &#123;</span><br><span class="line">        const onChange = this.props.onChange;</span><br><span class="line">        const value = this.props.value;</span><br><span class="line">        if (onChange) &#123;</span><br><span class="line">            onChange(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        let &#123; is_checked, value &#125; = this.state;</span><br><span class="line">        return (</span><br><span class="line">            &lt;label&gt;</span><br><span class="line">                &lt;input value=&#123;value&#125; type=&quot;checkbox&quot; onClick=&#123;this.checkCheckBox&#125; checked=&#123;is_checked&#125; /&gt;</span><br><span class="line">                &#123;this.props.children !== undefined ? this.props.children : null&#125;</span><br><span class="line">            &lt;/label&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">export default CheckBox;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">//App.js</span><br><span class="line"></span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import logo from &apos;./logo.svg&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import Blog from &apos;./components/Blog/Blog&apos;</span><br><span class="line">import CheckBox from &apos;./components/CheckBox/CheckBox&apos;</span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    checkedList: []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  changeCheckBox = (value) =&gt; &#123;</span><br><span class="line">    const valueIndex = this.state.checkedList.indexOf(value)</span><br><span class="line">    const checkedList = [...this.state.checkedList]</span><br><span class="line">    if (valueIndex === -1) &#123;</span><br><span class="line">      checkedList.push(value);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      checkedList.splice(valueIndex, 1);</span><br><span class="line">    &#125;</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      checkedList</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getChecked = (value) =&gt; &#123;</span><br><span class="line">    const valueIndex = this.state.checkedList.indexOf(value)</span><br><span class="line">    if (valueIndex === -1) &#123;</span><br><span class="line">      return false</span><br><span class="line">    &#125;</span><br><span class="line">    return true</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    console.log(&apos;当前点击&apos;, this.state.checkedList)</span><br><span class="line">    console.log(&apos;当前点击&apos;, this.getChecked(&apos;按钮1&apos;))</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;header className=&quot;App-header&quot;&gt;</span><br><span class="line">          &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;</span><br><span class="line">          &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;</span><br><span class="line">        &lt;/header&gt;</span><br><span class="line">        &lt;p className=&quot;App-intro&quot;&gt;</span><br><span class="line">          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;Blog /&gt;</span><br><span class="line">        &lt;CheckBox key=&quot;1&quot; value=&quot;按钮1&quot; checked=&#123;this.getChecked(&apos;按钮1&apos;)&#125; onChange=&#123;this.changeCheckBox&#125;&gt;按钮1&lt;/CheckBox&gt;</span><br><span class="line">        &lt;CheckBox key=&quot;2&quot; value=&quot;按钮2&quot; checked=&#123;this.getChecked(&apos;按钮2&apos;)&#125; onChange=&#123;this.changeCheckBox&#125;&gt;按钮2&lt;/CheckBox&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure><p><img src="http://ww1.sinaimg.cn/large/933205a1ly1fp03zn79w8j21m60osaea.jpg"><br>上述代码，复选框增加了自身的状态，初始的<code>state</code>默认从<code>props</code>中读取，再在<code>onChange</code>的时候，再把组件的<code>value</code> 值传上去，然后在父组件中获取，从而实现复选框的可控制，并且可以在控制台中获取到了我们想要的值。</p><h4 id="第四步，封装CheckBoxGroup组件"><a href="#第四步，封装CheckBoxGroup组件" class="headerlink" title="第四步，封装CheckBoxGroup组件"></a>第四步，封装CheckBoxGroup组件</h4><p>通过第三步，我们基本实现了我们的需求，但是App.js 文件里面操控复选框组件的逻辑代码太多了，影响了组件的简洁和使用。所以我们打算封装CheckBoxGroup 来包裹我们的复选框组件，把App.js中的逻辑抽离到CheckBoxGroup 组件上。</p><p>首先创建CheckBoxGroup.js 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">// CheckBoxGroup.js</span><br><span class="line">import React from &quot;react&quot;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line">class CheckBoxGroup extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            value: props.value || props.defaultValue || [],</span><br><span class="line">        &#125;;</span><br><span class="line">        this.toggleOption = this.toggleOption.bind(this);</span><br><span class="line">    &#125;</span><br><span class="line">    componentWillReceiveProps(nextProps) &#123;</span><br><span class="line">        if (&apos;value&apos; in nextProps) &#123;</span><br><span class="line">            this.setState(&#123;</span><br><span class="line">                value: nextProps.value || [],</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    getChildContext() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">            checkboxGroup: &#123;</span><br><span class="line">                toggleOption: this.toggleOption,</span><br><span class="line">                value: this.state.value,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    toggleOption(option) &#123;</span><br><span class="line">        const optionIndex = this.state.value.indexOf(option.value);</span><br><span class="line">        const value = [...this.state.value];</span><br><span class="line">        if (optionIndex === -1) &#123;</span><br><span class="line">            value.push(option.value);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            value.splice(optionIndex, 1);</span><br><span class="line">        &#125;</span><br><span class="line">        if (!(&apos;value&apos; in this.props)) &#123;</span><br><span class="line">            this.setState(&#123; value &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        const onChange = this.props.onChange;</span><br><span class="line">        if (onChange) &#123;</span><br><span class="line">            onChange(value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        const &#123; children, className &#125; = this.props</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#123;className&#125;&gt;</span><br><span class="line">                &#123;children&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CheckBoxGroup.childContextTypes = &#123;</span><br><span class="line">    checkboxGroup: PropTypes.any,</span><br><span class="line">&#125;;</span><br><span class="line">export default CheckBoxGroup</span><br></pre></td></tr></table></figure><p>代码分析：首先从<code>render</code> 开始</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">        const &#123; children, className &#125; = this.props</span><br><span class="line">        return (</span><br><span class="line">            &lt;div className=&#123;className&#125;&gt;</span><br><span class="line">                &#123;children&#125;</span><br><span class="line">            &lt;/div&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这块代码和上面<code>BlodList</code>那里一样，也是通过<code>this.props.children</code> 加载子节点。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">getChildContext() &#123;</span><br><span class="line">       return &#123;</span><br><span class="line">           checkboxGroup: &#123;</span><br><span class="line">               toggleOption: this.toggleOption,</span><br><span class="line">               value: this.state.value,</span><br><span class="line">           &#125;,</span><br><span class="line">       &#125;;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>子组件可以通过设置<code>contextTypes</code>类型后在<code>this.content</code>访问到父组件的<code>getChildContext</code>函数返回的对象属性，需要注意的是，getChildContext 指定的传递给子组件的属性需要先通过 childContextTypes 来指定，不然会产生错误。</p><p>同时，在子组件要把受控状态转移到<code>this.content</code>监听的对象中。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">//CheckBox.js</span><br><span class="line">import React from &quot;react&quot;</span><br><span class="line">import PropTypes from &apos;prop-types&apos;;</span><br><span class="line">import CheckBoxGroup from &apos;../CheckBoxGroup/CheckBoxGroup&apos;</span><br><span class="line">class CheckBox extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props)</span><br><span class="line">        this.checkCheckBox = this.checkCheckBox.bind(this);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            is_checked: props.checked || false,</span><br><span class="line">            value: props.value || &apos;&apos;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    checkCheckBox() &#123;</span><br><span class="line">        const &#123; checkboxGroup &#125; = this.context;</span><br><span class="line">        if (checkboxGroup) &#123;</span><br><span class="line">            checkboxGroup.toggleOption(&#123; label: this.props.children, value: this.props.value &#125;)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            const onChange = this.props.onChange;</span><br><span class="line">            const value = this.props.value;</span><br><span class="line">            if (onChange) &#123;</span><br><span class="line">                onChange(value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">        let &#123; is_checked, value &#125; = this.state;</span><br><span class="line">        const &#123; checkboxGroup &#125; = this.context;</span><br><span class="line">        if (checkboxGroup) &#123;</span><br><span class="line">            is_checked = checkboxGroup.value.indexOf(this.props.value) !== -1;</span><br><span class="line">        &#125;</span><br><span class="line">        return (</span><br><span class="line">            &lt;label&gt;</span><br><span class="line">                &lt;input value=&#123;value&#125; type=&quot;checkbox&quot; checked=&#123;is_checked&#125;</span><br><span class="line">                    onClick=&#123;this.checkCheckBox&#125; /&gt;</span><br><span class="line">                &#123;this.props.children !== undefined ? this.props.children : null&#125;</span><br><span class="line">            &lt;/label&gt;</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">CheckBox.Group = CheckBoxGroup;</span><br><span class="line">CheckBox.contextTypes = &#123;</span><br><span class="line">    checkboxGroup: PropTypes.any,</span><br><span class="line">&#125;</span><br><span class="line">export default CheckBox;</span><br></pre></td></tr></table></figure><p>子组件在点击的时候，会先判断是否有包裹的<code>this.content.checkboxGroup</code> 属性。如果有，就把状态转移到包裹的组件去管理。<br><code>CheckBox.Group = CheckboxGroup</code> 这段代码方便外部调用组件，即想引用CheckBoxGroup组件可以写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import CheckBox from &apos;./components/CheckBox/CheckBox&apos;</span><br><span class="line">const CheckBoxGroup = CheckBox.Group;</span><br></pre></td></tr></table></figure><p>然后在App.js 中引入<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">//App.js</span><br><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import logo from &apos;./logo.svg&apos;;</span><br><span class="line">import &apos;./App.css&apos;;</span><br><span class="line">import Blog from &apos;./components/Blog/Blog&apos;</span><br><span class="line">import CheckBox from &apos;./components/CheckBox/CheckBox&apos;</span><br><span class="line">const CheckBoxGroup = CheckBox.Group;</span><br><span class="line"></span><br><span class="line">class App extends Component &#123;</span><br><span class="line">  state=&#123;</span><br><span class="line">    checkList:[]</span><br><span class="line">  &#125;</span><br><span class="line">  selectCheckBtn=(values)=&gt;&#123;</span><br><span class="line">    console.log(values)</span><br><span class="line">    this.setState(&#123;</span><br><span class="line">      checkList:values</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">    render() &#123;</span><br><span class="line">    const &#123;checkList&#125; = this.state</span><br><span class="line">    return (</span><br><span class="line">      &lt;div className=&quot;App&quot;&gt;</span><br><span class="line">        &lt;header className=&quot;App-header&quot;&gt; </span><br><span class="line">         &lt;img src=&#123;logo&#125; className=&quot;App-logo&quot; alt=&quot;logo&quot; /&gt;  </span><br><span class="line">         &lt;h1 className=&quot;App-title&quot;&gt;Welcome to React&lt;/h1&gt;</span><br><span class="line">        &lt;/header&gt; </span><br><span class="line">        &lt;p className=&quot;App-intro&quot;&gt;</span><br><span class="line">          To get started, edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.</span><br><span class="line">        &lt;/p&gt;</span><br><span class="line">        &lt;Blog/&gt;</span><br><span class="line">        &lt;CheckBoxGroup value=&#123;checkList&#125; onChange=&#123;this.selectCheckBtn&#125;&gt; </span><br><span class="line">          &lt;CheckBox value=&#123;&apos;1&apos;&#125;&gt;按钮1&lt;/CheckBox&gt;</span><br><span class="line">          &lt;CheckBox value=&#123;&apos;2&apos;&#125;&gt;按钮2&lt;/CheckBox&gt;</span><br><span class="line">          &lt;CheckBox value=&#123;&apos;3&apos;&#125;&gt;按钮3&lt;/CheckBox&gt;</span><br><span class="line">          &lt;CheckBox value=&#123;&apos;4&apos;&#125;&gt;按钮4&lt;/CheckBox&gt;</span><br><span class="line">        &lt;/CheckBoxGroup&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;&#125;</span><br><span class="line">export default App;</span><br></pre></td></tr></table></figure></p><p>最后在浏览器点击复选框</p><p><img src="//ww1.sinaimg.cn/large/933205a1ly1fp04zmphioj21py0pygpy.jpg"></p><p>现在，我们就完成了一个复选框组件，可以给组件加上一些样式美化一下，然后在需要的时候直接引用就好了。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>写一个组件很容易，但是写好一个组件就不是那么容易的事了，React也有一些现在比较成熟的UI组件库，比如蚂蚁金服的Antd Design <a href="//github.com/ant-design/ant-design/">传送门</a> ，可以打开看看里面的源码学习一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文简单介绍了如何在React中编写组件。&lt;br&gt;
    
    </summary>
    
      <category term="zhouyinian" scheme="http://xgfe.github.io/categories/zhouyinian/"/>
    
    
      <category term="React" scheme="http://xgfe.github.io/tags/React/"/>
    
      <category term="component" scheme="http://xgfe.github.io/tags/component/"/>
    
  </entry>
  
  <entry>
    <title>ListView源码分析</title>
    <link href="http://xgfe.github.io/2018/02/09/caominkang/ListView%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://xgfe.github.io/2018/02/09/caominkang/ListView源码分析/</id>
    <published>2018-02-09T05:12:00.000Z</published>
    <updated>2018-08-24T03:48:57.231Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要是分析ListView源码，重点关注复用机制。</p><a id="more"></a><h1 id="ListView源码解析"><a href="#ListView源码解析" class="headerlink" title="ListView源码解析"></a>ListView源码解析</h1><p>&nbsp;&nbsp;本文分为三个部分，第一个部分提取出RecycleBin的相关代码，对RecyleBin做基本讲解；第二部分讲解ListView初始化时onLayout过程；第三部分讲解ListView如何在屏幕滑动中实现复用。</p><h2 id="一、RecycleBin"><a href="#一、RecycleBin" class="headerlink" title="一、RecycleBin"></a>一、RecycleBin</h2><p>&nbsp;&nbsp;RecycleBin是AbsListView的子类，也就是说只要是继承自AbsListView的，都可以使用这个机制，代码结构大概如下：</p><pre><code>class RecycleBin{    private int mFirstPosition;    private View[] mActiveViews = new View[0];    private int mViewTypeCount;    private ArrayList&lt;View&gt;[] mScrapViews;    private ArrayList&lt;View&gt; mCurrentScrap;    void fillActiveViews(int childCount,int firstActivePostion)    void getActiveView(int position);    void addScrapView(View scrap);    View getSrapView(int position);    public void setViewTypeCount(int viewTypeCount);}</code></pre><p>下面介绍字段和api：</p><ul><li>mFirstPosition指的是mActiveView[0]中存储的View在数据中的position。</li><li>mActiveViews缓存的是第一屏的数据，后面的讲解中会说明，主要是在ListView初始化中起作用</li><li>mViewTypeCount代表数据种类，值由setViewTypeCount方法设置。ListView可以处理不同种类的数据</li><li>mScrapViews用来缓存移出到屏幕外的view，因为ListView支持不同种类数据，所以mScrapViews是一个二维数组，对应不同种类数据，使用不同的ArrayList去缓存。</li><li>fillActiveViews是将屏幕上可以看到的view缓存到mActiveViews中</li><li>getActiveViews将指定的位置的view从mActiveViews中取出来，需要注意的是，取出后再次获取该位置view会返回空。</li><li>getScrapView用于从mScrapView中取出view，由于同种数据类型的view都是相同的，所以该方法只是返回该类型最后一个位置的view。</li></ul><p>也就是说RecycleBin有两种缓存view的模式：ActiveView和ScrapView.ListView在初始化过程中使用mActiveViews来缓存显示在屏幕中的view，在滚动过程中使用mScrapView缓存移除到屏幕外的数据，实现复用。下面我来具体看ListView是如何通过调用RecycleBin的方法来管理view的复用。</p><h2 id="二、ListView初始化过程"><a href="#二、ListView初始化过程" class="headerlink" title="二、ListView初始化过程"></a>二、ListView初始化过程</h2><p>&nbsp;&nbsp;重点关注ListView初始化过程中onLayout过程，因为与RecycleBin交互主要在这个过程。我们知道，android视图树的根节点是FrameLayout子类，而FrameLayout会让子view执行两次onLayout过程，ListView也不例外，也会有两次onLayout过程。</p><h3 id="1-第一次onLayout"><a href="#1-第一次onLayout" class="headerlink" title="1.第一次onLayout"></a>1.第一次onLayout</h3><p>&nbsp;&nbsp;ListView中没有复写父类AbsListView的onLayout方法，不过在父类onLayout中，做完数据判断后，直接调用了layoutChildren，并且注释有说明，子类不应该复写onLayout方法，而该复写layoutChildren。由于layoutChildren需要针对两次onLayout处理，所以判断和分支流程特别复杂，抽取出第一次调用的流程，大概如下：</p><pre><code> protected void layoutChildren(){    int childCount = getChildCount();    switch(mLayoutMode){    }    boolean dataChanged = mDataChanged;    if(dataChanged){    }else{        recycleBin.fillActiveView(childCount,firstPosition);    }    detachAllViewsFromParent();    switch (mLayoutMode){        default:            if(childCount==0)                fillFromTop(childrenTop);            else                fillSpecific(0,childrenTop)    }}</code></pre><p>&nbsp;&nbsp;以上是代码结构，省去了很多与分析流程无关的代码，可以看到，由于我们数据源没有变化，dataChanged等于false，进入fillActiveViews，但是此时ListView没有任何子view，childCount为0，这行代码没有任何作用，进入switch语句后，进入default分支，调用fillFromTop。我们进入该函数，发现主要调用了fillDown方法，完整代码如下</p><pre><code>private View fillDown(int pos, int nextTop) {    View selectedView = null;    int end = (getBottom() - getTop()) - mListPadding.bottom;    while (nextTop &lt; end &amp;&amp; pos &lt; mItemCount) {        // is this the selected item?          boolean selected = pos == mSelectedPosition;        View child = makeAndAddView(pos, nextTop, true, mListPadding.left, selected);        nextTop = child.getBottom() + mDividerHeight;        if (selected) {            selectedView = child;        }        pos++;    }    return selectedView;}</code></pre><p>&nbsp;&nbsp;可以看到，循环调用makeAndAddView（）方法，终止条件是数据项加载完或者最后一个子view的top小于ListView的底部。实现从ListView顶部一直填充到ListView底部，那么makeAndAddView方法肯定是构建view并且填充view到ListView中，下面是相关代码：</p><pre><code> private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,                            boolean selected) {    View child;    if (!mDataChanged) {        // Try to use an exsiting view for this position        child = mRecycler.getActiveView(position);        if (child != null) {            // Found it -- we&apos;re using an existing child            // This just needs to be positioned            setupChild(child, position, y, flow, childrenLeft, selected, true);            return child;        }    }    // Make a new view for this position, or convert an unused view if possible    child = obtainView(position, mIsScrap);    // This needs to be positioned and measured    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);    return child;}</code></pre><p>&nbsp;&nbsp;首先尝试通过recycler的getActiveView获取view，由于没有缓存过任何view，这里是获取不到的，再使用obtainView获取view。代码如下</p><pre><code>View obtainView(int position, boolean[] isScrap) {    isScrap[0] = false;    View scrapView;    scrapView = mRecycler.getScrapView(position);    View child;    if (scrapView != null) {        child = mAdapter.getView(position, scrapView, this);        if (child != scrapView) {            mRecycler.addScrapView(scrapView);            if (mCacheColorHint != 0) {                child.setDrawingCacheBackgroundColor(mCacheColorHint);            }        } else {            isScrap[0] = true;            dispatchFinishTemporaryDetach(child);        }    } else {        child = mAdapter.getView(position, null, this);        if (mCacheColorHint != 0) {            child.setDrawingCacheBackgroundColor(mCacheColorHint);        }    }    return child;}</code></pre><p>&nbsp;&nbsp;首先尝试从recyclerBin中获取scrapView，获取成功后作为参数传入Adapter.getView方法中，若获取失败，则将null传入Adapter.getView方法中。我们知道，在使用ListView时需要自定义Adapter，会复写getView方法，通常如下：</p><pre><code> public View getView(int position, @Nullable View convertView, @NonNull ViewGroup parent) {    Fruit fruit = getItem(position);    View view;    ViewHolder viewHolder;    if (convertView == null) {        view = LayoutInflater.from(getContext()).inflate(resourceId, parent, false);        viewHolder = new ViewHolder();        viewHolder.fruitImage = view.findViewById(R.id.fruit_image);        viewHolder.fruitName = view.findViewById(R.id.fruit_name);        view.setTag(viewHolder);    } else {        view = convertView;        viewHolder = (ViewHolder) view.getTag();    }    viewHolder.fruitImage.setImageResource(fruit.getImageId());    viewHolder.fruitName.setText(fruit.getName());    if(position==0)        view.setBackgroundColor(Color.RED);    return view;}</code></pre><p>&nbsp;&nbsp;我们可以看到，convertView为空时会使用LayoutInflater加载布局，如果不为空的话，直接复用convertView。到这里obtainView逻辑已经清楚了，回到makeAndAddView中，会将obtainView得到的view传入到setUpChild方法中，然后会调用addViewInLayout将该view添加到ListView中。也就是说第一次onLayout 方法使用Inflater加载了刚好一屏幕数据，其他数据并没有加载。</p><p>###2.第二次onLayout<br>&nbsp;&nbsp;我们依然从layoutChild方法开始，代码结构如下：</p><pre><code>protected void layoutChildren(){    int childCount = getChildCount();    switch(mLayoutMode){    }    boolean dataChanged = mDataChanged;    if(dataChanged){    }else{        recycleBin.fillActiveView(childCount,firstPosition);    }    detachAllViewsFromParent();    switch (mLayoutMode){        default:            if(childCount==0)                fillFromTop(childrenTop);            else                fillSpecific(0,childrenTop)    }}</code></pre><p>&nbsp;&nbsp;这次我们可以看到由于childCount已经不是0，代码流程如下：</p><ul><li>recycleBin.fillActiveView():将屏幕中的view缓存到ActiveView[]中</li><li>detachAllViewsFromParent():将第一次onLayout加入到ListView中的所有view从ListView中detach</li><li>fillSpecific（0，childrenTop）将view加载到ListView中</li></ul><p>&nbsp;&nbsp;fillSpecific是第一次onLayout过程中没有用到的方法，这个方法逻辑和fillDown很相似，不过是先加载指定位置view再分别加载两边view，由于传入的position是0，效果上基本和fillDown一样。所有我们还是关注makeAndAddView:</p><pre><code> private View makeAndAddView(int position, int y, boolean flow, int childrenLeft,                            boolean selected) {    View child;    if (!mDataChanged) {        // Try to use an exsiting view for this position        child = mRecycler.getActiveView(position);        if (child != null) {            // Found it -- we&apos;re using an existing child            // This just needs to be positioned            setupChild(child, position, y, flow, childrenLeft, selected, true);            return child;        }    }    // Make a new view for this position, or convert an unused view if possible    child = obtainView(position, mIsScrap);    // This needs to be positioned and measured    setupChild(child, position, y, flow, childrenLeft, selected, mIsScrap[0]);    return child;}</code></pre><p>&nbsp;&nbsp;这次代码逻辑就很简单了，mRecycler.getActiveView从缓存中获取view后直接将view传入setUpChild中，不过与第一次调用该方法不同的是，最后一个参数传入的是true，标记该view是使用的缓存，根据该标记，setUpChild方法内会走到attachViewToParent,将该view attach到ListView中。两次onLayout总体来说是这样的：</p><ul><li>使用inflater加载第一屏数据</li><li>将第一屏数据加入到recycleBin的ActiveViews中，并将这些view从ListView中移除</li><li>将ActiveViews中的view取出，重新attach到ListView中</li></ul><p>&nbsp;&nbsp;也就是说，在onLayout阶段，ActiveView主要是缓存第一次加载的数据，以避免因为两次onLayout产生重复数据</p><h2 id="三、屏幕滑动"><a href="#三、屏幕滑动" class="headerlink" title="三、屏幕滑动"></a>三、屏幕滑动</h2><p>&nbsp;&nbsp;屏幕滑动的处理是写在AbsListView中，触摸监听函数是onTouchEvent（），该函数会针对不同类型的触摸事件进行处理，而在屏幕上滑动事件对应的是ACTION_MOVE,而该case又嵌套一个switch分支，针对TOUCH_MODE处理，我们直接看TOUCH_MODE_SRCOLL,对应手指在屏幕上滑动。在该case内，调用了trackMotionScroll方法，也就是说只要手指在屏幕上滑动，trackMotionScroll就会被调用，trackMotion中核心代码如下：</p><pre><code>final boolean down = incrementalDeltaY&lt;0; if(down){    final int top = listPadding.top - incrementalDeltaY;    for (int i = 0; i &lt; childCount; i++) {        final View child = getChildAt(i);        if (child.getBottom() &gt;= top) {            break;        } else {            count++;            int position = firstPosition + i;            if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) {                mRecycler.addScrapView(child);            }        }    }} else{    final int bottom = getHeight() - listPadding.bottom - incrementalDeltaY;    for (int i = childCount - 1; i &gt;= 0; i--) {        final View child = getChildAt(i);        if (child.getTop() &lt;= bottom) {            break;        } else {            start = i;            count++;            int position = firstPosition + i;            if (position &gt;= headerViewsCount &amp;&amp; position &lt; footerViewsStart) {                mRecycler.addScrapView(child);            }        }    }}</code></pre><p>&nbsp;&nbsp;incrementalDeltaY是上次触发event事件时手指在y方向的改变量，如果小于0说明在屏幕上下滑，进入down为true流程。从ListView第一个child开始判断，只要该view的bottom小于ListView的top，说明该view已经划出了屏幕，调用mRecycler.addScrapView将该view缓存到scrapViews中,用count记录下缓存的数量。这样滑出屏幕的view已经缓存下来了，继续看接下来代码:</p><pre><code>if (count &gt; 0) {    detachViewsFromParent(start, count);}offsetChildrenTopAndBottom(incrementalDeltaY);  if (down) {    mFirstPosition += count;}invalidate();final int absIncrementalDeltaY = Math.abs(incrementalDeltaY);  if (spaceAbove &lt; absIncrementalDeltaY || spaceBelow &lt; absIncrementalDeltaY) {    fillGap(down);}</code></pre><p>代码流程如下：</p><ul><li>调用detachViewFromParent，将滑出屏幕的view从ListView中detach掉</li><li>调用offsetChildrenTopAndBottom按照便宜量平移剩下的子view，实现滑动效果</li><li>调用fillGap处理将要滑动到屏幕内的view</li></ul><p>那我们看fillGap如何处理将要移入屏幕的子view的：</p><pre><code>void fillGap(boolean down) {    final int count = getChildCount();    if (down) {        final int startOffset = count &gt; 0 ? getChildAt(count - 1).getBottom() + mDividerHeight :                getListPaddingTop();        fillDown(mFirstPosition + count, startOffset);        correctTooHigh(getChildCount());    } else {        final int startOffset = count &gt; 0 ? getChildAt(0).getTop() - mDividerHeight :                getHeight() - getListPaddingBottom();        fillUp(mFirstPosition - 1, startOffset);        correctTooLow(getChildCount());    }}</code></pre><p>&nbsp;&nbsp;我们可以看到，方法内部主要是调用了fillDown或者fillUp，我们来回顾下fillDown的逻辑</p><ul><li>从activeView中获取缓存的view</li><li>若第一步获取不成功，则调用obtainView获取view</li><li>obtainView会先尝试复用scrapView中的view</li><li>若上一步复用失败，则使用inflater加载布局来生成view</li><li>将得到的view传入setUpChild中以加入ListView中</li></ul><p>&nbsp;&nbsp;也就是说，在滑动屏幕时，每当有view从屏幕中移出，就先缓存到scrapViews中，再从ListView中移除该view，而每当有view要滑入屏幕中时，会从scrapViews中取出缓存的view,将其中的数据更新为相应位置的数据，再加入到ListView中，这样的循环使得ListView无论加载多少数据，都是固定数量的view在循环利用，内存都不会增加。</p><h2 id="四、总结"><a href="#四、总结" class="headerlink" title="四、总结"></a>四、总结</h2><p>&nbsp;&nbsp;ListView通过activeView解决两次onLayout过程中数据重复问题，通过scrapView解决滑动过程中view复用问题。无论是onLayout过程还是滑动过程，都是采用attach-detach-attach的操作思路，将两个阶段统一为一个抽象操作，以实现代码的复用。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文主要是分析ListView源码，重点关注复用机制。&lt;/p&gt;
    
    </summary>
    
      <category term="caominkang" scheme="http://xgfe.github.io/categories/caominkang/"/>
    
    
      <category term="android" scheme="http://xgfe.github.io/tags/android/"/>
    
      <category term="源码" scheme="http://xgfe.github.io/tags/%E6%BA%90%E7%A0%81/"/>
    
      <category term="listview" scheme="http://xgfe.github.io/tags/listview/"/>
    
  </entry>
  
</feed>
